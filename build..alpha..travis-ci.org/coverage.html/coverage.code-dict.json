{"/home/travis/build/npmtest/node-npmtest-sweet.js/test.js":"/* istanbul instrument in package npmtest_sweet_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sweet.js/lib.npmtest_sweet.js.js":"/* istanbul instrument in package npmtest_sweet_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sweet_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sweet_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sweet.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sweet.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sweet_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sweet_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sweet_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sweet_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sweet_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sweet_js.__dirname + '/lib.npmtest_sweet_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/dist/sweet.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.compile = compile;\n\nvar _babelCore = require('babel-core');\n\nfunction compileModule(entryPath, loader, refererName) {\n  return loader.compile(entryPath, refererName, false);\n}\n\nfunction parse(entryPath, loader, options) {\n  let refererName;\n  if (options != null) {\n    refererName = options.refererName;\n  }\n  return compileModule(entryPath, loader, refererName).parse();\n}\n\nfunction compile(entryPath, loader, options) {\n  let refererName,\n      noBabel = true;\n  if (options != null) {\n    refererName = options.refererName;\n    noBabel = options.noBabel;\n  }\n  let code = compileModule(entryPath, loader, refererName).codegen();\n  if (noBabel) {\n    return {\n      code\n    };\n  }\n  return (0, _babelCore.transform)(code, {\n    babelrc: true\n  });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zd2VldC5qcyJdLCJuYW1lcyI6WyJwYXJzZSIsImNvbXBpbGUiLCJjb21waWxlTW9kdWxlIiwiZW50cnlQYXRoIiwibG9hZGVyIiwicmVmZXJlck5hbWUiLCJvcHRpb25zIiwibm9CYWJlbCIsImNvZGUiLCJjb2RlZ2VuIiwiYmFiZWxyYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFtQmdCQSxLLEdBQUFBLEs7UUFZQUMsTyxHQUFBQSxPOztBQTdCaEI7O0FBU0EsU0FBU0MsYUFBVCxDQUNFQyxTQURGLEVBRUVDLE1BRkYsRUFHRUMsV0FIRixFQUlFO0FBQ0EsU0FBT0QsT0FBT0gsT0FBUCxDQUFlRSxTQUFmLEVBQTBCRSxXQUExQixFQUF1QyxLQUF2QyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0wsS0FBVCxDQUNMRyxTQURLLEVBRUxDLE1BRkssRUFHTEUsT0FISyxFQUlMO0FBQ0EsTUFBSUQsV0FBSjtBQUNBLE1BQUlDLFdBQVcsSUFBZixFQUFxQjtBQUNuQkQsa0JBQWNDLFFBQVFELFdBQXRCO0FBQ0Q7QUFDRCxTQUFPSCxjQUFjQyxTQUFkLEVBQXlCQyxNQUF6QixFQUFpQ0MsV0FBakMsRUFBOENMLEtBQTlDLEVBQVA7QUFDRDs7QUFFTSxTQUFTQyxPQUFULENBQ0xFLFNBREssRUFFTEMsTUFGSyxFQUdMRSxPQUhLLEVBSUw7QUFDQSxNQUFJRCxXQUFKO0FBQUEsTUFBaUJFLFVBQVUsSUFBM0I7QUFDQSxNQUFJRCxXQUFXLElBQWYsRUFBcUI7QUFDbkJELGtCQUFjQyxRQUFRRCxXQUF0QjtBQUNBRSxjQUFVRCxRQUFRQyxPQUFsQjtBQUNEO0FBQ0QsTUFBSUMsT0FBT04sY0FBY0MsU0FBZCxFQUF5QkMsTUFBekIsRUFBaUNDLFdBQWpDLEVBQThDSSxPQUE5QyxFQUFYO0FBQ0EsTUFBSUYsT0FBSixFQUFhO0FBQ1gsV0FBTztBQUNMQztBQURLLEtBQVA7QUFHRDtBQUNELFNBQU8sMEJBQU1BLElBQU4sRUFBWTtBQUNqQkUsYUFBUztBQURRLEdBQVosQ0FBUDtBQUdEIiwiZmlsZSI6InN3ZWV0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB0eXBlIFN3ZWV0TG9hZGVyIGZyb20gJy4vc3dlZXQtbG9hZGVyJztcbmltcG9ydCB7IHRyYW5zZm9ybSBhcyBiYWJlbCB9IGZyb20gJ2JhYmVsLWNvcmUnO1xuXG50eXBlIENvbXBpbGVPcHRpb25zID0ge1xuICByZWZlcmVyTmFtZT86IHN0cmluZyxcbiAgZGVidWdTdG9yZT86IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gIG5vQmFiZWw/OiBib29sZWFuLFxuICBsb2FkZXI6IFN3ZWV0TG9hZGVyLFxufTtcblxuZnVuY3Rpb24gY29tcGlsZU1vZHVsZShcbiAgZW50cnlQYXRoOiBzdHJpbmcsXG4gIGxvYWRlcjogU3dlZXRMb2FkZXIsXG4gIHJlZmVyZXJOYW1lPzogc3RyaW5nLFxuKSB7XG4gIHJldHVybiBsb2FkZXIuY29tcGlsZShlbnRyeVBhdGgsIHJlZmVyZXJOYW1lLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShcbiAgZW50cnlQYXRoOiBzdHJpbmcsXG4gIGxvYWRlcjogU3dlZXRMb2FkZXIsXG4gIG9wdGlvbnM/OiBDb21waWxlT3B0aW9ucyxcbikge1xuICBsZXQgcmVmZXJlck5hbWU7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICByZWZlcmVyTmFtZSA9IG9wdGlvbnMucmVmZXJlck5hbWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGVNb2R1bGUoZW50cnlQYXRoLCBsb2FkZXIsIHJlZmVyZXJOYW1lKS5wYXJzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZShcbiAgZW50cnlQYXRoOiBzdHJpbmcsXG4gIGxvYWRlcjogU3dlZXRMb2FkZXIsXG4gIG9wdGlvbnM/OiBDb21waWxlT3B0aW9ucyxcbikge1xuICBsZXQgcmVmZXJlck5hbWUsIG5vQmFiZWwgPSB0cnVlO1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgcmVmZXJlck5hbWUgPSBvcHRpb25zLnJlZmVyZXJOYW1lO1xuICAgIG5vQmFiZWwgPSBvcHRpb25zLm5vQmFiZWw7XG4gIH1cbiAgbGV0IGNvZGUgPSBjb21waWxlTW9kdWxlKGVudHJ5UGF0aCwgbG9hZGVyLCByZWZlcmVyTmFtZSkuY29kZWdlbigpO1xuICBpZiAobm9CYWJlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2RlLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJhYmVsKGNvZGUsIHtcbiAgICBiYWJlbHJjOiB0cnVlLFxuICB9KTtcbn1cbiJdfQ==","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/debug.js":"'use strict';\n/*\nThis file makes debugging sweet.js easier. Uses the built version of sweet.js\nto compile 'test.js'. You can use node-inspector to step through the expansion\nprocess:\n\n\tnpm install -g node-inspector\n\tnode-debug debug.js\n*/\n\nrequire('babel-register');\nvar compile = require('./src/sweet.js').compile;\nvar NodeLoader = require('./src/node-loader').default;\n\n\ndebugger;\n\nlet result = compile('./test.js', new NodeLoader(__dirname));\nconsole.log(result.code);\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/sweet.js":"// @flow\nimport type SweetLoader from './sweet-loader';\nimport { transform as babel } from 'babel-core';\n\ntype CompileOptions = {\n  refererName?: string,\n  debugStore?: Map<string, string>,\n  noBabel?: boolean,\n  loader: SweetLoader,\n};\n\nfunction compileModule(\n  entryPath: string,\n  loader: SweetLoader,\n  refererName?: string,\n) {\n  return loader.compile(entryPath, refererName, false);\n}\n\nexport function parse(\n  entryPath: string,\n  loader: SweetLoader,\n  options?: CompileOptions,\n) {\n  let refererName;\n  if (options != null) {\n    refererName = options.refererName;\n  }\n  return compileModule(entryPath, loader, refererName).parse();\n}\n\nexport function compile(\n  entryPath: string,\n  loader: SweetLoader,\n  options?: CompileOptions,\n) {\n  let refererName, noBabel = true;\n  if (options != null) {\n    refererName = options.refererName;\n    noBabel = options.noBabel;\n  }\n  let code = compileModule(entryPath, loader, refererName).codegen();\n  if (noBabel) {\n    return {\n      code,\n    };\n  }\n  return babel(code, {\n    babelrc: true,\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/debug-test262.js":"'use strict';\n/*\nThis file makes debugging sweet.js easier. Uses the built version of sweet.js\nto compile 'test.js'. You can use node-inspector to step through the expansion\nprocess:\n\n\tnpm install -g node-inspector\n\tnode-debug debug.js\n*/\n\nrequire('babel-register');\nvar compile = require('./src/sweet-loader.js').default;\nlet fs = require('fs');\n\ndebugger;\n\nconst PARSER_TEST_DIR = './test/test262-parser-tests';\n\nlet pass = fs.readdirSync(`${PARSER_TEST_DIR}/pass`);\nlet fail = fs.readdirSync(`${PARSER_TEST_DIR}/fail`);\n\n// TODO: make these pass\nconst passExcluded = [\n  '1012.script.js',\n  '1051.module.js',\n  '1052.module.js',\n  '1053.module.js',\n  '1054.module.js',\n  '1055.module.js',\n  '1056.module.js',\n  '1057.module.js',\n  '1058.module.js',\n  '1059.module.js',\n  '106.script.js',\n  '1060.module.js',\n  '1061.module.js',\n  '1062.module.js',\n  '1063.module.js',\n  '1064.module.js',\n  '1065.module.js',\n  '1066.module.js',\n  '1067.module.js',\n  '1068.module.js',\n  '1069.module.js',\n  '1070.module.js',\n  '1073.script.js',\n  '1074.script.js',\n  '1077.script.js',\n  '1116.module.js',\n  '1117.module.js',\n  '1118.module.js',\n  '1119.module.js',\n  '1120.module.js',\n  '1121.module.js',\n  '1122.module.js',\n  '1123.module.js',\n  '1124.module.js',\n  '1125.module.js',\n  '1126.module.js',\n  '1127.module.js',\n  '1128.script.js',\n  '1129.script.js',\n  '1130.script.js',\n  '1131.script.js',\n  '1138.script.js',\n  '1166.script.js',\n  '117.script.js',\n  '1202.script.js',\n  '1239.script.js',\n  '1240.script.js',\n  '1245.script.js',\n  '1246.script.js',\n  '1247.script.js',\n  '1248.script.js',\n  '128.script.js',\n  '1307.script.js',\n  '1319.script.js',\n  '1334.script.js',\n  '1335.script.js',\n  '1364.script.js',\n  '1370.script.js',\n  '140.script.js',\n  '1427.script.js',\n  '1428.script.js',\n  '1429.script.js',\n  '1430.script.js',\n  '1431.script.js',\n  '1432.script.js',\n  '1434.script.js',\n  '1467.script.js',\n  '1623.script.js',\n  '1638.script.js',\n  '1686.module.js',\n  '1687.module.js',\n  '1688.module.js',\n  '1689.module.js',\n  '1690.module.js',\n  '1691.module.js',\n  '1692.module.js',\n  '1693.module.js',\n  '1694.module.js',\n  '1695.module.js',\n  '1698.module.js',\n  '1699.module.js',\n  '1700.module.js',\n  '1701.module.js',\n  '1736.script.js',\n  '1739.script.js',\n  '1745.script.js',\n  '1779.script.js',\n  '1789.script.js',\n  '1844.script.js',\n  '1954.script.js',\n  '285.script.js',\n  '290.script.js',\n  '295.script.js',\n  '296.script.js',\n  '297.script.js',\n  '301.script.js',\n  '350.script.js',\n  '37.script.js',\n  '389.script.js',\n  '391.script.js',\n  '393.script.js',\n  '397.module.js',\n  '398.module.js',\n  '400.module.js',\n  '401.module.js',\n  '402.module.js',\n  '403.module.js',\n  '404.module.js',\n  '405.module.js',\n  '406.module.js',\n  '407.module.js',\n  '408.module.js',\n  '409.module.js',\n  '411.module.js',\n  '412.module.js',\n  '413.module.js',\n  '414.module.js',\n  '415.module.js',\n  '416.module.js',\n  '417.module.js',\n  '418.module.js',\n  '419.module.js',\n  '420.module.js',\n  '516.script.js',\n  '523.module.js',\n  '533.script.js',\n  '538.script.js',\n  '546.module.js',\n  '551.module.js',\n  '572.script.js',\n  '583.script.js',\n  '608.script.js',\n  '679.script.js',\n  '680.script.js',\n  '681.script.js',\n  '84.script.js',\n  '95.script.js',\n  '993.script.js',\n  '995.script.js',\n]\n\nfunction mkTester(subdir) {\n  function f(fname) {\n    let result = compile(`${PARSER_TEST_DIR}/${subdir}/${fname}`).codegen()\n    if (result == null) {\n      throw new Error('un expected null result');\n    }\n  }\n  return f;\n}\n\nlet passTest = mkTester('pass')\n\npass.filter(f => !passExcluded.includes(f)).forEach(f => {\n  console.log(f);\n  passTest(f);\n});\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/sweet-loader.js":"// @flow\nimport read from './reader/token-reader';\nimport { freshScope } from './scope';\nimport Env from './env';\nimport { List } from 'immutable';\nimport Compiler from './compiler';\nimport { ALL_PHASES } from './syntax';\nimport BindingMap from './binding-map.js';\nimport Term from 'sweet-spec';\nimport SweetModule from './sweet-module';\nimport * as _ from 'ramda';\nimport ScopeReducer from './scope-reducer';\nimport { wrapInTerms } from './macro-context';\nimport { transform as babel } from 'babel-core';\nimport Store from './store';\n\nexport const phaseInModulePathRegexp = /(.*):(\\d+)\\s*$/;\n\nexport type Context = {\n  bindings: any,\n  templateMap: any,\n  getTemplateIdentifier: any,\n  loader: any,\n  transform: any,\n  phase: number,\n  store: Store,\n};\n\nexport type LoaderOptions = {\n  noBabel?: boolean,\n  logging?: boolean,\n};\n\nexport default class SweetLoader {\n  sourceCache: Map<string, string>;\n  compiledCache: Map<string, SweetModule>;\n  context: any;\n  baseDir: string;\n  logging: boolean;\n\n  constructor(baseDir: string, options?: LoaderOptions = {}) {\n    this.sourceCache = new Map();\n    this.compiledCache = new Map();\n    this.baseDir = baseDir;\n    this.logging = options.logging || false;\n\n    let bindings = new BindingMap();\n    let templateMap = new Map();\n    let tempIdent = 0;\n    this.context = {\n      phase: 0,\n      bindings,\n      templateMap,\n      getTemplateIdentifier: () => ++tempIdent,\n      loader: this,\n      transform: c => {\n        if (options.noBabel) {\n          return {\n            code: c,\n          };\n        }\n        return babel(c, {\n          babelrc: true,\n        });\n      },\n    };\n  }\n\n  normalize(name: string, refererName?: string, refererAddress?: string) {\n    // takes `..path/to/source.js:<phase>`\n    // gives `/abs/path/to/source.js:<phase>`\n    // missing phases are turned into 0\n    if (!phaseInModulePathRegexp.test(name)) {\n      return `${name}:0`;\n    }\n    return name;\n  }\n\n  locate({ name, metadata }: { name: string, metadata: {} }) {\n    // takes `/abs/path/to/source.js:<phase>`\n    // gives { path: '/abs/path/to/source.js', phase: <phase> }\n    let match = name.match(phaseInModulePathRegexp);\n    if (match && match.length >= 3) {\n      return {\n        path: match[1],\n        phase: parseInt(match[2], 10),\n      };\n    }\n    throw new Error(`Module ${name} is missing phase information`);\n  }\n\n  fetch({\n    name,\n    address,\n    metadata,\n  }: { name: string, address: { path: string, phase: number }, metadata: {} }) {\n    throw new Error('No default fetch defined');\n  }\n\n  translate({\n    name,\n    address,\n    source,\n    metadata,\n  }: {\n    name: string,\n    address: { path: string, phase: number },\n    source: string,\n    metadata: {},\n  }) {\n    let src = this.compiledCache.get(address.path);\n    if (src != null) {\n      return src;\n    }\n    let compiledModule = this.compileSource(source, metadata);\n    this.compiledCache.set(address.path, compiledModule);\n    return compiledModule;\n  }\n\n  instantiate({\n    name,\n    address,\n    source,\n    metadata,\n  }: {\n    name: string,\n    address: { path: string, phase: number },\n    source: SweetModule,\n    metadata: {},\n  }) {\n    throw new Error('Not implemented yet');\n  }\n\n  eval(source: string) {\n    return (0, eval)(source);\n  }\n\n  load(entryPath: string) {\n    let metadata = {};\n    let name = this.normalize(entryPath);\n    let address = this.locate({ name, metadata });\n    let source = this.fetch({ name, address, metadata });\n    source = this.translate({ name, address, source, metadata });\n    return this.instantiate({ name, address, source, metadata });\n  }\n\n  // skip instantiate\n  compile(\n    entryPath: string,\n    refererName?: string,\n    enforceLangPragma?: boolean = true,\n  ) {\n    let metadata = {\n      enforceLangPragma,\n      entryPath,\n    };\n    let name = this.normalize(entryPath, refererName);\n    let address = this.locate({ name, metadata });\n    let source = this.fetch({ name, address, metadata });\n    return this.translate({ name, address, source, metadata });\n  }\n\n  get(entryPath: string, entryPhase: number) {\n    return this.compile(`${entryPath}:${entryPhase}`);\n  }\n\n  read(source: string): List<Term> {\n    return wrapInTerms(read(source));\n  }\n\n  freshStore() {\n    return new Store({});\n  }\n\n  compileSource(source: string, metadata: any) {\n    let directive = getLangDirective(source);\n    if (directive == null && metadata.enforceLangPragma) {\n      // eslint-disable-next-line no-console\n      if (this.logging) console.log(`skipping module ${metadata.entryPath}`);\n      return new SweetModule(List.of());\n    }\n    let stxl = this.read(source);\n    let outScope = freshScope('outsideEdge');\n    let inScope = freshScope('insideEdge0');\n    // the compiler starts at phase 0, with an empty environment and store\n    let compiler = new Compiler(\n      0,\n      new Env(),\n      this.freshStore(),\n      _.merge(this.context, {\n        currentScope: [outScope, inScope],\n      }),\n    );\n    return new SweetModule(\n      compiler.compile(\n        stxl.map(s =>\n          s.reduce(\n            new ScopeReducer(\n              [\n                { scope: outScope, phase: ALL_PHASES, flip: false },\n                { scope: inScope, phase: 0, flip: false },\n              ],\n              this.context.bindings,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nconst langDirectiveRegexp = /\\s*('lang .*')/;\nfunction getLangDirective(source: string) {\n  let match = source.match(langDirectiveRegexp);\n  if (match) {\n    return match[1];\n  }\n  return null;\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/helpers.js":"'lang sweet.js';\n\nvar TypeCodes = {\n  Identifier: 0,\n  Keyword: 1,\n  Punctuator: 2,\n  NumericLiteral: 3,\n  StringLiteral: 4,\n  TemplateElement: 5,\n  Template: 6,\n  RegExp: 7,\n};\n\nfunction check(obj, type) {\n  return obj && obj.type === 'RawSyntax' && obj.value.token.typeCode === type;\n}\n\nexport function unwrap(obj) {\n  var hasTok = obj && obj.value && obj.value.token;\n  if (hasTok && obj.value.token.typeCode === TypeCodes.StringLiteral) {\n    return {\n      value: obj.value.token.str,\n    };\n  } else if (hasTok && obj.value.token.typeCode !== TypeCodes.Template) {\n    return {\n      value: obj.value.token.value,\n    };\n  } else if (hasTok && obj.value.token.typeCode === TypeCodes.Template) {\n    return {\n      value: obj.value.token.items,\n    };\n  } else if (obj && obj.type === 'RawDelimiter') {\n    return {\n      value: obj.inner,\n    };\n  }\n  return {};\n}\n\nexport function isIdentifier(obj) {\n  return check(obj, TypeCodes.Identifier);\n}\n\nexport function fromIdentifier(obj, x) {\n  return obj.value.fromIdentifier(x);\n}\n\nexport function isKeyword(obj) {\n  return check(obj, TypeCodes.Keyword);\n}\n\nexport function fromKeyword(obj, x) {\n  return obj.value.fromKeyword(x);\n}\n\nexport function isPunctuator(obj) {\n  return check(obj, TypeCodes.Punctuator);\n}\n\nexport function fromPunctuator(obj, x) {\n  return obj.value.fromPunctuator(x);\n}\n\nexport function isNumericLiteral(obj) {\n  return check(obj, TypeCodes.NumericLiteral);\n}\n\nexport function fromNumericLiteral(obj, x) {\n  return obj.value.fromNumber(x);\n}\n\nexport function isStringLiteral(obj) {\n  return check(obj, TypeCodes.StringLiteral);\n}\n\nexport function fromStringLiteral(obj, x) {\n  return obj.value.fromString(x);\n}\n\nexport function isTemplateElement(obj) {\n  return check(obj, TypeCodes.TemplateElement);\n}\n\nexport function isTemplate(obj) {\n  return check(obj, TypeCodes.Template);\n}\n\nexport function isRegExp(obj) {\n  return check(obj, TypeCodes.RegExp);\n}\n\nexport function isParens(obj) {\n  return obj && obj.type === 'RawDelimiter' && obj.kind === 'parens';\n}\n\nexport function fromParens(obj, x) {\n  return obj.value.from('parens', x);\n}\n\nexport function isBrackets(obj) {\n  return obj && obj.type === 'RawDelimiter' && obj.kind === 'brackets';\n}\n\nexport function fromBrackets(obj, x) {\n  return obj.value.from('brackets', x);\n}\n\nexport function isBraces(obj) {\n  return obj && obj.type === 'RawDelimiter' && obj.kind === 'braces';\n}\n\nexport function fromBraces(obj, x) {\n  return obj.value.from('braces', x);\n}\n\nexport function isSyntaxTemplate(obj) {\n  return obj && obj.type === 'RawDelimiter' && obj.kind === 'syntaxTemplate';\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/mod.js":"    #lang 'base';\n    export function id(x) {\n      return x;\n    }","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/printAst.js":"var parse = require(\"./build/src/sweet.js\").parse;\nvar readFile = require(\"fs\").readFileSync;\nvar moduleResolver = require('./build/src/node-module-resolver').default;\nvar moduleLoader = require('./build/src/node-module-loader').default;\nvar transform = require('babel-core').transform;\n\nconsole.log(JSON.stringify(parse(readFile(\"test.js\", \"utf8\"), {\n  cwd: __dirname,\n\ttransform: transform,\n\tfilename: './test.js',\n  moduleResolver: moduleResolver,\n  moduleLoader: moduleLoader\n}), null, 2));\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/prism.js":"/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */(function(){var e=/\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i,t=self.Prism={languages:{insertBefore:function(e,n,r,i){i=i||t.languages;var s=i[e],o={};for(var u in s)if(s.hasOwnProperty(u)){if(u==n)for(var a in r)r.hasOwnProperty(a)&&(o[a]=r[a]);o[u]=s[u]}return i[e]=o},DFS:function(e,n){for(var r in e){n.call(e,r,e[r]);Object.prototype.toString.call(e)===\"[object Object]\"&&t.languages.DFS(e[r],n)}}},highlightAll:function(e,n){var r=document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');for(var i=0,s;s=r[i++];)t.highlightElement(s,e===!0,n)},highlightElement:function(r,i,s){var o,u,a=r;while(a&&!e.test(a.className))a=a.parentNode;if(a){o=(a.className.match(e)||[,\"\"])[1];u=t.languages[o]}if(!u)return;r.className=r.className.replace(e,\"\").replace(/\\s+/g,\" \")+\" language-\"+o;a=r.parentNode;/pre/i.test(a.nodeName)&&(a.className=a.className.replace(e,\"\").replace(/\\s+/g,\" \")+\" language-\"+o);var f=r.textContent.trim();if(!f)return;f=f.replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\\u00a0/g,\" \");var l={element:r,language:o,grammar:u,code:f};t.hooks.run(\"before-highlight\",l);if(i&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){l.highlightedCode=n.stringify(JSON.parse(e.data));l.element.innerHTML=l.highlightedCode;s&&s.call(l.element);t.hooks.run(\"after-highlight\",l)};c.postMessage(JSON.stringify({language:l.language,code:l.code}))}else{l.highlightedCode=t.highlight(l.code,l.grammar);l.element.innerHTML=l.highlightedCode;s&&s.call(r);t.hooks.run(\"after-highlight\",l)}},highlight:function(e,r){return n.stringify(t.tokenize(e,r))},tokenize:function(e,n){var r=t.Token,i=[e],s=n.rest;if(s){for(var o in s)n[o]=s[o];delete n.rest}e:for(var o in n){if(!n.hasOwnProperty(o)||!n[o])continue;var u=n[o],a=u.inside,f=!!u.lookbehind||0;u=u.pattern||u;for(var l=0;l<i.length;l++){var c=i[l];if(i.length>e.length)break e;if(c instanceof r)continue;u.lastIndex=0;var h=u.exec(c);if(h){f&&(f=h[1].length);var p=h.index-1+f,h=h[0].slice(f),d=h.length,v=p+d,m=c.slice(0,p+1),g=c.slice(v+1),y=[l,1];m&&y.push(m);var b=new r(o,a?t.tokenize(h,a):h);y.push(b);g&&y.push(g);Array.prototype.splice.apply(i,y)}}}return i},hooks:{all:{},add:function(e,n){var r=t.hooks.all;r[e]=r[e]||[];r[e].push(n)},run:function(e,n){var r=t.hooks.all[e];if(!r||!r.length)return;for(var i=0,s;s=r[i++];)s(n)}}},n=t.Token=function(e,t){this.type=e;this.content=t};n.stringify=function(e){if(typeof e==\"string\")return e;if(Object.prototype.toString.call(e)==\"[object Array]\"){for(var r=0;r<e.length;r++)e[r]=n.stringify(e[r]);return e.join(\"\")}var i={type:e.type,content:n.stringify(e.content),tag:\"span\",classes:[\"token\",e.type],attributes:{}};i.type==\"comment\"&&(i.attributes.spellcheck=\"true\");t.hooks.run(\"wrap\",i);var s=\"\";for(var o in i.attributes)s+=o+'=\"'+(i.attributes[o]||\"\")+'\"';return\"<\"+i.tag+' class=\"'+i.classes.join(\" \")+'\" '+s+\">\"+i.content+\"</\"+i.tag+\">\"};if(!self.document){self.addEventListener(\"message\",function(e){var n=JSON.parse(e.data),r=n.language,i=n.code;self.postMessage(JSON.stringify(t.tokenize(i,t.languages[r])));self.close()},!1);return}var r=document.getElementsByTagName(\"script\");r=r[r.length-1];if(r){t.filename=r.src;document.addEventListener&&!r.hasAttribute(\"data-manual\")&&document.addEventListener(\"DOMContentLoaded\",t.highlightAll)}})();\nPrism.languages.markup={comment:/&lt;!--[\\w\\W]*?--(&gt;|&gt;)/g,prolog:/&lt;\\?.+?\\?&gt;/,doctype:/&lt;!DOCTYPE.+?&gt;/,cdata:/&lt;!\\[CDATA\\[[\\w\\W]+?]]&gt;/i,tag:{pattern:/&lt;\\/?[\\w:-]+\\s*[\\w\\W]*?&gt;/gi,inside:{tag:{pattern:/^&lt;\\/?[\\w:-]+/i,inside:{punctuation:/^&lt;\\/?/,namespace:/^[\\w-]+?:/}},\"attr-value\":{pattern:/=(('|\")[\\w\\W]*?(\\2)|[^\\s>]+)/gi,inside:{punctuation:/=/g}},punctuation:/\\/?&gt;/g,\"attr-name\":{pattern:/[\\w:-]+/g,inside:{namespace:/^[\\w-]+?:/}}}},entity:/&amp;#?[\\da-z]{1,8};/gi};Prism.hooks.add(\"wrap\",function(e){e.type===\"entity\"&&(e.attributes.title=e.content.replace(/&amp;/,\"&\"))});\nPrism.languages.javascript={comment:{pattern:/(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*?(\\r?\\n|$))/g,lookbehind:!0},string:/(\"|')(\\\\?.)*?\\1/g,regex:{pattern:/(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/g,lookbehind:!0},keyword:/\\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\\b/g,\"boolean\":/\\b(true|false)\\b/g,number:/\\b-?(0x)?\\d*\\.?\\d+\\b/g,operator:/[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\\|?\\||\\?|\\*|\\//g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\\];(),.:]/g};Prism.languages.markup&&Prism.languages.insertBefore(\"markup\",\"tag\",{script:{pattern:/(&lt;|<)script[\\w\\W]*?(>|&gt;)[\\w\\W]*?(&lt;|<)\\/script(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)script[\\w\\W]*?(>|&gt;)|(&lt;|<)\\/script(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript}}});\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/profile.js":"/**\n * Copyright 2015 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar fs = require('fs');\nvar path = require('path');\nvar parse = require('./build/src/sweet').parse;\nvar NodeLoader = require('./build/src/node-loader').default;\n\nfunction benchmarkParsing(fileName) {\n  var loader = new NodeLoader(path.dirname(fs.realpathSync(__filename)));\n  var start = Date.now(), N = 100;\n  for (var i = 0; i < N; i++) {\n    parse(fileName, loader);\n  }\n  var time = Date.now() - start;\n  console.log((time / N).toFixed(2) + \"ms\");\n}\n\nbenchmarkParsing('./node_modules/angular/angular.js');\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/webpack.config.js":"module.exports = {\n\tentry: './build/src/browser-sweet.js',\n\toutput: {\n\t\tpath: __dirname + '/browser/scripts',\n\t\tlibrary: \"sweet\",\n\t\tlibraryTarget: 'amd',\n\t\tfilename: 'sweet.js'\n\t}\n};","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/editor/codemirror.js":"// CodeMirror version 3.0\n//\n// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  var ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = /MSIE [1-7]\\b/.test(navigator.userAgent);\n  var ie_lt9 = /MSIE [1-8]\\b/.test(navigator.userAgent);\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n    \n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var display = this.display = makeDisplay(place);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.view = makeView(new BranchChunk([new LeafChunk([makeLine(\"\", null, textHeight(display))])]));\n    this.nextOpId = 0;\n    loadMode(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n\n    // Initialize the content.\n    this.setValue(options.value || \"\");\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie) setTimeout(bind(resetInput, this, true), 20);\n    this.view.history = makeHistory();\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place) {\n    var d = {};\n    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none;\");\n    input.setAttribute(\"wrap\", \"off\"); input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\");\n    // Wraps and hides input textarea\n    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 1px\")], \"CodeMirror-hscrollbar\");\n    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"width: 1px\")], \"CodeMirror-vscrollbar\");\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt(\"div\");\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt(\"pre\", \"\\u00a0\", \"CodeMirror-cursor\");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt(\"pre\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\");\n    // Used to measure text size\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt(\"div\", \"\\u00a0\", null, \"position: absolute; height: \" + scrollerCutOff + \"px\");\n    // Will contain the gutters, if any\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Helper element to properly size the gutter backgrounds\n    var scrollerInner = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], null, \"position: relative; min-height: 100%\");\n    // Provides scrolling\n    d.scroller = elt(\"div\", [scrollerInner], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.scroller], \"CodeMirror\");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = \"1px\"; d.inputDiv.style.position = \"absolute\"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = \"18px\";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.showingFrom = d.showingTo = d.lastSizeC = 0;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = \"\";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n    // True when a drag from the editor is active\n    d.draggingText = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Used to adjust overwrite behaviour when a paste has been\n    // detected\n    d.pasteIncoming = false;\n\n    return d;\n  }\n\n  // VIEW CONSTRUCTOR\n\n  function makeView(doc) {\n    var selPos = {line: 0, ch: 0};\n    return {\n      doc: doc,\n      // frontier is the point up to which the content has been parsed,\n      frontier: 0, highlight: new Delayed(),\n      sel: {from: selPos, to: selPos, head: selPos, anchor: selPos, shift: false, extend: false},\n      scrollTop: 0, scrollLeft: 0,\n      overwrite: false, focused: false,\n      // Tracks the maximum line length so that\n      // the horizontal scrollbar can be kept\n      // static when scrolling.\n      maxLine: getLine(doc, 0),\n      maxLineLength: 0,\n      maxLineChanged: false,\n      suppressEdits: false,\n      goalColumn: null,\n      cantEdit: false,\n      keyMaps: []\n    };\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    var doc = cm.view.doc;\n    cm.view.mode = CodeMirror.getMode(cm.options, cm.options.mode);\n    doc.iter(0, doc.size, function(line) { line.stateAfter = null; });\n    cm.view.frontier = 0;\n    startWorker(cm, 100);\n  }\n\n  function wrappingChanged(cm) {\n    var doc = cm.view.doc, th = textHeight(cm.display);\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += \" CodeMirror-wrap\";\n      var perLine = cm.display.scroller.clientWidth / charWidth(cm.display) - 3;\n      doc.iter(0, doc.size, function(line) {\n        if (line.height == 0) return;\n        var guess = Math.ceil(line.text.length / perLine) || 1;\n        if (guess != 1) updateLineHeight(line, guess * th);\n      });\n      cm.display.sizer.style.minWidth = \"\";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n      computeMaxLength(cm.view);\n      doc.iter(0, doc.size, function(line) {\n        if (line.height != 0) updateLineHeight(line, th);\n      });\n    }\n    regChange(cm, 0, doc.size);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm.display, cm.view.doc.height);}, 100);\n  }\n\n  function keyMapChanged(cm) {\n    var style = keyMap[cm.options.keyMap].style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n      (style ? \" cm-keymap-\" + style : \"\");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    updateDisplay(cm, true);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(view) {\n    view.maxLine = getLine(view.doc, 0);\n    view.maxLineLength = lineLength(view.doc, view.maxLine);\n    view.maxLineChanged = true;\n    view.doc.iter(1, view.doc.size, function(line) {\n      var len = lineLength(view.doc, line);\n      if (len > view.maxLineLength) {\n        view.maxLineLength = len;\n        view.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = false;\n    for (var i = 0; i < options.gutters.length; ++i) {\n      if (options.gutters[i] == \"CodeMirror-linenumbers\") {\n        if (options.lineNumbers) found = true;\n        else options.gutters.splice(i--, 1);\n      }\n    }\n    if (!found && options.lineNumbers)\n      options.gutters.push(\"CodeMirror-linenumbers\");\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(d /* display */, docHeight) {\n    var totalHeight = docHeight + 2 * paddingTop(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + \"px\";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;\n    var needsV = scrollHeight > d.scroller.clientHeight;\n    if (needsV) {\n      d.scrollbarV.style.display = \"block\";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarV.firstChild.style.height = \n        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + \"px\";\n    } else d.scrollbarV.style.display = \"\";\n    if (needsH) {\n      d.scrollbarH.style.display = \"block\";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + \"px\";\n    } else d.scrollbarH.style.display = \"\";\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0)\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? \"18px\" : \"12px\";\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == \"number\") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && !display.gutters.firstChild) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.view.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + \"px\";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.view.doc, last = lineNumberFor(cm.options, doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo;\n    var updated = updateDisplayInner(cm, changes, viewPort);\n    if (updated) {\n      signalLater(cm, cm, \"update\", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, cm, \"viewportChange\", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    updateSelection(cm);\n    updateScrollbars(cm.display, cm.view.doc.height);\n\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, viewPort) {\n    var display = cm.display, doc = cm.view.doc;\n    if (!display.wrapper.clientWidth) {\n      display.showingFrom = display.showingTo = display.viewOffset = 0;\n      return;\n    }\n\n    // Compute the new visible window\n    // If scrollTop is specified, use that to determine which lines\n    // to render instead of the current scrollbar position.\n    var visible = visibleLines(display, doc, viewPort);\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (changes !== true && changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (changes && maybeUpdateLineNumberWidth(cm))\n      changes = true;\n    display.sizer.style.marginLeft = display.scrollbarH.style.left = display.gutters.offsetWidth + \"px\";\n\n    // When merged lines are present, the line that needs to be\n    // redrawn might not be the one that was changed.\n    if (changes !== true && sawCollapsedSpans)\n      for (var i = 0; i < changes.length; ++i) {\n        var ch = changes[i], merged;\n        while (merged = collapsedSpanAtStart(getLine(doc, ch.from))) {\n          var from = merged.find().from.line;\n          if (ch.diff) ch.diff -= ch.from - from;\n          ch.from = from;\n        }\n      }\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = changes === true ? 0 : Infinity;\n    if (cm.options.lineNumbers && changes && changes !== true)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff) { positionsChangedFrom = changes[i].from; break; }\n\n    var from = Math.max(visible.from - cm.options.viewportMargin, 0);\n    var to = Math.min(doc.size, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = display.showingFrom;\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(doc.size, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < doc.size && lineIsHidden(getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = changes === true ? [] :\n      computeIntact([{from: display.showingFrom, to: display.showingTo}], changes);\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo)\n      return;\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = \"\";\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) display.lastSizeC = display.wrapper.clientHeight;\n    display.showingFrom = from; display.showingTo = to;\n    startWorker(cm, 100);\n\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001)\n        updateLineHeight(node.lineObj, height);\n    }\n    display.viewOffset = heightAtLine(cm, getLine(doc, from));\n    // Position the mover div to align with the current virtual scroll position\n    display.mover.style.top = display.viewOffset + \"px\";\n    return true;\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    // IE does bad things to nodes when .innerHTML = \"\" is used on a parent\n    // we still need widgets and markers intact to add back to the new content later\n    if (!intact.length && !ie && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n        node.lineObj = null;\n      } else {\n        container.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineNo = from;\n    cm.view.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineNo) nextIntact = intact.shift();\n      if (lineIsHidden(line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n      } else if (nextIntact && nextIntact.from <= lineNo && nextIntact.to > lineNo) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineNo && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineNo));\n        cur = cur.nextSibling;\n      } else {\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineNo, dims);\n        container.insertBefore(lineNode, cur);\n        lineNode.lineObj = line;\n      }\n      ++lineNo;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims) {\n    var lineElement = lineContent(cm, line);\n    var markers = line.gutterMarkers, display = cm.display;\n\n    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass &&\n        (!line.widgets || !line.widgets.length)) return lineElement;\n\n    // Lines with gutter elements or a background class need\n    // to be wrapped again, and have the extra elements added\n    // to the wrapper div\n\n    var wrap = elt(\"div\", null, line.wrapClass, \"position: relative\");\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.appendChild(elt(\"div\", null, null, \"position: absolute; left: \" +\n                                            dims.fixedPos + \"px\"));\n      wrap.alignable = [gutterWrap];\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineNo),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + display.lineNumInnerWidth + \"px\"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                       dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n        }\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (line.bgClass)\n      wrap.appendChild(elt(\"div\", \"\\u00a0\", line.bgClass + \" CodeMirror-linebackground\"));\n    wrap.appendChild(lineElement);\n    if (line.widgets)\n      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n        var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n        node.widget = widget;\n        if (widget.noHScroll) {\n          (wrap.alignable || (wrap.alignable = [])).push(node);\n          var width = dims.wrapperWidth;\n          node.style.left = dims.fixedPos + \"px\";\n          if (!widget.coverGutter) {\n            width -= dims.gutterTotalWidth;\n            node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n          }\n          node.style.width = width + \"px\";\n        }\n        if (widget.coverGutter) {\n          node.style.zIndex = 5;\n          node.style.position = \"relative\";\n          if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n        }\n        if (widget.above)\n          wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n        else\n          wrap.appendChild(node);\n      }\n\n    if (ie_lt8) wrap.style.zIndex = 2;\n    return wrap;\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.view.sel.from, cm.view.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = \"none\";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = \"none\";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    var headPos = cursorCoords(cm, cm.view.sel.head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                      headPos.top + lineOff.top - wrapOff.top)) + \"px\";\n    display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                       headPos.left + lineOff.left - wrapOff.left)) + \"px\";\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.view.sel.head, \"div\");\n    display.cursor.style.left = pos.left + \"px\";\n    display.cursor.style.top = pos.top + \"px\";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n    display.cursor.style.display = \"\";\n\n    if (pos.other) {\n      display.otherCursor.style.display = \"\";\n      display.otherCursor.style.left = pos.other.left + \"px\";\n      display.otherCursor.style.top = pos.other.top + \"px\";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    } else { display.otherCursor.style.display = \"none\"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.view.doc, sel = cm.view.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? clientWidth - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg, retTop) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;\n      function coords(ch) {\n        return charCoords(cm, {line: line, ch: ch}, \"div\", lineObj);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(dir == \"rtl\" ? to - 1 : from);\n        var rightPos = coords(dir == \"rtl\" ? from : to - 1);\n        var left = leftPos.left, right = rightPos.right;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (fromArg == null && from == 0) left = pl;\n        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return rVal;\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromObj = getLine(doc, sel.from.line);\n      var cur = fromObj, merged, path = [sel.from.line, sel.from.ch], singleLine;\n      while (merged = collapsedSpanAtEnd(cur)) {\n        var found = merged.find();\n        path.push(found.from.ch, found.to.line, found.to.ch);\n        if (found.to.line == sel.to.line) {\n          path.push(sel.to.ch);\n          singleLine = true;\n          break;\n        }\n        cur = getLine(doc, found.to.line);\n      }\n\n      // This is a single, merged line\n      if (singleLine) {\n        for (var i = 0; i < path.length; i += 3)\n          drawForLine(path[i], path[i+1], path[i+2]);\n      } else {\n        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);\n        if (sel.from.ch)\n          // Draw the first line of selection.\n          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);\n        else\n          // Simply include it in the middle block.\n          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;\n\n        if (!sel.to.ch)\n          middleBot = heightAtLine(cm, toObj) - display.viewOffset;\n        else\n          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);\n\n        if (middleTop < middleBot) add(pl, middleTop, null, middleBot);\n      }\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = \"\";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = \"\";\n    display.blinker = setInterval(function() {\n      if (!display.cursor.offsetHeight) return;\n      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n    }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.view.frontier < cm.display.showingTo)\n      cm.view.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var view = cm.view, doc = view.doc;\n    if (view.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(view.mode, getStateBefore(cm, view.frontier));\n    var changed = [], prevChange;\n    doc.iter(view.frontier, Math.min(doc.size, cm.display.showingTo + 500), function(line) {\n      if (view.frontier >= cm.display.showingFrom) { // Visible\n        if (highlightLine(cm, line, state) && view.frontier >= cm.display.showingFrom) {\n          if (prevChange && prevChange.end == view.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: view.frontier, end: view.frontier + 1});\n        }\n        line.stateAfter = copyState(view.mode, state);\n      } else {\n        processLine(cm, line, state);\n        line.stateAfter = view.frontier % 5 == 0 ? copyState(view.mode, state) : null;\n      }\n      ++view.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n) {\n    var minindent, minline, doc = cm.view.doc;\n    for (var search = n, lim = n - 100; search > lim; --search) {\n      if (search == 0) return 0;\n      var line = getLine(doc, search-1);\n      if (line.stateAfter) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n) {\n    var view = cm.view;\n    var pos = findStartLine(cm, n), state = pos && getLine(view.doc, pos-1).stateAfter;\n    if (!state) state = startState(view.mode);\n    else state = copyState(view.mode, state);\n    view.doc.iter(pos, n, function(line) {\n      processLine(cm, line, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= view.showingFrom && pos < view.showingTo;\n      line.stateAfter = save ? copyState(view.mode, state) : null;\n      ++pos;\n    });\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n  \n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\")).appendChild(elt(\"span\", \"x\"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data) {\n    var data = data || measureLine(cm, line), dir = -1;\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top, bottom: r.bottom};\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var display = cm.display, cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          display.scroller.clientWidth == memo.width)\n        return memo.measure;\n    }\n    \n    var measure = measureLineInner(cm, line);\n    // Store result in the cache\n    var memo = {text: line.text, width: display.scroller.clientWidth,\n                markedSpans: line.markedSpans, measure: measure};\n    if (cache.length == 16) cache[++display.measureLineCachePos % 16] = memo;\n    else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = lineContent(cm, line, measure);\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt(\"div\", null, null, \"display: inline-block\");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = display.lineDiv.getBoundingClientRect();\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var size = cur.getBoundingClientRect();\n      var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);\n      for (var j = 0; j < vranges.length; j += 2) {\n        var rtop = vranges[j], rbot = vranges[j+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[j] = Math.min(top, rtop);\n          vranges[j+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (j == vranges.length) vranges.push(top, bot);\n      data[i] = {left: size.left - outer.left, right: size.right - outer.left, top: j};\n    }\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      var vr = cur.top;\n      cur.top = vranges[vr]; cur.bottom = vranges[vr+1];\n    }\n    return data;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    cm.view.maxLineChanged = true;\n  }\n\n  // Context is one of \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = lineObj.widgets[i].node.offsetHeight;\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context != \"local\") yOff -= cm.display.viewOffset;\n    if (context == \"page\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  function charCoords(cm, pos, context, lineObj) {\n    if (!lineObj) lineObj = getLine(cm.view.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.view.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var main, other, linedir = order[0].level;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i], rtl = part.level % 2, nb, here;\n      if (part.from < ch && part.to > ch) return get(ch, rtl);\n      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;\n      if (left == ch) {\n        // Opera and IE return bogus offsets and widths for edges\n        // where the direction flips, but only for the side with the\n        // lower level. So we try to use the side with the higher\n        // level.\n        if (i && part.level < (nb = order[i-1]).level) here = get(nb.level % 2 ? nb.from : nb.to - 1, true);\n        else here = get(rtl && part.from != part.to ? ch - 1 : ch);\n        if (rtl == linedir) main = here; else other = here;\n      } else if (right == ch) {\n        var nb = i < order.length - 1 && order[i+1];\n        if (!rtl && nb && nb.from == nb.to) continue;\n        if (nb && part.level < nb.level) here = get(nb.level % 2 ? nb.to - 1 : nb.from);\n        else here = get(rtl ? ch : ch - 1, true);\n        if (rtl == linedir) main = here; else other = here;\n      }\n    }\n    if (linedir && !ch) other = get(order[0].to - 1);\n    if (!main) return other;\n    if (other) main.other = other;\n    return main;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.view.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return {line: 0, ch: 0, outside: true};\n    var lineNo = lineAtHeight(doc, y);\n    if (lineNo >= doc.size) return {line: doc.size - 1, ch: getLine(doc, doc.size - 1).text.length};\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      if (merged && found.ch == lineRight(lineObj))\n        lineNo = merged.find().to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, cWidth = cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, {line: lineNo, ch: ch}, \"line\",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return Math.max(0, sp.left - cWidth);\n      else if (innerOff < sp.top) return sp.left + cWidth;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = paddingLeft(cm.display), toX = getX(to);\n\n    if (x > toX) return {line: lineNo, ch: to, outside: wrongLine};\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var after = x - fromX < toX - x, ch = after ? from : to;\n        while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;\n        return {line: lineNo, ch: ch, after: after, outside: wrongLine};\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (wrongLine) toX += 1000; dist -= step;}\n      else {from = middle; fromX = middleX; dist = step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"x\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  function startOperation(cm) {\n    if (cm.curOp) ++cm.curOp.depth;\n    else cm.curOp = {\n      // Nested operations delay update until the outermost one\n      // finishes.\n      depth: 1,\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      delayedCallbacks: [],\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      updateMaxLine: false,\n      id: ++cm.nextOpId\n    };\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (--op.depth) return;\n    cm.curOp = null;\n    var view = cm.view, display = cm.display;\n    if (op.updateMaxLine) computeMaxLength(view);\n    if (view.maxLineChanged && !cm.options.lineWrapping) {\n      var width = measureChar(cm, view.maxLine, view.maxLine.text.length).right;\n      display.sizer.style.minWidth = (width + 3 + scrollerCutOff) + \"px\";\n      view.maxLineChanged = false;\n    }\n    var newScrollPos, updated;\n    if (op.selectionChanged) {\n      var coords = cursorCoords(cm, view.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null)\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (newScrollPos) scrollCursorIntoView(cm);\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (view.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    if (op.textChanged)\n      signal(cm, \"change\", cm, op.textChanged);\n    if (op.selectionChanged) signal(cm, \"cursorActivity\", cm);\n    for (var i = 0; i < op.delayedCallbacks.length; ++i) op.delayedCallbacks[i](cm);\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this;\n      startOperation(cm);\n      try {var result = f.apply(cm, arguments);}\n      finally {endOperation(cm);}\n      return result;\n    };\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.view.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.view.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, view = cm.view, sel = view.sel;\n    if (!view.focused || hasSelection(input) || isReadOnly(cm)) return false;\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    startOperation(cm);\n    view.sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput[same] == text[same]) ++same;\n    var from = sel.from, to = sel.to;\n    if (same < prevInput.length)\n      from = {line: from.line, ch: from.ch - (prevInput.length - same)};\n    else if (view.overwrite && posEq(from, to) && !cm.display.pasteIncoming)\n      to = {line: to.line, ch: Math.min(getLine(cm.view.doc, to.line).text.length, to.ch + (text.length - same))};\n    var updateInput = cm.curOp.updateInput;\n    updateDoc(cm, from, to, splitLines(text.slice(same)), \"end\",\n              cm.display.pasteIncoming ? \"paste\" : \"input\", {from: from, to: to});\n    cm.curOp.updateInput = updateInput;\n    if (text.length > 1000) input.value = cm.display.prevInput = \"\";\n    else cm.display.prevInput = text;\n    endOperation(cm);\n    cm.display.pasteIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var view = cm.view, minimal, selected;\n    if (!posEq(view.sel.from, view.sel.to)) {\n      cm.display.prevInput = \"\";\n      minimal = hasCopyEvent &&\n        (view.sel.to.line - view.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      if (minimal) cm.display.input.value = \"-\";\n      else cm.display.input.value = selected || cm.getSelection();\n      if (view.focused) selectInput(cm.display.input);\n    } else if (user) cm.display.prevInput = cm.display.input.value = \"\";\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != \"nocursor\" && (ie || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.view.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    on(d.scroller, \"dblclick\", operation(cm, e_preventDefault));\n    on(d.lineSpace, \"selectstart\", function(e) {\n      if (!mouseEventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!gecko) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, \"scroll\", function() {\n      setScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    });\n    on(d.scrollbarV, \"scroll\", function() {\n      setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, \"scroll\", function() {\n      setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.view.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, \"mousedown\", reFocus);\n    on(d.scrollbarV, \"mousedown\", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n    on(window, \"resize\", function resizeHandler() {\n      // Might be a text scaling operation, clear size caches.\n      d.cachedCharWidth = d.cachedTextHeight = null;\n      clearCaches(cm);\n      if (d.wrapper.parentNode) updateDisplay(cm, true);\n      else off(window, \"resize\", resizeHandler);\n    });\n\n    on(d.input, \"keyup\", operation(cm, function(e) {\n      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e_prop(e, \"keyCode\") == 16) cm.view.sel.shift = false;\n    }));\n    on(d.input, \"input\", bind(fastPoll, cm));\n    on(d.input, \"keydown\", operation(cm, onKeyDown));\n    on(d.input, \"keypress\", operation(cm, onKeyPress));\n    on(d.input, \"focus\", bind(onFocus, cm));\n    on(d.input, \"blur\", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\n      on(d.scroller, \"dragenter\", drag_);\n      on(d.scroller, \"dragover\", drag_);\n      on(d.scroller, \"drop\", operation(cm, onDrop));\n    }\n    on(d.scroller, \"paste\", function(){focusInput(cm); fastPoll(cm);});\n    on(d.input, \"paste\", function() {\n      d.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy() {\n      if (d.inaccurateSelection) {\n        d.prevInput = \"\";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n    }\n    on(d.input, \"cut\", prepareCopy);\n    on(d.input, \"copy\", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, \"mouseup\", function() {\n        if (document.activeElement == d.input) d.input.blur();\n        focusInput(cm);\n    });\n  }\n\n  function mouseEventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode)\n      if (/\\bCodeMirror-(?:line)?widget\\b/.test(n.className) ||\n          n.parentNode == display.sizer && n != display.mover) return true;\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller) return null;\n    }\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    var cm = this, display = cm.display, view = cm.view, sel = view.sel, doc = view.doc;\n    sel.shift = e_prop(e, \"shiftKey\");\n\n    if (mouseEventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n    case 3:\n      if (gecko) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (start) extendSelection(cm, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    if (!view.focused) onFocus(cm);\n\n    var now = +new Date, type = \"single\";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = \"triple\";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == \"single\") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        view.draggingText = false;\n        off(document, \"mouseup\", dragEnd);\n        off(display.scroller, \"drop\", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm, start);\n          focusInput(cm);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      view.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, \"mouseup\", dragEnd);\n      on(display.scroller, \"drop\", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == \"single\") extendSelection(cm, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to;\n\n    function doSelect(cur) {\n      if (type == \"single\") {\n        extendSelection(cm, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == \"double\") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm, word.from, startend);\n        else extendSelection(cm, startstart, word.to);\n      } else if (type == \"triple\") {\n        if (posLess(cur, startstart)) extendSelection(cm, startend, clipPos(doc, {line: cur.line, ch: 0}));\n        else extendSelection(cm, startstart, clipPos(doc, {line: cur.line + 1, ch: 0}));\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        if (!view.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      var cur = posFromMouse(cm, e);\n      if (cur) doSelect(cur);\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if (!ie && !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  function onDrop(e) {\n    var cm = this;\n    if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n    e_preventDefault(e);\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.view.doc, pos);\n            operation(cm, function() {\n              var end = replaceRange(cm, text.join(\"\"), pos, pos, \"paste\");\n              setSelection(cm, pos, end);\n            })();\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.view.draggingText && !(posLess(pos, cm.view.sel.from) || posLess(cm.view.sel.to, pos))) {\n        cm.view.draggingText(e);\n        if (ie) setTimeout(bind(focusInput, cm), 50);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          var curFrom = cm.view.sel.from, curTo = cm.view.sel.to;\n          setSelection(cm, pos, pos);\n          if (cm.view.draggingText) replaceRange(cm, \"\", curFrom, curTo, \"paste\");\n          cm.replaceSelection(text, null, \"paste\");\n          focusInput(cm);\n          onFocus(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    var display = cm.display;\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n\n    if (mX >= Math.floor(display.gutters.getBoundingClientRect().right)) return false;\n    e_preventDefault(e);\n    if (!hasHandler(cm, \"gutterClick\")) return true;\n\n    var lineBox = display.lineDiv.getBoundingClientRect();\n    if (mY > lineBox.bottom) return true;\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.view.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalLater(cm, cm, \"gutterClick\", cm, line, gutter, e);\n        break;\n      }\n    }\n    return true;\n  }\n\n  function onDragStart(cm, e) {\n    var txt = cm.getSelection();\n    e.dataTransfer.setData(\"Text\", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari)\n      e.dataTransfer.setDragImage(elt('img'), 0, 0);\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.view.scrollTop - val) < 2) return;\n    cm.view.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.view.scrollLeft : Math.abs(cm.view.scrollLeft - val) < 2) return;\n    cm.view.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelDX, wheelDY, wheelStartX, wheelStartY, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    var scroll = cm.display.scroller;\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.view.scrollTop, bot = top + cm.display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.view.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (wheelStartX == null) {\n        wheelStartX = scroll.scrollLeft; wheelStartY = scroll.scrollTop;\n        wheelDX = dx; wheelDY = dy;\n        setTimeout(function() {\n          if (wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - wheelStartX;\n          var movedY = scroll.scrollTop - wheelStartY;\n          var sample = (movedY && wheelDY && movedY / wheelDY) ||\n            (movedX && wheelDX && movedX / wheelDX);\n          wheelStartX = wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        wheelDX += dx; wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var view = cm.view, prevShift = view.sel.shift;\n    try {\n      if (isReadOnly(cm)) view.suppressEdits = true;\n      if (dropShift) view.sel.shift = false;\n      bound(cm);\n    } catch(e) {\n      if (e != Pass) throw e;\n      return false;\n    } finally {\n      view.sel.shift = prevShift;\n      view.suppressEdits = false;\n    }\n    return true;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.view.keyMaps.slice(0);\n    maps.push(cm.options.keyMap);\n    if (cm.options.extraKeys) maps.unshift(cm.options.extraKeys);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap)\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n    }, 50);\n\n    var name = keyNames[e_prop(e, \"keyCode\")], handled = false;\n    var flipCtrlCmd = mac && (opera || qtwebkit);\n    if (name == null || e.altGraphKey) return false;\n    if (e_prop(e, \"altKey\")) name = \"Alt-\" + name;\n    if (e_prop(e, flipCtrlCmd ? \"metaKey\" : \"ctrlKey\")) name = \"Ctrl-\" + name;\n    if (e_prop(e, flipCtrlCmd ? \"ctrlKey\" : \"metaKey\")) name = \"Cmd-\" + name;\n\n    var stopped = false;\n    function stop() { stopped = true; }\n    var keymaps = allKeyMaps(cm);\n\n    if (e_prop(e, \"shiftKey\")) {\n      handled = lookupKey(\"Shift-\" + name, keymaps,\n                          function(b) {return doHandleBinding(cm, b, true);}, stop)\n        || lookupKey(name, keymaps, function(b) {\n          if (typeof b == \"string\" && /^go[A-Z]/.test(b)) return doHandleBinding(cm, b);\n        }, stop);\n    } else {\n      handled = lookupKey(name, keymaps,\n                          function(b) { return doHandleBinding(cm, b); }, stop);\n    }\n    if (stopped) handled = false;\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.view.focused) onFocus(cm);\n    if (ie && e.keyCode == 27) { e.returnValue = false; }\n    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var code = e_prop(e, \"keyCode\");\n    // IE does strange things with escape.\n    cm.view.sel.shift = code == 16 || e_prop(e, \"shiftKey\");\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && e_prop(e, mac ? \"metaKey\" : \"ctrlKey\"))\n        cm.replaceSelection(\"\");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e_prop(e, \"keyCode\"), charCode = e_prop(e, \"charCode\");\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (this.options.electricChars && this.view.mode.electricChars &&\n        this.options.smartIndent && !isReadOnly(this) &&\n        this.view.mode.electricChars.indexOf(ch) > -1)\n      setTimeout(operation(cm, function() {indentLine(cm, cm.view.sel.to.line, \"smart\");}), 75);\n    if (handleCharBinding(cm, e, ch)) return;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.view.focused) {\n      signal(cm, \"focus\", cm);\n      cm.view.focused = true;\n      if (cm.display.scroller.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.scroller.className += \" CodeMirror-focused\";\n      resetInput(cm, true);\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.view.focused) {\n      signal(cm, \"blur\", cm);\n      cm.view.focused = false;\n      cm.display.scroller.className = cm.display.scroller.className.replace(\" CodeMirror-focused\", \"\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.view.focused) cm.view.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    var display = cm.display, sel = cm.view.sel;\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))\n      operation(cm, setSelection)(cm, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = \"absolute\";\n    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n      \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; outline: none;\" +\n      \"border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds \"Select all\" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = \" \";\n\n    function rehide() {\n      display.inputDiv.style.position = \"relative\";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all \n      if (display.input.selectionStart != null) {\n        clearTimeout(detectingSelectAll);\n        var extval = display.input.value = \" \" + (posEq(sel.from, sel.to) ? \"\" : display.input.value), i = 0;\n        display.prevInput = \" \";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n        detectingSelectAll = setTimeout(function poll(){\n          if (display.prevInput == \" \" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        }, 200);\n      }\n    }\n\n    if (gecko) {\n      e_stop(e);\n      on(window, \"mouseup\", function mouseup() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      });\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  // Replace the range from from to to by the strings in newText.\n  // Afterwards, set the selection to selFrom, selTo.\n  function updateDoc(cm, from, to, newText, selUpdate, origin) {\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans &&\n      removeReadOnlyRanges(cm.view.doc, from, to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        updateDocInner(cm, split[i].from, split[i].to, [\"\"], origin);\n      if (split.length)\n        return updateDocInner(cm, split[0].from, split[0].to, newText, selUpdate, origin);\n    } else {\n      return updateDocInner(cm, from, to, newText, selUpdate, origin);\n    }\n  }\n\n  function updateDocInner(cm, from, to, newText, selUpdate, origin) {\n    if (cm.view.suppressEdits) return;\n\n    var view = cm.view, doc = view.doc, old = [];\n    doc.iter(from.line, to.line + 1, function(line) {\n      old.push(newHL(line.text, line.markedSpans));\n    });\n    var startSelFrom = view.sel.from, startSelTo = view.sel.to;\n    var lines = updateMarkedSpans(hlSpans(old[0]), hlSpans(lst(old)), from.ch, to.ch, newText);\n    var retval = updateDocNoUndo(cm, from, to, lines, selUpdate, origin);\n    if (view.history) addChange(cm, from.line, newText.length, old, origin,\n                                startSelFrom, startSelTo, view.sel.from, view.sel.to);\n    return retval;\n  }\n\n  function unredoHelper(cm, type) {\n    var doc = cm.view.doc, hist = cm.view.history;\n    var set = (type == \"undo\" ? hist.done : hist.undone).pop();\n    if (!set) return;\n    var anti = {events: [], fromBefore: set.fromAfter, toBefore: set.toAfter,\n                fromAfter: set.fromBefore, toAfter: set.toBefore};\n    for (var i = set.events.length - 1; i >= 0; i -= 1) {\n      hist.dirtyCounter += type == \"undo\" ? -1 : 1;\n      var change = set.events[i];\n      var replaced = [], end = change.start + change.added;\n      doc.iter(change.start, end, function(line) { replaced.push(newHL(line.text, line.markedSpans)); });\n      anti.events.push({start: change.start, added: change.old.length, old: replaced});\n      var selPos = i ? null : {from: set.fromBefore, to: set.toBefore};\n      updateDocNoUndo(cm, {line: change.start, ch: 0}, {line: end - 1, ch: getLine(doc, end-1).text.length},\n                      change.old, selPos, type);\n    }\n    (type == \"undo\" ? hist.undone : hist.done).push(anti);\n  }\n\n  function updateDocNoUndo(cm, from, to, lines, selUpdate, origin) {\n    var view = cm.view, doc = view.doc, display = cm.display;\n    if (view.suppressEdits) return;\n\n    var nlines = to.line - from.line, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, firstLine));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (lineLength(doc, line) == view.maxLineLength) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    var lastHL = lst(lines), th = textHeight(display);\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && hlText(lastHL) == \"\") {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = [];\n      for (var i = 0, e = lines.length - 1; i < e; ++i)\n        added.push(makeLine(hlText(lines[i]), hlSpans(lines[i]), th));\n      updateLine(cm, lastLine, lastLine.text, hlSpans(lastHL));\n      if (nlines) doc.remove(from.line, nlines, cm);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (lines.length == 1) {\n        updateLine(cm, firstLine, firstLine.text.slice(0, from.ch) + hlText(lines[0]) +\n                   firstLine.text.slice(to.ch), hlSpans(lines[0]));\n      } else {\n        for (var added = [], i = 1, e = lines.length - 1; i < e; ++i)\n          added.push(makeLine(hlText(lines[i]), hlSpans(lines[i]), th));\n        added.push(makeLine(hlText(lastHL) + firstLine.text.slice(to.ch), hlSpans(lastHL), th));\n        updateLine(cm, firstLine, firstLine.text.slice(0, from.ch) + hlText(lines[0]), hlSpans(lines[0]));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (lines.length == 1) {\n      updateLine(cm, firstLine, firstLine.text.slice(0, from.ch) + hlText(lines[0]) +\n                 lastLine.text.slice(to.ch), hlSpans(lines[0]));\n      doc.remove(from.line + 1, nlines, cm);\n    } else {\n      var added = [];\n      updateLine(cm, firstLine, firstLine.text.slice(0, from.ch) + hlText(lines[0]), hlSpans(lines[0]));\n      updateLine(cm, lastLine, hlText(lastHL) + lastLine.text.slice(to.ch), hlSpans(lastHL));\n      for (var i = 1, e = lines.length - 1; i < e; ++i)\n        added.push(makeLine(hlText(lines[i]), hlSpans(lines[i]), th));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1, cm);\n      doc.insert(from.line + 1, added);\n    }\n\n    if (cm.options.lineWrapping) {\n      var perLine = Math.max(5, display.scroller.clientWidth / charWidth(display) - 3);\n      doc.iter(from.line, from.line + lines.length, function(line) {\n        if (line.height == 0) return;\n        var guess = (Math.ceil(line.text.length / perLine) || 1) * th;\n        if (guess != line.height) updateLineHeight(line, guess);\n      });\n    } else {\n      doc.iter(checkWidthStart, from.line + lines.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > view.maxLineLength) {\n          view.maxLine = line;\n          view.maxLineLength = len;\n          view.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    view.frontier = Math.min(view.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = lines.length - nlines - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n    if (hasHandler(cm, \"change\")) {\n      // Normalize lines to contain only strings, since that's what\n      // the change event handler expects\n      for (var i = 0; i < lines.length; ++i)\n        if (typeof lines[i] != \"string\") lines[i] = lines[i].text;\n      var changeObj = {from: from, to: to, text: lines, origin: origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n\n    // Update the selection\n    var newSelFrom, newSelTo, end = {line: from.line + lines.length - 1,\n                                     ch: hlText(lastHL).length  + (lines.length == 1 ? from.ch : 0)};\n    if (selUpdate && typeof selUpdate != \"string\") {\n      if (selUpdate.from) { newSelFrom = selUpdate.from; newSelTo = selUpdate.to; }\n      else newSelFrom = newSelTo = selUpdate;\n    } else if (selUpdate == \"end\") {\n      newSelFrom = newSelTo = end;\n    } else if (selUpdate == \"start\") {\n      newSelFrom = newSelTo = from;\n    } else if (selUpdate == \"around\") {\n      newSelFrom = from; newSelTo = end;\n    } else {\n      var adjustPos = function(pos) {\n        if (posLess(pos, from)) return pos;\n        if (!posLess(to, pos)) return end;\n        var line = pos.line + lendiff;\n        var ch = pos.ch;\n        if (pos.line == to.line)\n          ch += hlText(lastHL).length - (to.ch - (to.line == from.line ? from.ch : 0));\n        return {line: line, ch: ch};\n      };\n      newSelFrom = adjustPos(view.sel.from);\n      newSelTo = adjustPos(view.sel.to);\n    }\n    setSelection(cm, newSelFrom, newSelTo, null, true);\n    return end;\n  }\n\n  function replaceRange(cm, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    return updateDoc(cm, from, to, splitLines(code), null, origin);\n  }\n\n  // SELECTION\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function copyPos(x) {return {line: x.line, ch: x.ch};}\n\n  function clipLine(doc, n) {return Math.max(0, Math.min(n, doc.size-1));}\n  function clipPos(doc, pos) {\n    if (pos.line < 0) return {line: 0, ch: 0};\n    if (pos.line >= doc.size) return {line: doc.size-1, ch: getLine(doc, doc.size-1).text.length};\n    var ch = pos.ch, linelen = getLine(doc, pos.line).text.length;\n    if (ch == null || ch > linelen) return {line: pos.line, ch: linelen};\n    else if (ch < 0) return {line: pos.line, ch: 0};\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= 0 && l < doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(cm, pos, other, bias) {\n    var sel = cm.view.sel;\n    if (sel.shift || sel.extend) {\n      var anchor = sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(cm, anchor, pos, bias);\n    } else {\n      setSelection(cm, pos, other || pos, bias);\n    }\n    cm.curOp.userSelChange = true;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(cm, anchor, head, bias, checkAtomic) {\n    cm.view.goalColumn = null;\n    var sel = cm.view.sel;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(cm, anchor, bias, checkAtomic != \"push\");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(cm, head, bias, checkAtomic != \"push\");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    cm.curOp.updateInput = true;\n    cm.curOp.selectionChanged = true;\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm, cm.view.sel.from, cm.view.sel.to, null, \"push\");\n  }\n\n  function skipAtomic(cm, pos, bias, mayClear) {\n    var doc = cm.view.doc, flipped = false, curPos = pos;\n    var dir = bias || 1;\n    cm.view.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line), toClear;\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear && m.clearOnEnter) {\n              (toClear || (toClear = [])).push(m);\n              continue;\n            } else if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? \"from\" : \"to\"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line) newPos = clipPos(doc, {line: newPos.line - 1});\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.size - 1) newPos = {line: newPos.line + 1, ch: 0};\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(cm, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  cm.view.cantEdit = true;\n                  return {line: 0, ch: 0};\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n        if (toClear) for (var i = 0; i < toClear.length; ++i) toClear[i].clear();\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var view = cm.view;\n    var coords = scrollPosIntoView(cm, view.sel.head);\n    if (!view.focused) return;\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var hidden = display.cursor.style.display == \"none\";\n      if (hidden) {\n        display.cursor.style.display = \"\";\n        display.cursor.style.left = coords.left + \"px\";\n        display.cursor.style.top = (coords.top - display.viewOffset) + \"px\";\n      }\n      display.cursor.scrollIntoView(doScroll);\n      if (hidden) display.cursor.style.display = \"none\";\n    }\n  }\n\n  function scrollPosIntoView(cm, pos) {\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var scrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n      var startTop = cm.view.scrollTop, startLeft = cm.view.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.view.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.view.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, pt = paddingTop(display);\n    y1 += pt; y2 += pt;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.view.doc.height + 2 * pt;\n    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;\n    if (y1 < screentop) result.scrollTop = atTop ? 0 : Math.max(0, y1);\n    else if (y2 > screentop + screen) result.scrollTop = (atBottom ? docBottom : y2) - screen;\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.view.doc;\n    if (!how) how = \"add\";\n    if (how == \"smart\") {\n      if (!cm.view.mode.indent) how = \"prev\";\n      else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (how == \"smart\") {\n      indentation = cm.view.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    }\n    else if (how == \"add\") indentation = curSpace + cm.options.indentUnit;\n    else if (how == \"subtract\") indentation = curSpace - cm.options.indentUnit;\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm, indentString, {line: n, ch: 0}, {line: n, ch: curSpaceString.length}, \"input\");\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.view.doc;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(cm, dir, unit, visually) {\n    var doc = cm.view.doc, end = cm.view.sel.head, line = end.line, ch = end.ch;\n    var lineObj = getLine(doc, line);\n    function findNextLine() {\n      var l = line + dir;\n      if (l < 0 || l == doc.size) return false;\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return false;\n      } else ch = next;\n      return true;\n    }\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\") {\n      var sawWord = false;\n      for (;;) {\n        if (dir < 0) if (!moveOnce()) break;\n        if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;\n        else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}\n        if (dir > 0) if (!moveOnce()) break;\n      }\n    }\n    return skipAtomic(cm, {line: line, ch: ch}, dir, true);\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if (pos.after === false || end == line.length) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar :\n        /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);} :\n      function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: {line: pos.line, ch: start}, to: {line: pos.line, ch: end}};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm, {line: line, ch: 0}, clipPos(cm.view.doc, {line: line + 1, ch: 0}));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    getValue: function(lineSep) {\n      var text = [], doc = this.view.doc;\n      doc.iter(0, doc.size, function(line) { text.push(line.text); });\n      return text.join(lineSep || \"\\n\");\n    },\n\n    setValue: operation(null, function(code) {\n      var doc = this.view.doc, top = {line: 0, ch: 0}, lastLen = getLine(doc, doc.size-1).text.length;\n      updateDocInner(this, top, {line: doc.size - 1, ch: lastLen}, splitLines(code), top, top, \"setValue\");\n    }),\n\n    getSelection: function(lineSep) { return this.getRange(this.view.sel.from, this.view.sel.to, lineSep); },\n\n    replaceSelection: operation(null, function(code, collapse, origin) {\n      var sel = this.view.sel;\n      updateDoc(this, sel.from, sel.to, splitLines(code), collapse || \"around\", origin);\n    }),\n\n    focus: function(){window.focus(); focusInput(this); onFocus(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n\n    getMode: function() {return this.view.mode;},\n\n    addKeyMap: function(map) {\n      this.view.keyMaps.push(map);\n    },\n\n    removeKeyMap: function(map) {\n      var maps = this.view.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if ((typeof map == \"string\" ? maps[i].name : maps[i]) == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    undo: operation(null, function() {unredoHelper(this, \"undo\");}),\n    redo: operation(null, function() {unredoHelper(this, \"redo\");}),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != \"string\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.view.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n\n    indentSelection: operation(null, function(how) {\n      var sel = this.view.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    historySize: function() {\n      var hist = this.view.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n\n    clearHistory: function() {this.view.history = makeHistory();},\n\n    markClean: function() {\n      this.view.history.dirtyCounter = 0;\n      this.view.history.lastOp = this.view.history.lastOrigin = null;\n    },\n\n    isClean: function () {return this.view.history.dirtyCounter == 0;},\n      \n    getHistory: function() {\n      var hist = this.view.history;\n      function cp(arr) {\n        for (var i = 0, nw = [], nwelt; i < arr.length; ++i) {\n          var set = arr[i];\n          nw.push({events: nwelt = [], fromBefore: set.fromBefore, toBefore: set.toBefore,\n                   fromAfter: set.fromAfter, toAfter: set.toAfter});\n          for (var j = 0, elt = set.events; j < elt.length; ++j) {\n            var old = [], cur = elt[j];\n            nwelt.push({start: cur.start, added: cur.added, old: old});\n            for (var k = 0; k < cur.old.length; ++k) old.push(hlText(cur.old[k]));\n          }\n        }\n        return nw;\n      }\n      return {done: cp(hist.done), undone: cp(hist.undone)};\n    },\n\n    setHistory: function(histData) {\n      var hist = this.view.history = makeHistory();\n      hist.done = histData.done;\n      hist.undone = histData.undone;\n    },\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos) {\n      var doc = this.view.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line), mode = this.view.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getStateAfter: function(line) {\n      var doc = this.view.doc;\n      line = clipLine(doc, line == null ? doc.size - 1: line);\n      return getStateBefore(this, line + 1);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.view.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == \"object\") pos = clipPos(this.view.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.view.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords) {\n      var off = this.display.lineSpace.getBoundingClientRect();\n      return coordsChar(this, coords.left - off.left, coords.top - off.top);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n\n    markText: operation(null, function(from, to, options) {\n      return markText(this, clipPos(this.view.doc, from), clipPos(this.view.doc, to),\n                      options, \"range\");\n    }),\n\n    setBookmark: operation(null, function(pos, widget) {\n      pos = clipPos(this.view.doc, pos);\n      return markText(this, pos, pos, widget ? {replacedWith: widget} : {}, \"bookmark\");\n    }),\n\n    findMarksAt: function(pos) {\n      var doc = this.view.doc;\n      pos = clipPos(doc, pos);\n      var markers = [], spans = getLine(doc, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker);\n      }\n      return markers;\n    },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var i = 0, cm = this, doc = cm.view.doc;\n      doc.iter(0, doc.size, function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp(\"\\\\b\" + cls + \"\\\\b\").test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var upd = cur.replace(new RegExp(\"^\" + cls + \"\\\\b\\\\s*|\\\\s*\\\\b\" + cls + \"\\\\b\"), \"\");\n          if (upd == cur) return false;\n          line[prop] = upd || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      var widget = options || {};\n      widget.node = node;\n      if (widget.noHScroll) this.display.alignWidgets = true;\n      changeLine(this, handle, function(line) {\n        (line.widgets || (line.widgets = [])).push(widget);\n        widget.line = line;\n        return true;\n      });\n      return widget;\n    }),\n\n    removeLineWidget: operation(null, function(widget) {\n      var ws = widget.line.widgets, no = lineNo(widget.line);\n      if (no == null) return;\n      for (var i = 0; i < ws.length; ++i) if (ws[i] == widget) ws.splice(i--, 1);\n      regChange(this, no, no + 1);\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.view.doc, line)) return null;\n        var n = line;\n        line = getLine(this.view.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.view.doc, pos));\n      var top = pos.top, left = pos.left;\n      node.style.position = \"absolute\";\n      display.sizer.appendChild(node);\n      if (vert == \"over\") top = pos.top;\n      else if (vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.view.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        if (pos.bottom + node.offsetHeight > vspace && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = (top + paddingTop(display)) + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    lineCount: function() {return this.view.doc.size;},\n\n    clipPos: function(pos) {return clipPos(this.view.doc, pos);},\n\n    getCursor: function(start) {\n      var sel = this.view.sel, pos;\n      if (start == null || start == \"head\") pos = sel.head;\n      else if (start == \"anchor\") pos = sel.anchor;\n      else if (start == \"end\" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n\n    somethingSelected: function() {return !posEq(this.view.sel.from, this.view.sel.to);},\n\n    setCursor: operation(null, function(line, ch, extend) {\n      var pos = clipPos(this.view.doc, typeof line == \"number\" ? {line: line, ch: ch || 0} : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n\n    setSelection: operation(null, function(anchor, head) {\n      var doc = this.view.doc;\n      setSelection(this, clipPos(doc, anchor), clipPos(doc, head || anchor));\n    }),\n\n    extendSelection: operation(null, function(from, to) {\n      var doc = this.view.doc;\n      extendSelection(this, clipPos(doc, from), to && clipPos(doc, to));\n    }),\n\n    setExtending: function(val) {this.view.sel.extend = val;},\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {\n      var doc = this.view.doc;\n      if (isLine(doc, line)) return getLine(doc, line);\n    },\n\n    getLineNumber: function(line) {return lineNo(line);},\n\n    setLine: operation(null, function(line, text) {\n      if (isLine(this.view.doc, line))\n        replaceRange(this, text, {line: line, ch: 0}, {line: line, ch: getLine(this.view.doc, line).text.length});\n    }),\n\n    removeLine: operation(null, function(line) {\n      if (isLine(this.view.doc, line))\n        replaceRange(this, \"\", {line: line, ch: 0}, clipPos(this.view.doc, {line: line+1, ch: 0}));\n    }),\n\n    replaceRange: operation(null, function(code, from, to) {\n      var doc = this.view.doc;\n      from = clipPos(doc, from);\n      to = to ? clipPos(doc, to) : from;\n      return replaceRange(this, code, from, to);\n    }),\n\n    getRange: function(from, to, lineSep) {\n      var doc = this.view.doc;\n      from = clipPos(doc, from); to = clipPos(doc, to);\n      var l1 = from.line, l2 = to.line;\n      if (l1 == l2) return getLine(doc, l1).text.slice(from.ch, to.ch);\n      var code = [getLine(doc, l1).text.slice(from.ch)];\n      doc.iter(l1 + 1, l2, function(line) { code.push(line.text); });\n      code.push(getLine(doc, l2).text.slice(0, to.ch));\n      return code.join(lineSep || \"\\n\");\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n\n    execCommand: function(cmd) {return commands[cmd](this);},\n\n    // Stuff used by commands, probably not much use to outside code.\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.view.sel, pos = dir < 0 ? sel.from : sel.to;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) pos = findPosH(this, dir, unit, true);\n      extendSelection(this, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.view.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this, \"\", sel.from, sel.to, \"delete\");\n      else replaceRange(this, \"\", sel.from, findPosH(this, dir, unit, false), \"delete\");\n      this.curOp.userSelChange = true;\n    }),\n\n    moveV: operation(null, function(dir, unit) {\n      var view = this.view, doc = view.doc, display = this.display;\n      var cur = view.sel.head, pos = cursorCoords(this, cur, \"div\");\n      var x = pos.left, y;\n      if (view.goalColumn != null) x = view.goalColumn;\n      if (unit == \"page\") {\n        var pageSize = Math.min(display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n        y = pos.top + dir * pageSize;\n      } else if (unit == \"line\") {\n        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n      }\n      do {\n        var target = coordsChar(this, x, y);\n        y += dir * 5;\n      } while (target.outside && (dir < 0 ? y > 0 : y < doc.height));\n\n      if (unit == \"page\") display.scrollbarV.scrollTop += charCoords(this, target, \"div\").top - pos.top;\n      extendSelection(this, target, target, dir);\n      view.goalColumn = x;\n    }),\n\n    toggleOverwrite: function() {\n      if (this.view.overwrite = !this.view.overwrite)\n        this.display.cursor.className += \" CodeMirror-overwrite\";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n    },\n\n    posFromIndex: function(off) {\n      var lineNo = 0, ch, doc = this.view.doc;\n      doc.iter(0, doc.size, function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(doc, {line: lineNo, ch: ch});\n    },\n    indexFromPos: function (coords) {\n      if (coords.line < 0 || coords.ch < 0) return 0;\n      var index = coords.ch;\n      this.view.doc.iter(0, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    scrollTo: function(x, y) {\n      if (x != null) this.display.scrollbarH.scrollLeft = this.display.scroller.scrollLeft = x;\n      if (y != null) this.display.scrollbarV.scrollTop = this.display.scroller.scrollTop = y;\n      updateDisplay(this, []);\n    },\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: function(pos) {\n      if (typeof pos == \"number\") pos = {line: pos, ch: 0};\n      pos = pos ? clipPos(this.view.doc, pos) : this.view.sel.head;\n      scrollPosIntoView(this, pos);\n    },\n\n    setSize: function(width, height) {\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      this.refresh();\n    },\n\n    on: function(type, f) {on(this, type, f);},\n    off: function(type, f) {off(this, type, f);},\n\n    operation: function(f){return operation(this, f)();},\n\n    refresh: function() {\n      clearCaches(this);\n      if (this.display.scroller.scrollHeight > this.view.scrollTop)\n        this.display.scrollbarV.scrollTop = this.display.scroller.scrollTop = this.view.scrollTop;\n      updateDisplay(this, true);\n    },\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {cm.setValue(val);}, true);\n  option(\"mode\", null, loadMode, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    loadMode(cm);\n    clearCaches(cm);\n    updateDisplay(cm, true);\n  }, true);\n  option(\"electricChars\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", keyMapChanged);\n  option(\"extraKeys\", null);\n\n  option(\"onKeyEvent\", null);\n  option(\"onDragEvent\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n  \n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {onBlur(cm); cm.display.input.blur();}\n    else if (!val) resetInput(cm, true);\n  });\n  option(\"dragDrop\", true);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorHeight\", 1);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 40);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n      spec = mimeModes[spec];\n    else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec))\n      return CodeMirror.resolveMode(\"application/xml\");\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    return modeObj;\n  };\n\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    for (var prop in properties) if (properties.hasOwnProperty(prop))\n      exts[prop] = properties[prop];\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection({line: 0, ch: 0}, {line: cm.lineCount() - 1});},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange(\"\", from, {line: from.line + 1, ch: 0}, \"delete\");\n      else cm.replaceRange(\"\", from, sel ? to : {line: from.line}, \"delete\");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange(\"\", {line: l, ch: 0}, {line: l}, \"delete\");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection({line: 0, ch: 0});},\n    goDocEnd: function(cm) {cm.extendSelection({line: cm.lineCount() - 1});},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection({line: start.line, ch: inWS ? 0 : firstNonWS});\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\", \"end\", \"input\");},\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.replaceSelection(\"\\t\", \"end\", \"input\");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        {line: cur.line, ch: cur.ch - 1}, {line: cur.line, ch: cur.ch + 1});\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection(\"\\n\", \"end\", \"input\");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Alt-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goWordLeft\", \"Ctrl-Right\": \"goWordRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delWordBefore\", \"Ctrl-Delete\": \"delWordAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goWordLeft\",\n    \"Alt-Right\": \"goWordRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delWordBefore\",\n    \"Ctrl-Alt-Backspace\": \"delWordAfter\", \"Alt-Delete\": \"delWordAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle, stop) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) {\n        if (stop) stop();\n        return true;\n      }\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) {\n        if (stop) stop();\n        return true;\n      }\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        if (lookup(fallthrough[i])) return true;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i)\n      if (lookup(maps[i])) return true;\n  }\n  function isModifierKey(event) {\n    var name = keyNames[e_prop(event, \"keyCode\")];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n  CodeMirror.isModifierKey = isModifierKey;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      // Deplorable hack to make the submit method do the right thing.\n      on(textarea.form, \"submit\", save);\n      var form = textarea.form, realSubmit = form.submit;\n      try {\n        form.submit = function wrappedSubmit() {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == 0;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {return countColumn(this.string, this.start, this.tabSize);},\n    indentation: function() {return countColumn(this.string, null, this.tabSize);},\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);}\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(cm, type) {\n    this.lines = [];\n    this.type = type;\n    this.cm = cm;\n  }\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    startOperation(this.cm);\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(line))\n        updateLineHeight(line, textHeight(this.cm.display));\n    }\n    if (min != null) regChange(this.cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.collapsed && this.cm.view.cantEdit) {\n      this.cm.view.cantEdit = false;\n      reCheckSelection(this.cm);\n    }\n    endOperation(this.cm);\n    signalLater(this.cm, this, \"clear\");\n  };\n\n  TextMarker.prototype.find = function() {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = {line: found, ch: span.from};\n        if (span.to != null) to = {line: found, ch: span.to};\n      }\n    }\n    if (this.type == \"bookmark\") return from;\n    return from && {from: from, to: to};\n  };\n\n  function markText(cm, from, to, options, type) {\n    var doc = cm.view.doc;\n    var marker = new TextMarker(cm, type);\n    if (type == \"range\" && !posLess(from, to)) return marker;\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      marker[opt] = options[opt];\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    }\n    if (marker.collapsed) sawCollapsedSpans = true;\n\n    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd;\n    doc.iter(curLine, to.line + 1, function(line) {\n      var span = {from: null, to: null, marker: marker};\n      size += line.text.length;\n      if (curLine == from.line) {span.from = from.ch; size -= from.ch;}\n      if (curLine == to.line) {span.to = to.ch; size -= line.text.length - to.ch;}\n      if (marker.collapsed) {\n        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);\n        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);\n        else updateLineHeight(line, 0);\n      }\n      addMarkedSpan(line, span);\n      if (marker.collapsed && curLine == from.line && lineIsHidden(line))\n        updateLineHeight(line, 0);\n      ++curLine;\n    });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (cm.view.history.done.length || cm.view.history.undone.length)\n        cm.clearHistory();\n    }\n    if (marker.collapsed) {\n      if (collapsedAtStart != collapsedAtEnd)\n        throw new Error(\"Inserting collapsed marker overlapping an existing one\");\n      marker.size = size;\n      marker.atomic = true;\n    }\n    if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)\n      regChange(cm, from.line, to.line + 1);\n    if (marker.atomic) reCheckSelection(cm);\n    return marker;\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.lines.push(line);\n  }\n\n  function markedSpansBefore(old, startCh) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || marker.type == \"bookmark\" && span.from == startCh) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, startCh, endCh) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || marker.type == \"bookmark\" && span.from == endCh && span.from != startCh) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function updateMarkedSpans(oldFirst, oldLast, startCh, endCh, newText) {\n    if (!oldFirst && !oldLast) return newText;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh);\n    var last = markedSpansAfter(oldLast, startCh, endCh);\n\n    // Next, merge those two ends\n    var sameLine = newText.length == 1, offset = lst(newText).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n\n    var newMarkers = [newHL(newText[0], first)];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = newText.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(newHL(newText[i+1], gapMarkers));\n      newMarkers.push(newHL(lst(newText), last));\n    }\n    return newMarkers;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var m = markers[i].find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (!posLess(m.from, p.to) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from)) newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to)) newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function collapsedSpanAt(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if ((sp.from == null || sp.from < ch) &&\n          (sp.to == null || sp.to > ch) &&\n          (!found || found.width < sp.marker.width))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAt(line, -1); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAt(line, line.text.length + 1); }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(line, sp))\n        return true;\n    }\n  }\n  window.lineIsHidden = lineIsHidden;\n  function lineIsHiddenInner(line, span) {\n    if (span.to == null || span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && sp.from == span.to &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(line, sp)) return true;\n    }\n  }\n\n  // hl stands for history-line, a data structure that can be either a\n  // string (line without markers) or a {text, markedSpans} object.\n  function hlText(val) { return typeof val == \"string\" ? val : val.text; }\n  function hlSpans(val) {\n    if (typeof val == \"string\") return null;\n    var spans = val.markedSpans, out = null;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n  function newHL(text, spans) { return spans ? {text: text, markedSpans: spans} : text; }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i) {\n      var lines = spans[i].marker.lines;\n      var ix = indexOf(lines, line);\n      lines.splice(ix, 1);\n    }\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.lines.push(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  function makeLine(text, markedSpans, height) {\n    var line = {text: text, height: height};\n    attachMarkedSpans(line, markedSpans);\n    if (lineIsHidden(line)) line.height = 0;\n    return line;\n  }\n\n  function updateLine(cm, line, text, markedSpans) {\n    line.text = text;\n    line.stateAfter = line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    if (lineIsHidden(line)) line.height = 0;\n    else if (!line.height) line.height = textHeight(cm.display);\n    signalLater(cm, line, \"change\");\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function highlightLine(cm, line, state) {\n    var mode = cm.view.mode, flattenSpans = cm.options.flattenSpans;\n    var changed = !line.styles, pos = 0, curText = \"\", curStyle = null;\n    var stream = new StringStream(line.text, cm.options.tabSize), st = line.styles || (line.styles = []);\n    if (line.text == \"\" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      var style = mode.token(stream, state), substr = stream.current();\n      stream.start = stream.pos;\n      if (!flattenSpans || curStyle != style) {\n        if (curText) {\n          changed = changed || pos >= st.length || curText != st[pos] || curStyle != st[pos+1];\n          st[pos++] = curText; st[pos++] = curStyle;\n        }\n        curText = substr; curStyle = style;\n      } else curText = curText + substr;\n      // Give up when line is ridiculously long\n      if (stream.pos > 5000) break;\n    }\n    if (curText) {\n      changed = changed || pos >= st.length || curText != st[pos] || curStyle != st[pos+1];\n      st[pos++] = curText; st[pos++] = curStyle;\n    }\n    if (stream.pos > 5000) { st[pos++] = line.text.slice(stream.pos); st[pos++] = null; }\n    if (pos != st.length) { st.length = pos; changed = true; }\n    return changed;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, line, state) {\n    var mode = cm.view.mode;\n    var stream = new StringStream(line.text, cm.options.tabSize);\n    if (line.text == \"\" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= 5000) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {};\n  function styleToClass(style) {\n    if (!style) return null;\n    return styleToClassCache[style] ||\n      (styleToClassCache[style] = \"cm-\" + style.replace(/ +/g, \" cm-\"));\n  }\n\n  function lineContent(cm, realLine, measure) {\n    var merged, line = realLine, lineBefore, sawBefore, simple = true;\n    while (merged = collapsedSpanAtStart(line)) {\n      simple = false;\n      line = getLine(cm.view.doc, merged.find().from.line);\n      if (!lineBefore) lineBefore = line;\n    }\n\n    var builder = {pre: elt(\"pre\"), col: 0, pos: 0, display: !measure,\n                   measure: null, addedOne: false, cm: cm};\n    if (line.textClass) builder.pre.className = line.textClass;\n\n    do {\n      if (!line.styles)\n        highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if (measure && sawBefore && line != realLine && !builder.addedOne) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.addedOne = true;\n      }\n      var next = insertLineContent(line, builder);\n      sawBefore = line == lineBefore;\n      if (next) {\n        line = getLine(cm.view.doc, next.to.line);\n        simple = false;\n      }\n    } while (next);\n\n    if (measure && !builder.addedOne)\n      measure[0] = builder.pre.appendChild(simple ? elt(\"span\", \"\\u00a0\") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(realLine))\n      builder.pre.appendChild(document.createTextNode(\"\\u00a0\"));\n\n    return builder.pre;\n  }\n\n  var tokenSpecialChars = /[\\t\\u0000-\\u0019\\u200b\\u2028\\u2029\\uFEFF]/g;\n  function buildToken(builder, text, style, startStyle, endStyle) {\n    if (!text) return;\n    if (!tokenSpecialChars.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        tokenSpecialChars.lastIndex = pos;\n        var m = tokenSpecialChars.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          builder.col += tabWidth;\n        } else {\n          var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n          token.title = \"\\\\u\" + m[0].charCodeAt(0).toString(16);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      return builder.pre.appendChild(elt(\"span\", [content], fullStyle));\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    for (var i = 0; i < text.length; ++i) {\n      if (i && i < text.length - 1 &&\n          builder.cm.options.lineWrapping &&\n          spanAffectsWrapping.test(text.slice(i - 1, i + 1)))\n        builder.pre.appendChild(elt(\"wbr\"));\n      builder.measure[builder.pos++] =\n        buildToken(builder, text.charAt(i), style,\n                   i == 0 && startStyle, i == text.length - 1 && endStyle);\n    }\n    if (text.length) builder.addedOne = true;\n  }\n\n  function buildCollapsedSpan(builder, size, widget) {\n    if (widget) {\n      if (!builder.display) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure && size) {\n        builder.measure[builder.pos] = widget;\n        builder.addedOne = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder) {\n    var st = line.styles, spans = line.markedSpans;\n    if (!spans) {\n      for (var i = 0; i < st.length; i+=2)\n        builder.addToken(builder, st[i], styleToClass(st[i+1]));\n      return;\n    }\n\n    var allText = line.text, len = allText.length;\n    var pos = 0, i = 0, text = \"\", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmark = null;\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == \"bookmark\" && sp.from == pos && m.replacedWith)\n            foundBookmark = m.replacedWith;\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.from != null && collapsed.marker.replacedWith);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style + spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\");\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = st[i++]; style = styleToClass(st[i++]);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    remove: function(at, n, cm) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(cm, line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertHeight: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    remove: function(at, n, callbacks) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.remove(at, rm, callbacks);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertHeight(at, lines, height);\n    },\n    insertHeight: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertHeight(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iter: function(from, to, op) { this.iterN(from, to - from, op); },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.view.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory() {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [],\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      dirtyCounter: 0\n    };\n  }\n\n  function addChange(cm, start, added, old, origin, fromBefore, toBefore, fromAfter, toAfter) {\n    var history = cm.view.history;\n    history.undone.length = 0;\n    var time = +new Date, cur = lst(history.done);\n    \n    if (cur &&\n        (history.lastOp == cm.curOp.id ||\n         history.lastOrigin == origin && (origin == \"input\" || origin == \"delete\") &&\n         history.lastTime > time - 600)) {\n      // Merge this change into the last event\n      var last = lst(cur.events);\n      if (last.start > start + old.length || last.start + last.added < start) {\n        // Doesn't intersect with last sub-event, add new sub-event\n        cur.events.push({start: start, added: added, old: old});\n      } else {\n        // Patch up the last sub-event\n        var startBefore = Math.max(0, last.start - start),\n        endAfter = Math.max(0, (start + old.length) - (last.start + last.added));\n        for (var i = startBefore; i > 0; --i) last.old.unshift(old[i - 1]);\n        for (var i = endAfter; i > 0; --i) last.old.push(old[old.length - i]);\n        if (startBefore) last.start = start;\n        last.added += added - (old.length - startBefore - endAfter);\n      }\n      cur.fromAfter = fromAfter; cur.toAfter = toAfter;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {events: [{start: start, added: added, old: old}],\n             fromBefore: fromBefore, toBefore: toBefore, fromAfter: fromAfter, toAfter: toAfter};\n      history.done.push(cur);\n      while (history.done.length > cm.options.undoDepth)\n        history.done.shift();\n      if (history.dirtyCounter < 0)\n          // The user has made a change after undoing past the last clean state. \n          // We can never get back to a clean state now until markClean() is called.\n          history.dirtyCounter = NaN;\n      else\n        history.dirtyCounter++;\n    }\n    history.lastTime = time;\n    history.lastOp = cm.curOp.id;\n    history.lastOrigin = origin;\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // Allow 3rd-party code to override event properties by adding an override\n  // object to an event object.\n  function e_prop(e, prop) {\n    var overridden = e.override && e.override.hasOwnProperty(prop);\n    return overridden ? e.override[prop] : e[prop];\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  function signalLater(cm, emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 3), flist = cm.curOp && cm.curOp.delayedCallbacks;\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      if (flist) flist.push(bnd(arr[i]));\n      else arr[i].apply(null, args);\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = 0, n = 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else node.select();\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    var c = 0;\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) ++c;\n    return !c;\n  }\n\n  var isExtendingChar = /[\\u0300-\\u036F\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\uA66F\\uA670-\\uA672\\uA674-\\uA67D\\uA69F]/;\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    e.innerHTML = \"\";\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = \"\";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of regexps matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  var spanAffectsWrapping = /^$/; // Won't match any two-character string\n  if (gecko) spanAffectsWrapping = /$'/;\n  else if (safari) spanAffectsWrapping = /\\-[^ \\-?]|\\?[^ !'\\\"\\),.\\-\\/:;\\?\\]\\}]/;\n  else if (chrome) spanAffectsWrapping = /\\-[^ \\-\\.?]|\\?[^ \\-\\.?\\]\\}:;!'\\\"\\),\\/]|[\\.!\\\"#&%\\)*+,:;=>\\]|\\}~][\\(\\{\\[<]|\\$'/;\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt(\"span\", \"\\u200b\");\n    else return elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 109: \"-\", 107: \"=\", 127: \"Delete\",\n                  186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n                  221: \"]\", 222: \"'\", 63276: \"PageUp\", 63277: \"PageDown\", 63275: \"End\", 63273: \"Home\",\n                  63234: \"Left\", 63232: \"Up\", 63235: \"Right\", 63233: \"Down\", 63302: \"Insert\", 63272: \"Delete\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from)\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n    }\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.view.doc, lineN);\n    var visual = visualLine(cm.view.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return {line: lineN, ch: ch};\n  }\n  function lineEnd(cm, lineNo) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.view.doc, lineNo)))\n      lineNo = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return {line: lineNo, ch: ch};\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var moveOneUnit = byUnit ? function(pos, dir) {\n      do pos += dir;\n      while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));\n      return pos;\n    } : function(pos, dir) { return pos + dir; };\n    var linedir = bidi[0].level;\n    for (var i = 0; i < bidi.length; ++i) {\n      var part = bidi[i], sticky = part.level % 2 == linedir;\n      if ((part.from < start && part.to > start) ||\n          (sticky && (part.from == start || part.to == start))) break;\n    }\n    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);\n\n    while (target != null) {\n      if (part.level % 2 == linedir) {\n        if (target < part.from || target > part.to) {\n          part = bidi[i += dir];\n          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));\n        } else break;\n      } else {\n        if (target == bidiLeft(part)) {\n          part = bidi[--i];\n          target = part && bidiRight(part);\n        } else if (target == bidiRight(part)) {\n          part = bidi[++i];\n          target = part && bidiLeft(part);\n        } else break;\n      }\n    }\n\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr\";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return \"r\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    return function charOrdering(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [], startType = null;\n      for (var i = 0, type; i < len; ++i) {\n        types.push(type = charType(str.charCodeAt(i)));\n        if (startType == null) {\n          if (type == \"L\") startType = \"L\";\n          else if (type == \"R\" || type == \"r\") startType = \"R\";\n        }\n      }\n      if (startType == null) startType = \"L\";\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = startType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = startType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len - 1 && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = startType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : startType) == \"L\";\n          var after = (end < len - 1 ? types[end] : startType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"3.0\";\n\n  return CodeMirror;\n})();\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/ast-dispatcher.js":"export default class ASTDispatcher {\n  constructor(prefix, errorIfMissing) {\n    this.errorIfMissing = errorIfMissing;\n    this.prefix = prefix;\n  }\n\n  dispatch(term) {\n    let field = this.prefix + term.type;\n    if (typeof this[field] === 'function') {\n      return this[field](term);\n    } else if (!this.errorIfMissing) {\n      return term;\n    }\n    throw new Error(`Missing implementation for: ${field}`);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/binding-map.js":"// @flow\nimport { List } from 'immutable';\nimport { assert } from './errors';\nimport { Maybe } from 'ramda-fantasy';\nimport type { SymbolClass } from './symbol';\nimport Syntax from './syntax';\n\ntype Scopeset = any;\n\ntype ScopesetBinding = {\n  scopes: Scopeset,\n  binding: SymbolClass,\n  alias: Maybe<Syntax>,\n};\n\nexport default class BindingMap {\n  _map: Map<string, List<ScopesetBinding>>;\n\n  constructor() {\n    this._map = new Map();\n  }\n\n  // given a syntax object and a binding,\n  // add the binding to the map associating the binding with the syntax object's\n  // scope set\n  add(\n    stx: Syntax,\n    {\n      binding,\n      phase,\n      skipDup = false,\n    }: { binding: SymbolClass, phase: number | {}, skipDup: boolean },\n  ) {\n    let stxName = stx.val();\n    let allScopeset = stx.scopesets.all;\n    let scopeset = stx.scopesets.phase.has(phase)\n      ? stx.scopesets.phase.get(phase)\n      : List();\n    scopeset = allScopeset.concat(scopeset);\n    assert(phase != null, 'must provide a phase for binding add');\n\n    let scopesetBindingList = this._map.get(stxName);\n    if (scopesetBindingList) {\n      if (skipDup && scopesetBindingList.some(s => s.scopes.equals(scopeset))) {\n        return;\n      }\n      this._map.set(\n        stxName,\n        scopesetBindingList.push({\n          scopes: scopeset,\n          binding: binding,\n          alias: Maybe.Nothing(),\n        }),\n      );\n    } else {\n      this._map.set(\n        stxName,\n        List.of({\n          scopes: scopeset,\n          binding: binding,\n          alias: Maybe.Nothing(),\n        }),\n      );\n    }\n  }\n\n  addForward(\n    stx: Syntax,\n    forwardStx: Syntax,\n    binding: SymbolClass,\n    phase: number | {},\n  ) {\n    let stxName = stx.token.value;\n    let allScopeset = stx.scopesets.all;\n    let scopeset = stx.scopesets.phase.has(phase)\n      ? stx.scopesets.phase.get(phase)\n      : List();\n    scopeset = allScopeset.concat(scopeset);\n    assert(phase != null, 'must provide a phase for binding add');\n\n    let scopesetBindingList = this._map.get(stxName);\n    if (scopesetBindingList) {\n      this._map.set(\n        stxName,\n        scopesetBindingList.push({\n          scopes: scopeset,\n          binding: binding,\n          alias: Maybe.of(forwardStx),\n        }),\n      );\n    } else {\n      this._map.set(\n        stxName,\n        List.of({\n          scopes: scopeset,\n          binding: binding,\n          alias: Maybe.of(forwardStx),\n        }),\n      );\n    }\n  }\n\n  get(stx: Syntax) {\n    return this._map.get(stx.token.value);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/browser-sweet.js":"import { compile as sweetCompile } from './sweet';\nimport StoreLoader from './store-loader';\nimport Store from './store';\n\nclass BrowserStoreLoader extends StoreLoader {\n  store: Map<string, string>;\n\n  constructor(baseDir: string, store: Map<string, string>) {\n    super(baseDir, store, true);\n  }\n\n  fetch({ name, address }: { name: string, address: any }) {\n    if (this.store.has(address.path)) {\n      return this.store.get(address.path);\n    }\n    throw new Error(\n      `The module ${name} is not in the debug store: addr.path is ${address.path}`,\n    );\n  }\n\n  freshStore() {\n    return new Store({});\n  }\n\n  eval(source: string, store: Store) {\n    return (0, eval)(source);\n  }\n}\n\nexport function compile(source, helpers) {\n  let s = new Map();\n  s.set('main.js', source);\n  s.set('sweet.js/helpers.js', helpers);\n  s.set('sweet.js/helpers', helpers);\n  let loader = new BrowserStoreLoader('.', s);\n  return sweetCompile('main.js', loader);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/codegen.js":"import shiftCodegen, { FormattedCodeGen } from 'shift-codegen';\n\nexport default function codegen(modTerm) {\n  return {\n    code: shiftCodegen(modTerm, new FormattedCodeGen()),\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/compiler.js":"import TermExpander from './term-expander.js';\nimport TokenExpander from './token-expander';\nimport * as _ from 'ramda';\n\nexport default class Compiler {\n  constructor(phase, env, store, context) {\n    this.phase = phase;\n    this.env = env;\n    this.store = store;\n    this.context = context;\n  }\n\n  compile(stxl) {\n    let tokenExpander = new TokenExpander(\n      _.merge(this.context, {\n        phase: this.phase,\n        env: this.env,\n        store: this.store,\n      }),\n    );\n    let termExpander = new TermExpander(\n      _.merge(this.context, {\n        phase: this.phase,\n        env: this.env,\n        store: this.store,\n      }),\n    );\n\n    return tokenExpander.expand(stxl).map(t => termExpander.expand(t));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/enforester.js":"// @flow\nimport {\n  isIdentifierExpression,\n  isStaticMemberExpression,\n  isComputedMemberExpression,\n} from './terms';\nimport Term, * as T from 'sweet-spec';\nimport { Maybe } from 'ramda-fantasy';\nimport ScopeReducer from './scope-reducer';\nconst Just = Maybe.Just;\nconst Nothing = Maybe.Nothing;\n\nimport {\n  FunctionDeclTransform,\n  VariableDeclTransform,\n  NewTransform,\n  LetDeclTransform,\n  ConstDeclTransform,\n  SyntaxDeclTransform,\n  SyntaxrecDeclTransform,\n  OperatorDeclTransform,\n  ReturnStatementTransform,\n  WhileTransform,\n  IfTransform,\n  ForTransform,\n  SwitchTransform,\n  BreakTransform,\n  ContinueTransform,\n  DoTransform,\n  DebuggerTransform,\n  YieldTransform,\n  WithTransform,\n  ImportTransform,\n  ExportTransform,\n  SuperTransform,\n  ThisTransform,\n  ClassTransform,\n  DefaultTransform,\n  TryTransform,\n  ThrowTransform,\n  CompiletimeTransform,\n  VarBindingTransform,\n  ModuleNamespaceTransform,\n} from './transforms';\nimport { List } from 'immutable';\nimport { expect, assert } from './errors';\nimport {\n  isOperator,\n  isUnaryOperator,\n  getOperatorAssoc,\n  getOperatorPrec,\n  operatorLt,\n} from './operators';\nimport Syntax, { ALL_PHASES } from './syntax';\nimport type { SymbolClass } from './symbol';\n\nimport { freshScope } from './scope';\nimport { sanitizeReplacementValues } from './load-syntax';\n\nimport MacroContext from './macro-context';\n\nconst EXPR_LOOP_OPERATOR = {};\nconst EXPR_LOOP_NO_CHANGE = {};\nconst EXPR_LOOP_EXPANSION = {};\n\nfunction getLineNumber(x: Syntax | T.Term) {\n  let stx;\n  if (x instanceof Syntax) {\n    stx = x;\n  } else if (x instanceof T.RawSyntax) {\n    stx = x.value;\n  } else if (x instanceof T.RawDelimiter) {\n    return getLineNumber(x.inner.first());\n  } else {\n    throw new Error(`Not implemented yet ${x}`);\n  }\n  return stx.lineNumber();\n}\n\nexport class Enforester {\n  done: boolean;\n  term: ?Term;\n  rest: List<Term>;\n  prev: List<Term>;\n  context: {\n    env: Map<string, any>,\n    store: Map<string, any>,\n    phase: number | {},\n    useScope: SymbolClass,\n    bindings: any,\n  };\n  opCtx: {\n    prec: number,\n    combine: (x: any) => any,\n    stack: List<*>,\n  };\n\n  constructor(stxl: List<Term>, prev: List<Term>, context: any) {\n    this.done = false;\n    assert(List.isList(stxl), 'expecting a list of terms to enforest');\n    assert(List.isList(prev), 'expecting a list of terms to enforest');\n    assert(context, 'expecting a context to enforest');\n    this.term = null;\n\n    this.rest = stxl;\n    this.prev = prev;\n\n    this.context = context;\n  }\n\n  peek(n: number = 0): ?Term {\n    return this.rest.get(n);\n  }\n\n  advance() {\n    let ret: ?Term = this.rest.first();\n    this.rest = this.rest.rest();\n    return ret;\n  }\n\n  /*\n   enforest works over:\n   prev - a list of the previously enforest Terms\n   term - the current term being enforested (initially null)\n   rest - remaining Terms to enforest\n   */\n  enforest(type?: 'expression' | 'Module' = 'Module') {\n    // initialize the term\n    this.term = null;\n\n    if (this.rest.size === 0) {\n      this.done = true;\n      return this.term;\n    }\n\n    if (this.isEOF(this.peek())) {\n      this.term = new T.EOF({});\n      this.advance();\n      return this.term;\n    }\n\n    let result;\n    if (type === 'expression') {\n      result = this.enforestExpressionLoop();\n    } else {\n      result = this.enforestModule();\n    }\n\n    if (this.rest.size === 0) {\n      this.done = true;\n    }\n    return result;\n  }\n\n  enforestModule() {\n    return this.enforestBody();\n  }\n\n  enforestBody() {\n    return this.enforestModuleItem();\n  }\n\n  enforestModuleItem() {\n    let lookahead = this.peek();\n\n    if (this.isImportTransform(lookahead)) {\n      this.advance();\n      return this.enforestImportDeclaration();\n    } else if (this.isExportTransform(lookahead)) {\n      this.advance();\n      return this.enforestExportDeclaration();\n    }\n    return this.enforestStatement();\n  }\n\n  enforestExportDeclaration() {\n    let lookahead = this.peek();\n    if (this.isCompiletimeTransform(lookahead)) {\n      this.expandMacro();\n      lookahead = this.peek();\n    }\n\n    if (this.isPunctuator(lookahead, '*')) {\n      this.advance();\n      let moduleSpecifier = this.enforestFromClause();\n      return new T.ExportAllFrom({ moduleSpecifier });\n    } else if (this.isBraces(lookahead)) {\n      let namedExports = this.enforestExportClause();\n      let moduleSpecifier = null;\n      if (this.isIdentifier(this.peek(), 'from')) {\n        moduleSpecifier = this.enforestFromClause();\n      }\n      return new T.ExportFrom({ namedExports, moduleSpecifier });\n    } else if (this.isClassTransform(lookahead)) {\n      return new T.Export({\n        declaration: this.enforestClass({ isExpr: false }),\n      });\n    } else if (this.isFnDeclTransform(lookahead)) {\n      return new T.Export({\n        declaration: this.enforestFunction({ isExpr: false }),\n      });\n    } else if (this.isDefaultTransform(lookahead)) {\n      this.advance();\n      if (this.isCompiletimeTransform(lookahead)) {\n        this.expandMacro();\n        lookahead = this.peek();\n      }\n\n      if (this.isFnDeclTransform(this.peek())) {\n        return new T.ExportDefault({\n          body: this.enforestFunction({ isExpr: false, inDefault: true }),\n        });\n      } else if (this.isClassTransform(this.peek())) {\n        return new T.ExportDefault({\n          body: this.enforestClass({ isExpr: false, inDefault: true }),\n        });\n      } else {\n        let body = this.enforestExpressionLoop();\n        this.consumeSemicolon();\n        return new T.ExportDefault({ body });\n      }\n    } else if (\n      this.isVarDeclTransform(lookahead) ||\n      this.isLetDeclTransform(lookahead) ||\n      this.isConstDeclTransform(lookahead) ||\n      this.isSyntaxrecDeclTransform(lookahead) ||\n      this.isSyntaxDeclTransform(lookahead) ||\n      this.isOperatorDeclTransform(lookahead)\n    ) {\n      return new T.Export({\n        declaration: this.enforestVariableDeclaration(),\n      });\n    }\n    throw this.createError(lookahead, 'unexpected syntax');\n  }\n\n  enforestExportClause() {\n    let enf = new Enforester(this.matchCurlies(), List(), this.context);\n    let result = [];\n    while (enf.rest.size !== 0) {\n      result.push(enf.enforestExportSpecifier());\n      enf.consumeComma();\n    }\n    return List(result);\n  }\n\n  enforestExportSpecifier() {\n    let name = this.enforestIdentifier();\n    if (this.isIdentifier(this.peek(), 'as')) {\n      this.advance();\n      let exportedName = this.enforestIdentifier();\n      return new T.ExportSpecifier({ name, exportedName });\n    }\n    return new T.ExportSpecifier({\n      name: null,\n      exportedName: name,\n    });\n  }\n\n  enforestImportDeclaration() {\n    let lookahead = this.peek();\n    let defaultBinding = null;\n    let namedImports = List();\n    let forSyntax = false;\n\n    if (this.isStringLiteral(lookahead)) {\n      let moduleSpecifier = this.advance();\n      this.consumeSemicolon();\n      return new T.Import({\n        defaultBinding,\n        namedImports,\n        moduleSpecifier,\n        forSyntax,\n      });\n    }\n\n    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {\n      defaultBinding = this.enforestBindingIdentifier();\n      if (!this.isPunctuator(this.peek(), ',')) {\n        let moduleSpecifier = this.enforestFromClause();\n        if (\n          this.isKeyword(this.peek(), 'for') &&\n          this.isIdentifier(this.peek(1), 'syntax')\n        ) {\n          this.advance();\n          this.advance();\n          forSyntax = true;\n        }\n\n        return new T.Import({\n          defaultBinding,\n          moduleSpecifier,\n          namedImports: List(),\n          forSyntax,\n        });\n      }\n    }\n    this.consumeComma();\n    lookahead = this.peek();\n    if (this.isBraces(lookahead)) {\n      let imports = this.enforestNamedImports();\n      let fromClause = this.enforestFromClause();\n      if (\n        this.isKeyword(this.peek(), 'for') &&\n        this.isIdentifier(this.peek(1), 'syntax')\n      ) {\n        this.advance();\n        this.advance();\n        forSyntax = true;\n      }\n\n      return new T.Import({\n        defaultBinding,\n        forSyntax,\n        namedImports: imports,\n        moduleSpecifier: fromClause,\n      });\n    } else if (this.isPunctuator(lookahead, '*')) {\n      let namespaceBinding = this.enforestNamespaceBinding();\n      let moduleSpecifier = this.enforestFromClause();\n      if (\n        this.isKeyword(this.peek(), 'for') &&\n        this.isIdentifier(this.peek(1), 'syntax')\n      ) {\n        this.advance();\n        this.advance();\n        forSyntax = true;\n      }\n      return new T.ImportNamespace({\n        defaultBinding,\n        forSyntax,\n        namespaceBinding,\n        moduleSpecifier,\n      });\n    }\n    throw this.createError(lookahead, 'unexpected syntax');\n  }\n\n  enforestNamespaceBinding() {\n    this.matchPunctuator('*');\n    this.matchIdentifier('as');\n    return this.enforestBindingIdentifier();\n  }\n\n  enforestNamedImports() {\n    let enf = new Enforester(this.matchCurlies(), List(), this.context);\n    let result = [];\n    while (enf.rest.size !== 0) {\n      result.push(enf.enforestImportSpecifiers());\n      enf.consumeComma();\n    }\n    return List(result);\n  }\n\n  enforestImportSpecifiers() {\n    let lookahead = this.peek();\n    let name;\n    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {\n      name = this.matchRawSyntax();\n      if (!this.isIdentifier(this.peek(), 'as')) {\n        return new T.ImportSpecifier({\n          name: null,\n          binding: new T.BindingIdentifier({\n            name: name,\n          }),\n        });\n      } else {\n        this.matchIdentifier('as');\n      }\n    } else {\n      throw this.createError(lookahead, 'unexpected token in import specifier');\n    }\n    return new T.ImportSpecifier({\n      name,\n      binding: this.enforestBindingIdentifier(),\n    });\n  }\n\n  enforestFromClause() {\n    this.matchIdentifier('from');\n    let lookahead = this.matchStringLiteral();\n    this.consumeSemicolon();\n    return lookahead;\n  }\n\n  enforestStatementListItem() {\n    let lookahead = this.peek();\n\n    if (this.isFnDeclTransform(lookahead)) {\n      return this.enforestFunction({ isExpr: false });\n    } else if (this.isClassTransform(lookahead)) {\n      return this.enforestClass({ isExpr: false });\n    } else {\n      return this.enforestStatement();\n    }\n  }\n\n  enforestStatement() {\n    let lookahead = this.peek();\n\n    if (this.term === null && this.isCompiletimeTransform(lookahead)) {\n      this.expandMacro();\n      lookahead = this.peek();\n    }\n\n    if (\n      this.term === null &&\n      this.isTerm(lookahead) &&\n      lookahead instanceof T.Statement\n    ) {\n      // TODO: check that this is actually an statement\n      return this.advance();\n    }\n\n    if (this.term === null && this.isBraces(lookahead)) {\n      return this.enforestBlockStatement();\n    }\n\n    if (this.term === null && this.isWhileTransform(lookahead)) {\n      return this.enforestWhileStatement();\n    }\n\n    if (this.term === null && this.isIfTransform(lookahead)) {\n      return this.enforestIfStatement();\n    }\n    if (this.term === null && this.isForTransform(lookahead)) {\n      return this.enforestForStatement();\n    }\n    if (this.term === null && this.isSwitchTransform(lookahead)) {\n      return this.enforestSwitchStatement();\n    }\n    if (this.term === null && this.isBreakTransform(lookahead)) {\n      return this.enforestBreakStatement();\n    }\n    if (this.term === null && this.isContinueTransform(lookahead)) {\n      return this.enforestContinueStatement();\n    }\n    if (this.term === null && this.isDoTransform(lookahead)) {\n      return this.enforestDoStatement();\n    }\n    if (this.term === null && this.isDebuggerTransform(lookahead)) {\n      return this.enforestDebuggerStatement();\n    }\n    if (this.term === null && this.isWithTransform(lookahead)) {\n      return this.enforestWithStatement();\n    }\n    if (this.term === null && this.isTryTransform(lookahead)) {\n      return this.enforestTryStatement();\n    }\n    if (this.term === null && this.isThrowTransform(lookahead)) {\n      return this.enforestThrowStatement();\n    }\n\n    // TODO: put somewhere else\n    if (this.term === null && this.isKeyword(lookahead, 'class')) {\n      return this.enforestClass({ isExpr: false });\n    }\n\n    if (this.term === null && this.isFnDeclTransform(lookahead)) {\n      return this.enforestFunction({ isExpr: false });\n    }\n\n    if (\n      this.term === null &&\n      this.isIdentifier(lookahead) &&\n      this.isPunctuator(this.peek(1), ':')\n    ) {\n      return this.enforestLabeledStatement();\n    }\n\n    if (\n      this.term === null &&\n      (this.isVarDeclTransform(lookahead) ||\n        this.isLetDeclTransform(lookahead) ||\n        this.isConstDeclTransform(lookahead) ||\n        this.isSyntaxrecDeclTransform(lookahead) ||\n        this.isSyntaxDeclTransform(lookahead) ||\n        this.isOperatorDeclTransform(lookahead))\n    ) {\n      let stmt = new T.VariableDeclarationStatement({\n        declaration: this.enforestVariableDeclaration(),\n      });\n      this.consumeSemicolon();\n      return stmt;\n    }\n\n    if (this.term === null && this.isReturnStmtTransform(lookahead)) {\n      return this.enforestReturnStatement();\n    }\n\n    if (this.term === null && this.isPunctuator(lookahead, ';')) {\n      this.advance();\n      return new T.EmptyStatement({});\n    }\n\n    return this.enforestExpressionStatement();\n  }\n\n  enforestLabeledStatement() {\n    let label = this.matchIdentifier();\n    this.matchPunctuator(':');\n    let stmt = this.enforestStatement();\n\n    return new T.LabeledStatement({\n      label: label,\n      body: stmt,\n    });\n  }\n\n  enforestBreakStatement() {\n    this.matchKeyword('break');\n    let lookahead = this.peek();\n    let label = null;\n    if (this.rest.size === 0 || this.isPunctuator(lookahead, ';')) {\n      this.consumeSemicolon();\n      return new T.BreakStatement({ label });\n    }\n    if (\n      this.isIdentifier(lookahead) ||\n      this.isKeyword(lookahead, 'yield') ||\n      this.isKeyword(lookahead, 'let')\n    ) {\n      label = this.enforestIdentifier();\n    }\n    this.consumeSemicolon();\n\n    return new T.BreakStatement({ label });\n  }\n\n  enforestTryStatement() {\n    this.matchKeyword('try');\n    let body = this.enforestBlock();\n    if (this.isKeyword(this.peek(), 'catch')) {\n      let catchClause = this.enforestCatchClause();\n      if (this.isKeyword(this.peek(), 'finally')) {\n        this.advance();\n        let finalizer = this.enforestBlock();\n        return new T.TryFinallyStatement({\n          body,\n          catchClause,\n          finalizer,\n        });\n      }\n      return new T.TryCatchStatement({ body, catchClause });\n    }\n    if (this.isKeyword(this.peek(), 'finally')) {\n      this.advance();\n      let finalizer = this.enforestBlock();\n      return new T.TryFinallyStatement({ body, catchClause: null, finalizer });\n    }\n    throw this.createError(this.peek(), 'try with no catch or finally');\n  }\n\n  enforestCatchClause() {\n    this.matchKeyword('catch');\n    let bindingParens = this.matchParens();\n    let enf = new Enforester(bindingParens, List(), this.context);\n    let binding = enf.enforestBindingTarget();\n    let body = this.enforestBlock();\n    return new T.CatchClause({ binding, body });\n  }\n\n  enforestThrowStatement() {\n    this.matchKeyword('throw');\n    let expression = this.enforestExpression();\n    this.consumeSemicolon();\n    return new T.ThrowStatement({ expression });\n  }\n\n  enforestWithStatement() {\n    this.matchKeyword('with');\n    let objParens = this.matchParens();\n    let enf = new Enforester(objParens, List(), this.context);\n    let object = enf.enforestExpression();\n    let body = this.enforestStatement();\n    return new T.WithStatement({ object, body });\n  }\n\n  enforestDebuggerStatement() {\n    this.matchKeyword('debugger');\n\n    return new T.DebuggerStatement({});\n  }\n\n  enforestDoStatement() {\n    this.matchKeyword('do');\n    let body = this.enforestStatement();\n    this.matchKeyword('while');\n    let testBody = this.matchParens();\n    let enf = new Enforester(testBody, List(), this.context);\n    let test = enf.enforestExpression();\n    this.consumeSemicolon();\n    return new T.DoWhileStatement({ body, test });\n  }\n\n  enforestContinueStatement() {\n    let kwd = this.matchKeyword('continue');\n    let lookahead = this.peek();\n    let label = null;\n    if (this.rest.size === 0 || this.isPunctuator(lookahead, ';')) {\n      this.consumeSemicolon();\n      return new T.ContinueStatement({ label });\n    }\n    if (\n      lookahead instanceof T.RawSyntax &&\n      this.lineNumberEq(kwd, lookahead) &&\n      (this.isIdentifier(lookahead) ||\n        this.isKeyword(lookahead, 'yield') ||\n        this.isKeyword(lookahead, 'let'))\n    ) {\n      label = this.enforestIdentifier();\n    }\n    this.consumeSemicolon();\n\n    return new T.ContinueStatement({ label });\n  }\n\n  enforestSwitchStatement() {\n    this.matchKeyword('switch');\n    let cond = this.matchParens();\n    let enf = new Enforester(cond, List(), this.context);\n    let discriminant = enf.enforestExpression();\n    let body = this.matchCurlies();\n\n    if (body.size === 0) {\n      return new T.SwitchStatement({\n        discriminant: discriminant,\n        cases: List(),\n      });\n    }\n    enf = new Enforester(body, List(), this.context);\n    let cases = enf.enforestSwitchCases();\n    let lookahead = enf.peek();\n    if (enf.isKeyword(lookahead, 'default')) {\n      let defaultCase = enf.enforestSwitchDefault();\n      let postDefaultCases = enf.enforestSwitchCases();\n      return new T.SwitchStatementWithDefault({\n        discriminant,\n        preDefaultCases: cases,\n        defaultCase,\n        postDefaultCases,\n      });\n    }\n    return new T.SwitchStatement({ discriminant, cases });\n  }\n\n  enforestSwitchCases() {\n    let cases = [];\n    while (!(this.rest.size === 0 || this.isKeyword(this.peek(), 'default'))) {\n      cases.push(this.enforestSwitchCase());\n    }\n    return List(cases);\n  }\n\n  enforestSwitchCase() {\n    this.matchKeyword('case');\n    return new T.SwitchCase({\n      test: this.enforestExpression(),\n      consequent: this.enforestSwitchCaseBody(),\n    });\n  }\n\n  enforestSwitchCaseBody() {\n    this.matchPunctuator(':');\n    return this.enforestStatementListInSwitchCaseBody();\n  }\n\n  enforestStatementListInSwitchCaseBody() {\n    let result = [];\n    while (\n      !(this.rest.size === 0 ||\n        this.isKeyword(this.peek(), 'default') ||\n        this.isKeyword(this.peek(), 'case'))\n    ) {\n      result.push(this.enforestStatementListItem());\n    }\n    return List(result);\n  }\n\n  enforestSwitchDefault() {\n    this.matchKeyword('default');\n    return new T.SwitchDefault({\n      consequent: this.enforestSwitchCaseBody(),\n    });\n  }\n\n  enforestForStatement() {\n    this.matchKeyword('for');\n    let cond = this.matchParens();\n    let enf = new Enforester(cond, List(), this.context);\n    let lookahead, test, init, right, left, update, cnst;\n\n    // case where init is null\n    if (enf.isPunctuator(enf.peek(), ';')) {\n      enf.advance();\n      if (!enf.isPunctuator(enf.peek(), ';')) {\n        test = enf.enforestExpression();\n      }\n      enf.matchPunctuator(';');\n      if (enf.rest.size !== 0) {\n        right = enf.enforestExpression();\n      }\n      return new T.ForStatement({\n        init: null,\n        test: test,\n        update: right,\n        body: this.enforestStatement(),\n      });\n      // case where init is not null\n    } else {\n      // testing\n      lookahead = enf.peek();\n      if (\n        enf.isVarDeclTransform(lookahead) ||\n        enf.isLetDeclTransform(lookahead) ||\n        enf.isConstDeclTransform(lookahead)\n      ) {\n        init = enf.enforestVariableDeclaration();\n        lookahead = enf.peek();\n        if (\n          this.isKeyword(lookahead, 'in') || this.isIdentifier(lookahead, 'of')\n        ) {\n          if (this.isKeyword(lookahead, 'in')) {\n            enf.advance();\n            right = enf.enforestExpression();\n            cnst = T.ForInStatement;\n          } else {\n            assert(\n              this.isIdentifier(lookahead, 'of'),\n              'expecting `of` keyword',\n            );\n            enf.advance();\n            right = enf.enforestExpression();\n            cnst = T.ForOfStatement;\n          }\n          return new cnst({\n            left: init,\n            right,\n            body: this.enforestStatement(),\n          });\n        }\n        enf.matchPunctuator(';');\n        if (enf.isPunctuator(enf.peek(), ';')) {\n          enf.advance();\n          test = null;\n        } else {\n          test = enf.enforestExpression();\n          enf.matchPunctuator(';');\n        }\n        update = enf.enforestExpression();\n      } else {\n        if (\n          this.isKeyword(enf.peek(1), 'in') ||\n          this.isIdentifier(enf.peek(1), 'of')\n        ) {\n          left = enf.enforestBindingIdentifier();\n          let kind = enf.advance();\n          if (this.isKeyword(kind, 'in')) {\n            cnst = T.ForInStatement;\n          } else {\n            cnst = T.ForOfStatement;\n          }\n          right = enf.enforestExpression();\n          return new cnst({\n            left: left,\n            right,\n            body: this.enforestStatement(),\n          });\n        }\n        init = enf.enforestExpression();\n        enf.matchPunctuator(';');\n        if (enf.isPunctuator(enf.peek(), ';')) {\n          enf.advance();\n          test = null;\n        } else {\n          test = enf.enforestExpression();\n          enf.matchPunctuator(';');\n        }\n        update = enf.enforestExpression();\n      }\n      return new T.ForStatement({\n        init,\n        test,\n        update,\n        body: this.enforestStatement(),\n      });\n    }\n  }\n\n  enforestIfStatement() {\n    this.matchKeyword('if');\n    let cond = this.matchParens();\n    let enf = new Enforester(cond, List(), this.context);\n    let lookahead = enf.peek();\n    let test = enf.enforestExpression();\n    if (test === null) {\n      throw enf.createError(lookahead, 'expecting an expression');\n    }\n    let consequent = this.enforestStatement();\n    let alternate = null;\n    if (this.isKeyword(this.peek(), 'else')) {\n      this.advance();\n      alternate = this.enforestStatement();\n    }\n    return new T.IfStatement({ test, consequent, alternate });\n  }\n\n  enforestWhileStatement() {\n    this.matchKeyword('while');\n    let cond = this.matchParens();\n    let enf = new Enforester(cond, List(), this.context);\n    let lookahead = enf.peek();\n    let test = enf.enforestExpression();\n    if (test === null) {\n      throw enf.createError(lookahead, 'expecting an expression');\n    }\n    let body = this.enforestStatement();\n\n    return new T.WhileStatement({ test, body });\n  }\n\n  enforestBlockStatement() {\n    return new T.BlockStatement({\n      block: this.enforestBlock(),\n    });\n  }\n\n  enforestBlock() {\n    return new T.Block({\n      statements: this.matchCurlies(),\n    });\n  }\n\n  enforestClass({\n    isExpr = false,\n    inDefault = false,\n  }: { isExpr?: boolean, inDefault?: boolean }) {\n    let kw = this.matchRawSyntax();\n    let name = null, supr = null;\n\n    if (this.isIdentifier(this.peek())) {\n      name = this.enforestBindingIdentifier();\n    } else if (!isExpr) {\n      if (inDefault) {\n        name = new T.BindingIdentifier({\n          name: Syntax.fromIdentifier('_default', kw),\n        });\n      } else {\n        throw this.createError(this.peek(), 'unexpected syntax');\n      }\n    }\n\n    if (this.isKeyword(this.peek(), 'extends')) {\n      this.advance();\n      supr = this.enforestExpressionLoop();\n    }\n\n    let elements = [];\n    let enf = new Enforester(this.matchCurlies(), List(), this.context);\n    while (enf.rest.size !== 0) {\n      if (enf.isPunctuator(enf.peek(), ';')) {\n        enf.advance();\n        continue;\n      }\n\n      let isStatic = false;\n      let { methodOrKey, kind } = enf.enforestMethodDefinition();\n      if (kind === 'identifier' && methodOrKey.value.val() === 'static') {\n        isStatic = true;\n        ({ methodOrKey, kind } = enf.enforestMethodDefinition());\n      }\n      if (kind === 'method') {\n        elements.push(new T.ClassElement({ isStatic, method: methodOrKey }));\n      } else {\n        throw this.createError(\n          enf.peek(),\n          'Only methods are allowed in classes',\n        );\n      }\n    }\n    return new (isExpr ? T.ClassExpression : T.ClassDeclaration)({\n      name,\n      super: supr,\n      elements: List(elements),\n    });\n  }\n\n  enforestBindingTarget(\n    { allowPunctuator = false }: { allowPunctuator?: boolean } = {},\n  ) {\n    let lookahead = this.peek();\n    if (\n      this.isIdentifier(lookahead) ||\n      this.isKeyword(lookahead) ||\n      (allowPunctuator && this.isPunctuator(lookahead))\n    ) {\n      return this.enforestBindingIdentifier({ allowPunctuator });\n    } else if (this.isBrackets(lookahead)) {\n      return this.enforestArrayBinding();\n    } else if (this.isBraces(lookahead)) {\n      return this.enforestObjectBinding();\n    }\n    assert(false, 'not implemented yet');\n  }\n\n  enforestObjectBinding() {\n    let enf = new Enforester(this.matchCurlies(), List(), this.context);\n    let properties = [];\n\n    //TODO: implement object rest operator when it lands\n    while (enf.rest.size !== 0) {\n      properties.push(enf.enforestBindingProperty());\n\n      if (enf.rest.size > 0 && !enf.isPunctuator(enf.peek(), ',')) {\n        throw enf.createError(enf.peek(), 'unexpected token');\n      }\n\n      enf.consumeComma();\n    }\n\n    return new T.ObjectBinding({\n      properties: List(properties),\n    });\n  }\n\n  enforestBindingProperty() {\n    let lookahead = this.peek();\n    let { name, binding } = this.enforestPropertyName();\n    if (\n      this.isIdentifier(lookahead) ||\n      this.isKeyword(lookahead, 'let') ||\n      this.isKeyword(lookahead, 'yield')\n    ) {\n      if (!this.isPunctuator(this.peek(), ':')) {\n        let defaultValue = null;\n        if (this.isAssign(this.peek())) {\n          this.advance();\n          let expr = this.enforestExpressionLoop();\n          defaultValue = expr;\n        }\n        return new T.BindingPropertyIdentifier({\n          binding,\n          init: defaultValue,\n        });\n      }\n    }\n    this.matchPunctuator(':');\n    binding = this.enforestBindingElement();\n    return new T.BindingPropertyProperty({\n      name,\n      binding,\n    });\n  }\n\n  enforestArrayBinding() {\n    let bracket = this.matchSquares();\n    let enf = new Enforester(bracket, List(), this.context);\n    let elements = [], restElement = null;\n    while (enf.rest.size !== 0) {\n      let el = null;\n      if (!enf.isPunctuator(enf.peek(), ',')) {\n        if (enf.isPunctuator(enf.peek(), '...')) {\n          enf.advance();\n          restElement = enf.enforestBindingTarget();\n          if (enf.rest.size > 0) {\n            throw enf.createError(\n              '',\n              'Rest element must be last element in array',\n            );\n          }\n        } else {\n          el = enf.enforestBindingElement();\n\n          if (el == null) {\n            throw enf.createError(enf.peek(), 'expected expression');\n          }\n          if (enf.rest.size > 0 && !enf.isPunctuator(enf.peek(), ',')) {\n            throw enf.createError(enf.peek(), 'unexpected token');\n          }\n        }\n      }\n      if (restElement == null) {\n        elements.push(el);\n        enf.consumeComma();\n      }\n    }\n    return new T.ArrayBinding({\n      elements: List(elements),\n      restElement,\n    });\n  }\n\n  enforestBindingElement() {\n    let binding = this.enforestBindingTarget();\n\n    if (this.isAssign(this.peek())) {\n      this.advance();\n      let init = this.enforestExpressionLoop();\n      binding = new T.BindingWithDefault({ binding, init });\n    }\n    return binding;\n  }\n\n  enforestBindingIdentifier(\n    { allowPunctuator }: { allowPunctuator?: boolean } = {},\n  ) {\n    let name;\n    if (allowPunctuator && this.isPunctuator(this.peek())) {\n      name = this.enforestPunctuator();\n    } else {\n      name = this.enforestIdentifier();\n    }\n    return new T.BindingIdentifier({ name });\n  }\n\n  enforestPunctuator() {\n    let lookahead = this.peek();\n    if (this.isPunctuator(lookahead)) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting a punctuator');\n  }\n\n  enforestIdentifier() {\n    let lookahead = this.peek();\n    if (this.isIdentifier(lookahead) || this.isKeyword(lookahead)) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting an identifier');\n  }\n\n  enforestReturnStatement() {\n    let kw = this.matchRawSyntax();\n    let lookahead = this.peek();\n\n    // short circuit for the empty expression case\n    if (\n      this.rest.size === 0 || (lookahead && !this.lineNumberEq(kw, lookahead))\n    ) {\n      return new T.ReturnStatement({\n        expression: null,\n      });\n    }\n\n    let term = null;\n    if (!this.isPunctuator(lookahead, ';')) {\n      term = this.enforestExpression();\n      expect(\n        term != null,\n        'Expecting an expression to follow return keyword',\n        lookahead,\n        this.rest,\n      );\n    }\n\n    this.consumeSemicolon();\n    return new T.ReturnStatement({\n      expression: term,\n    });\n  }\n\n  enforestVariableDeclaration() {\n    let kind;\n    let lookahead = this.advance();\n\n    if (this.isVarDeclTransform(lookahead)) {\n      kind = 'var';\n    } else if (this.isLetDeclTransform(lookahead)) {\n      kind = 'let';\n    } else if (this.isConstDeclTransform(lookahead)) {\n      kind = 'const';\n    } else if (this.isSyntaxDeclTransform(lookahead)) {\n      kind = 'syntax';\n    } else if (this.isSyntaxrecDeclTransform(lookahead)) {\n      kind = 'syntaxrec';\n    } else if (this.isOperatorDeclTransform(lookahead)) {\n      kind = 'operator';\n    }\n\n    let decls = List();\n\n    while (true) {\n      let term = this.enforestVariableDeclarator({\n        isSyntax: kind === 'syntax' ||\n          kind === 'syntaxrec' ||\n          kind === 'operator',\n        isOperator: kind === 'operator',\n      });\n      let lookahead = this.peek();\n      decls = decls.concat(term);\n\n      if (this.isPunctuator(lookahead, ',')) {\n        this.advance();\n      } else {\n        break;\n      }\n    }\n\n    return new T.VariableDeclaration({\n      kind: kind,\n      declarators: decls,\n    });\n  }\n\n  enforestVariableDeclarator({\n    isSyntax,\n    isOperator,\n  }: { isSyntax: boolean, isOperator: boolean }) {\n    let id = this.enforestBindingTarget({ allowPunctuator: isSyntax });\n    const AssocValues = ['left', 'right', 'prefix', 'postfix'];\n\n    let assoc, prec;\n    if (isOperator) {\n      assoc = this.matchIdentifier();\n      if (AssocValues.indexOf(assoc.val()) === -1) {\n        throw this.createError(\n          this.peek(),\n          `Associativity must be one of ${AssocValues.join(',')}`,\n        );\n      }\n      prec = this.matchLiteral();\n    }\n\n    let init;\n    if (this.isPunctuator(this.peek(), '=')) {\n      this.advance();\n      let enf = new Enforester(this.rest, List(), this.context);\n      init = enf.enforest('expression');\n      this.rest = enf.rest;\n    } else {\n      init = null;\n    }\n\n    if (isOperator) {\n      return new T.OperatorDeclarator({\n        binding: id,\n        init,\n        prec,\n        assoc,\n      });\n    }\n    return new T.VariableDeclarator({\n      binding: id,\n      init: init,\n    });\n  }\n\n  enforestExpressionStatement() {\n    let start = this.rest.get(0);\n    let expr = this.enforestExpression();\n    if (expr === null) {\n      throw this.createError(start, 'not a valid expression');\n    }\n    this.consumeSemicolon();\n\n    return new T.ExpressionStatement({\n      expression: expr,\n    });\n  }\n\n  enforestExpression() {\n    let left = this.enforestExpressionLoop();\n    let lookahead = this.peek();\n    if (this.isPunctuator(lookahead, ',')) {\n      while (this.rest.size !== 0) {\n        if (!this.isPunctuator(this.peek(), ',')) {\n          break;\n        }\n        let operator = this.matchRawSyntax();\n        let right = this.enforestExpressionLoop();\n        left = new T.BinaryExpression({\n          left,\n          operator: operator.val(),\n          right,\n        });\n      }\n    }\n    this.term = null;\n    return left;\n  }\n\n  enforestExpressionLoop() {\n    this.term = null;\n    this.opCtx = {\n      prec: 0,\n      combine: x => x,\n      stack: List(),\n    };\n\n    do {\n      let term = this.enforestAssignmentExpression();\n      // no change means we've done as much enforesting as possible\n      // if nothing changed, maybe we just need to pop the expr stack\n      if (term === EXPR_LOOP_NO_CHANGE && this.opCtx.stack.size > 0) {\n        this.term = this.opCtx.combine(this.term);\n        let { prec, combine } = this.opCtx.stack.last();\n        this.opCtx.prec = prec;\n        this.opCtx.combine = combine;\n        this.opCtx.stack = this.opCtx.stack.pop();\n      } else if (term === EXPR_LOOP_NO_CHANGE) {\n        break;\n      } else if (term === EXPR_LOOP_OPERATOR || term === EXPR_LOOP_EXPANSION) {\n        // operator means an opCtx was pushed on the stack\n        this.term = null;\n      } else {\n        this.term = term;\n      }\n    } while (true); // get a fixpoint\n    return this.term;\n  }\n\n  enforestAssignmentExpression() {\n    let lookahead = this.peek();\n\n    if (this.term === null && this.isModuleNamespaceTransform(lookahead)) {\n      // $FlowFixMe: we need to refactor the enforester to make flow work better\n      let namespace = this.getFromCompiletimeEnvironment(this.advance().value);\n      this.matchPunctuator('.');\n      let name = this.matchIdentifier();\n      // $FlowFixMe: we need to refactor the enforester to make flow work better\n      let exportedName = namespace.mod.exportedNames.find(\n        exName => exName.exportedName.val() === name.val(),\n      );\n      this.rest = this.rest.unshift(\n        new T.RawSyntax({\n          value: Syntax.fromIdentifier(name.val(), exportedName.exportedName),\n        }),\n      );\n      lookahead = this.peek();\n    }\n\n    if (this.term === null && this.isCompiletimeTransform(lookahead)) {\n      this.expandMacro();\n      lookahead = this.peek();\n    }\n\n    if (\n      this.term === null &&\n      this.isTerm(lookahead) &&\n      lookahead instanceof T.Expression\n    ) {\n      // TODO: check that this is actually an expression\n      return this.advance();\n    }\n\n    if (this.term === null && this.isYieldTransform(lookahead)) {\n      return this.enforestYieldExpression();\n    }\n\n    if (this.term === null && this.isClassTransform(lookahead)) {\n      return this.enforestClass({ isExpr: true });\n    }\n\n    if (\n      this.term === null &&\n      lookahead &&\n      (this.isIdentifier(lookahead) || this.isParens(lookahead)) &&\n      this.isPunctuator(this.peek(1), '=>') &&\n      this.lineNumberEq(lookahead, this.peek(1))\n    ) {\n      return this.enforestArrowExpression();\n    }\n\n    if (this.term === null && this.isSyntaxTemplate(lookahead)) {\n      return this.enforestSyntaxTemplate();\n    }\n\n    // ($x:expr)\n    if (this.term === null && this.isParens(lookahead)) {\n      return new T.ParenthesizedExpression({\n        inner: this.matchParens(),\n      });\n    }\n\n    if (\n      this.term === null &&\n      (this.isKeyword(lookahead, 'this') ||\n        this.isIdentifier(lookahead) ||\n        this.isKeyword(lookahead, 'let') ||\n        this.isKeyword(lookahead, 'yield') ||\n        this.isNumericLiteral(lookahead) ||\n        this.isStringLiteral(lookahead) ||\n        this.isTemplate(lookahead) ||\n        this.isBooleanLiteral(lookahead) ||\n        this.isNullLiteral(lookahead) ||\n        this.isRegularExpression(lookahead) ||\n        this.isFnDeclTransform(lookahead) ||\n        this.isBraces(lookahead) ||\n        this.isBrackets(lookahead))\n    ) {\n      return this.enforestPrimaryExpression();\n    }\n\n    // prefix unary\n    if (\n      this.term === null &&\n      (this.isOperator(lookahead) || this.isCustomPrefixOperator(lookahead))\n    ) {\n      return this.enforestUnaryExpression();\n    }\n\n    if (\n      this.term === null &&\n      this.isVarBindingTransform(lookahead) &&\n      lookahead instanceof T.RawSyntax\n    ) {\n      let lookstx = lookahead.value;\n      // $FlowFixMe\n      let id = this.getFromCompiletimeEnvironment(lookstx).id;\n      if (id !== lookstx) {\n        this.advance();\n        this.rest = List.of(id).concat(this.rest);\n        return EXPR_LOOP_EXPANSION;\n      }\n    }\n\n    if (\n      (this.term === null &&\n        (this.isNewTransform(lookahead) || this.isSuperTransform(lookahead))) ||\n      // and then check the cases where the term part of p is something...\n      (this.term &&\n        // $x:expr . $prop:ident\n        ((this.isPunctuator(lookahead, '.') &&\n          (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))) ||\n          // $x:expr [ $b:expr ]\n          this.isBrackets(lookahead) ||\n          // $x:expr (...)\n          this.isParens(lookahead)))\n    ) {\n      return this.enforestLeftHandSideExpression({ allowCall: true });\n    }\n\n    // $l:expr $op:binaryOperator $r:expr\n    if (this.term && this.isCustomBinaryOperator(lookahead)) {\n      return this.enforestBinaryExpression();\n    }\n\n    // postfix unary\n    if (\n      this.term &&\n      (this.isUpdateOperator(lookahead) ||\n        this.isCustomPostfixOperator(lookahead))\n    ) {\n      return this.enforestUpdateExpression();\n    }\n\n    // $l:expr $op:binaryOperator $r:expr\n    if (\n      this.term &&\n      (this.isOperator(lookahead) || this.isCustomBinaryOperator(lookahead))\n    ) {\n      return this.enforestBinaryExpression();\n    }\n\n    // $x:id `...`\n    if (this.term && this.isTemplate(lookahead)) {\n      return this.enforestTemplateLiteral();\n    }\n\n    // $x:expr = $init:expr\n    if (this.term && this.isAssign(lookahead)) {\n      let binding = this.transformDestructuring(this.term);\n      let op = this.matchRawSyntax();\n\n      let enf = new Enforester(this.rest, List(), this.context);\n      let init = enf.enforest('expression');\n      this.rest = enf.rest;\n\n      if (op.val() === '=') {\n        return new T.AssignmentExpression({\n          binding,\n          expression: init,\n        });\n      } else {\n        return new T.CompoundAssignmentExpression({\n          binding,\n          operator: op.val(),\n          expression: init,\n        });\n      }\n    }\n\n    if (this.term && this.isPunctuator(lookahead, '?')) {\n      return this.enforestConditionalExpression();\n    }\n\n    return EXPR_LOOP_NO_CHANGE;\n  }\n\n  enforestPrimaryExpression() {\n    let lookahead = this.peek();\n    // $x:ThisExpression\n    if (this.term === null && this.isKeyword(lookahead, 'this')) {\n      return this.enforestThisExpression();\n    }\n    // $x:ident\n    if (\n      this.term === null &&\n      (this.isIdentifier(lookahead) ||\n        this.isKeyword(lookahead, 'let') ||\n        this.isKeyword(lookahead, 'yield'))\n    ) {\n      return this.enforestIdentifierExpression();\n    }\n    if (this.term === null && this.isNumericLiteral(lookahead)) {\n      return this.enforestNumericLiteral();\n    }\n    if (this.term === null && this.isStringLiteral(lookahead)) {\n      return this.enforestStringLiteral();\n    }\n    if (this.term === null && this.isTemplate(lookahead)) {\n      return this.enforestTemplateLiteral();\n    }\n    if (this.term === null && this.isBooleanLiteral(lookahead)) {\n      return this.enforestBooleanLiteral();\n    }\n    if (this.term === null && this.isNullLiteral(lookahead)) {\n      return this.enforestNullLiteral();\n    }\n    if (this.term === null && this.isRegularExpression(lookahead)) {\n      return this.enforestRegularExpressionLiteral();\n    }\n    // $x:FunctionExpression\n    if (this.term === null && this.isFnDeclTransform(lookahead)) {\n      return this.enforestFunction({ isExpr: true });\n    }\n    // { $p:prop (,) ... }\n    if (this.term === null && this.isBraces(lookahead)) {\n      return this.enforestObjectExpression();\n    }\n    // [$x:expr (,) ...]\n    if (this.term === null && this.isBrackets(lookahead)) {\n      return this.enforestArrayExpression();\n    }\n    assert(false, 'Not a primary expression');\n  }\n\n  enforestLeftHandSideExpression({ allowCall }: { allowCall: boolean }) {\n    let lookahead = this.peek();\n\n    if (this.isCompiletimeTransform(lookahead)) {\n      this.expandMacro();\n      lookahead = this.peek();\n    }\n\n    if (this.isSuperTransform(lookahead)) {\n      this.advance();\n      this.term = new T.Super({});\n    } else if (this.isNewTransform(lookahead)) {\n      this.term = this.enforestNewExpression();\n    } else if (this.isThisTransform(lookahead)) {\n      this.term = this.enforestThisExpression();\n    } else if (this.isBraces(lookahead)) {\n      this.term = this.enforestPrimaryExpression();\n      return this.term;\n    }\n\n    while (true) {\n      lookahead = this.peek();\n      if (this.isParens(lookahead)) {\n        if (!allowCall) {\n          // we're dealing with a new expression\n          if (\n            this.term &&\n            (isIdentifierExpression(this.term) ||\n              isStaticMemberExpression(this.term) ||\n              isComputedMemberExpression(this.term))\n          ) {\n            return this.term;\n          }\n          this.term = this.enforestExpressionLoop();\n        } else {\n          this.term = this.enforestCallExpression();\n        }\n      } else if (this.isBrackets(lookahead)) {\n        this.term = this.term\n          ? this.enforestComputedMemberExpression()\n          : this.enforestPrimaryExpression();\n      } else if (\n        this.isPunctuator(lookahead, '.') &&\n        (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))\n      ) {\n        this.term = this.enforestStaticMemberExpression();\n      } else if (this.isTemplate(lookahead)) {\n        this.term = this.enforestTemplateLiteral();\n      } else if (this.isIdentifier(lookahead)) {\n        if (this.term) break;\n        this.term = new T.IdentifierExpression({\n          name: this.enforestIdentifier(),\n        });\n      } else {\n        break;\n      }\n    }\n    return this.term;\n  }\n\n  enforestBooleanLiteral() {\n    return new T.LiteralBooleanExpression({\n      value: this.matchRawSyntax().val() === 'true',\n    });\n  }\n\n  enforestTemplateLiteral() {\n    return new T.TemplateExpression({\n      tag: this.term,\n      elements: this.enforestTemplateElements(),\n    });\n  }\n\n  enforestStringLiteral() {\n    return new T.LiteralStringExpression({\n      value: this.matchRawSyntax().val(),\n    });\n  }\n\n  enforestNumericLiteral() {\n    let num = this.matchRawSyntax();\n    if (num.val() === 1 / 0) {\n      return new T.LiteralInfinityExpression({});\n    }\n    return new T.LiteralNumericExpression({\n      value: num.val(),\n    });\n  }\n\n  enforestIdentifierExpression() {\n    return new T.IdentifierExpression({\n      name: this.matchRawSyntax(),\n    });\n  }\n\n  enforestRegularExpressionLiteral() {\n    let reStx = this.matchRawSyntax();\n\n    let lastSlash = reStx.token.value.lastIndexOf('/');\n    let pattern = reStx.token.value.slice(1, lastSlash);\n    let flags = reStx.token.value.slice(lastSlash + 1);\n    return new T.LiteralRegExpExpression({\n      pattern,\n      flags,\n    });\n  }\n\n  enforestNullLiteral() {\n    this.advance();\n    return new T.LiteralNullExpression({});\n  }\n\n  enforestThisExpression() {\n    return new T.ThisExpression({\n      stx: this.matchRawSyntax(),\n    });\n  }\n\n  enforestArgumentList() {\n    let result = [];\n    while (this.rest.size > 0) {\n      let arg;\n      if (this.isPunctuator(this.peek(), '...')) {\n        this.advance();\n        arg = new T.SpreadElement({\n          expression: this.enforestExpressionLoop(),\n        });\n      } else {\n        arg = this.enforestExpressionLoop();\n      }\n      if (this.rest.size > 0) {\n        this.matchPunctuator(',');\n      }\n      result.push(arg);\n    }\n    return List(result);\n  }\n\n  enforestNewExpression() {\n    this.matchKeyword('new');\n    if (\n      this.isPunctuator(this.peek(), '.') &&\n      this.isIdentifier(this.peek(1), 'target')\n    ) {\n      this.advance();\n      this.advance();\n      return new T.NewTargetExpression({});\n    }\n\n    let callee = this.enforestLeftHandSideExpression({ allowCall: false });\n    let args;\n    if (this.isParens(this.peek())) {\n      args = this.matchParens();\n    } else {\n      args = List();\n    }\n    return new T.NewExpression({\n      callee,\n      arguments: args,\n    });\n  }\n\n  enforestComputedMemberExpression() {\n    let enf = new Enforester(this.matchSquares(), List(), this.context);\n    return new T.ComputedMemberExpression({\n      object: this.term,\n      expression: enf.enforestExpression(),\n    });\n  }\n\n  transformDestructuring(term: Term) {\n    switch (term.type) {\n      case 'IdentifierExpression':\n        return new T.BindingIdentifier({ name: term.name });\n\n      case 'ParenthesizedExpression':\n        if (term.inner.size === 1 && this.isIdentifier(term.inner.get(0))) {\n          return new T.BindingIdentifier({ name: term.inner.get(0).value });\n        }\n        return term;\n      case 'DataProperty':\n        return new T.BindingPropertyProperty({\n          name: term.name,\n          binding: this.transformDestructuringWithDefault(term.expression),\n        });\n      case 'ShorthandProperty':\n        return new T.BindingPropertyIdentifier({\n          binding: new T.BindingIdentifier({ name: term.name }),\n          init: null,\n        });\n      case 'ObjectExpression':\n        return new T.ObjectBinding({\n          properties: term.properties.map(t => this.transformDestructuring(t)),\n        });\n      case 'ArrayExpression': {\n        let last = term.elements.last();\n        if (last != null && last.type === 'SpreadElement') {\n          return new T.ArrayBinding({\n            elements: term.elements\n              .slice(0, -1)\n              .map(t => t && this.transformDestructuringWithDefault(t)),\n            restElement: this.transformDestructuringWithDefault(\n              last.expression,\n            ),\n          });\n        } else {\n          return new T.ArrayBinding({\n            elements: term.elements.map(\n              t => t && this.transformDestructuringWithDefault(t),\n            ),\n            restElement: null,\n          });\n        }\n      }\n      case 'StaticPropertyName':\n        return new T.BindingIdentifier({\n          name: term.value,\n        });\n      case 'ComputedMemberExpression':\n      case 'StaticMemberExpression':\n      case 'ArrayBinding':\n      case 'BindingIdentifier':\n      case 'BindingPropertyIdentifier':\n      case 'BindingPropertyProperty':\n      case 'BindingWithDefault':\n      case 'ObjectBinding':\n        return term;\n    }\n    assert(false, 'not implemented yet for ' + term.type);\n  }\n\n  transformDestructuringWithDefault(term: Term) {\n    switch (term.type) {\n      case 'AssignmentExpression':\n        return new T.BindingWithDefault({\n          binding: this.transformDestructuring(term.binding),\n          init: term.expression,\n        });\n    }\n    return this.transformDestructuring(term);\n  }\n\n  enforestCallExpression() {\n    let paren = this.matchParens();\n    return new T.CallExpressionE({\n      callee: this.term,\n      arguments: paren,\n    });\n  }\n\n  enforestArrowExpression() {\n    let enf;\n    if (this.isIdentifier(this.peek())) {\n      enf = new Enforester(List.of(this.advance()), List(), this.context);\n    } else {\n      let p = this.matchParens();\n      enf = new Enforester(p, List(), this.context);\n    }\n    let params = enf.enforestFormalParameters();\n    this.matchPunctuator('=>');\n\n    let body;\n    if (this.isBraces(this.peek())) {\n      body = this.matchCurlies();\n      return new T.ArrowExpressionE({ params, body });\n    } else {\n      enf = new Enforester(this.rest, List(), this.context);\n      body = enf.enforestExpressionLoop();\n      this.rest = enf.rest;\n      return new T.ArrowExpression({ params, body });\n    }\n  }\n\n  enforestYieldExpression() {\n    let kwd = this.matchKeyword('yield');\n    let lookahead = this.peek();\n\n    if (\n      this.rest.size === 0 || (lookahead && !this.lineNumberEq(kwd, lookahead))\n    ) {\n      return new T.YieldExpression({\n        expression: null,\n      });\n    } else {\n      let isGenerator = false;\n      if (this.isPunctuator(this.peek(), '*')) {\n        isGenerator = true;\n        this.advance();\n      }\n      let expr = this.enforestExpression();\n      return new (isGenerator\n        ? T.YieldGeneratorExpression\n        : T.YieldExpression)({\n        expression: expr,\n      });\n    }\n  }\n\n  enforestSyntaxTemplate() {\n    return new T.SyntaxTemplate({\n      template: this.matchRawDelimiter(),\n    });\n  }\n\n  enforestStaticMemberExpression() {\n    let object = this.term;\n    this.advance();\n    let property = this.matchRawSyntax();\n\n    return new T.StaticMemberExpression({\n      object: object,\n      property: property,\n    });\n  }\n\n  enforestArrayExpression() {\n    let arr = this.matchSquares();\n\n    let elements = [];\n\n    let enf = new Enforester(arr, List(), this.context);\n\n    while (enf.rest.size > 0) {\n      let lookahead = enf.peek();\n      let expression = null;\n      if (!enf.isPunctuator(lookahead, ',')) {\n        let isSpread = false;\n        if (enf.isPunctuator(lookahead, '...')) {\n          enf.advance();\n          isSpread = true;\n        }\n        expression = enf.enforestExpressionLoop();\n        if (expression == null) {\n          // this was a macro that expanded to nothing\n          continue;\n        }\n        if (enf.rest.size > 0 && !enf.isPunctuator(enf.peek(), ',')) {\n          throw enf.createError(enf.peek(), 'unexpected token');\n        }\n        if (isSpread) {\n          expression = new T.SpreadElement({ expression });\n        }\n      }\n      enf.consumeComma();\n      elements.push(expression);\n    }\n\n    return new T.ArrayExpression({\n      elements: List(elements),\n    });\n  }\n\n  enforestObjectExpression() {\n    let obj = this.matchCurlies();\n\n    let properties = List();\n\n    let enf = new Enforester(obj, List(), this.context);\n\n    let lastProp = null;\n    //TODO: implement object spread operator when it lands\n    while (enf.rest.size > 0) {\n      let prop = enf.enforestPropertyDefinition();\n\n      if (enf.rest.size > 0 && !enf.isPunctuator(enf.peek(), ',')) {\n        throw enf.createError(enf.peek(), 'unexpected token');\n      }\n\n      enf.consumeComma();\n      properties = properties.concat(prop);\n\n      if (lastProp === prop) {\n        throw enf.createError(prop, 'invalid syntax in object');\n      }\n      lastProp = prop;\n    }\n\n    return new T.ObjectExpression({\n      properties: properties,\n    });\n  }\n\n  enforestPropertyDefinition() {\n    let { methodOrKey, kind } = this.enforestMethodDefinition();\n\n    switch (kind) {\n      case 'method':\n        return methodOrKey;\n      case 'identifier':\n        if (this.isAssign(this.peek())) {\n          this.advance();\n          let init = this.enforestExpressionLoop();\n          return new T.BindingPropertyIdentifier({\n            init,\n            binding: this.transformDestructuring(methodOrKey),\n          });\n        } else if (!this.isPunctuator(this.peek(), ':')) {\n          return new T.ShorthandProperty({\n            name: methodOrKey.value,\n          });\n        }\n    }\n\n    this.matchPunctuator(':');\n    let expr = this.enforestExpressionLoop();\n\n    return new T.DataProperty({\n      name: methodOrKey,\n      expression: expr,\n    });\n  }\n\n  enforestMethodDefinition() {\n    let lookahead = this.peek();\n    let isGenerator = false;\n    if (this.isPunctuator(lookahead, '*')) {\n      isGenerator = true;\n      this.advance();\n    }\n\n    if (\n      this.isIdentifier(lookahead, 'get') && this.isPropertyName(this.peek(1))\n    ) {\n      this.advance();\n      let { name } = this.enforestPropertyName();\n      this.matchParens();\n      let body = this.matchCurlies();\n      return {\n        methodOrKey: new T.Getter({ name, body }),\n        kind: 'method',\n      };\n    } else if (\n      this.isIdentifier(lookahead, 'set') && this.isPropertyName(this.peek(1))\n    ) {\n      this.advance();\n      let { name } = this.enforestPropertyName();\n      let enf = new Enforester(this.matchParens(), List(), this.context);\n      let param = enf.enforestBindingElement();\n      let body = this.matchCurlies();\n      return {\n        methodOrKey: new T.Setter({ name, param, body }),\n        kind: 'method',\n      };\n    }\n    let { name } = this.enforestPropertyName();\n    if (this.isParens(this.peek())) {\n      let params = this.matchParens();\n      let enf = new Enforester(params, List(), this.context);\n      let formalParams = enf.enforestFormalParameters();\n\n      let body = this.matchCurlies();\n      return {\n        methodOrKey: new T.Method({\n          isGenerator,\n          name,\n          params: formalParams,\n          body,\n        }),\n        kind: 'method',\n      };\n    }\n    return {\n      methodOrKey: name,\n      kind: this.isIdentifier(lookahead) || this.isKeyword(lookahead)\n        ? 'identifier'\n        : 'property',\n    };\n  }\n\n  enforestPropertyName() {\n    let lookahead = this.peek();\n\n    if (this.isStringLiteral(lookahead) || this.isNumericLiteral(lookahead)) {\n      return {\n        name: new T.StaticPropertyName({\n          value: this.matchRawSyntax(),\n        }),\n        binding: null,\n      };\n    } else if (this.isBrackets(lookahead)) {\n      let enf = new Enforester(this.matchSquares(), List(), this.context);\n      let expr = enf.enforestExpressionLoop();\n      return {\n        name: new T.ComputedPropertyName({\n          expression: expr,\n        }),\n        binding: null,\n      };\n    }\n    let name = this.matchRawSyntax();\n    return {\n      name: new T.StaticPropertyName({ value: name }),\n      binding: new T.BindingIdentifier({ name }),\n    };\n  }\n\n  enforestFunction({\n    isExpr,\n    inDefault,\n  }: { isExpr?: boolean, inDefault?: boolean }) {\n    let name = null, params, body;\n    let isGenerator = false;\n    // eat the function keyword\n    let fnKeyword = this.matchRawSyntax();\n    let lookahead = this.peek();\n\n    if (this.isPunctuator(lookahead, '*')) {\n      isGenerator = true;\n      this.advance();\n      lookahead = this.peek();\n    }\n\n    if (!this.isParens(lookahead)) {\n      name = this.enforestBindingIdentifier();\n    } else if (inDefault) {\n      name = new T.BindingIdentifier({\n        name: Syntax.fromIdentifier('*default*', fnKeyword),\n      });\n    }\n\n    params = this.matchParens();\n\n    body = this.matchCurlies();\n\n    let enf = new Enforester(params, List(), this.context);\n    let formalParams = enf.enforestFormalParameters();\n\n    return new (isExpr ? T.FunctionExpressionE : T.FunctionDeclarationE)({\n      name: name,\n      isGenerator: isGenerator,\n      params: formalParams,\n      body: body,\n    });\n  }\n\n  enforestFormalParameters() {\n    let items = [];\n    let rest = null;\n    while (this.rest.size !== 0) {\n      let lookahead = this.peek();\n      if (this.isPunctuator(lookahead, '...')) {\n        this.matchPunctuator('...');\n        rest = this.enforestBindingIdentifier();\n        break;\n      }\n      items.push(this.enforestParam());\n      this.consumeComma();\n    }\n    return new T.FormalParameters({\n      items: List(items),\n      rest,\n    });\n  }\n\n  enforestParam() {\n    return this.enforestBindingElement();\n  }\n\n  enforestUpdateExpression() {\n    const lookahead = this.peek();\n    const leftTerm = this.term;\n    if (!lookahead) {\n      throw this.createError(lookahead, 'assertion failure: operator is null');\n    }\n    let operator = this.matchRawSyntax();\n    if (this.isCompiletimeTransform(lookahead)) {\n      const operatorTransform = this.getFromCompiletimeEnvironment(operator);\n      if (!operatorTransform || operatorTransform.value.type !== 'operator') {\n        throw this.createError(lookahead, 'unexpected transform');\n      }\n      let result = operatorTransform.value.f.call(null, leftTerm);\n      let enf = new Enforester(result, List(), this.context);\n      return enf.enforestExpressionLoop();\n    }\n    return new T.UpdateExpression({\n      isPrefix: false,\n      operator: operator.val(),\n      operand: this.transformDestructuring(leftTerm),\n    });\n  }\n\n  enforestUnaryExpression() {\n    const lookahead = this.peek();\n    if (!lookahead) {\n      throw this.createError(lookahead, 'assertion failure: operator is null');\n    }\n    let operator = this.matchRawSyntax();\n    let prec, combine;\n    if (this.isCompiletimeTransform(lookahead)) {\n      const operatorTransform = this.getFromCompiletimeEnvironment(lookahead);\n      if (!operatorTransform || operatorTransform.value.type !== 'operator') {\n        throw this.createError(lookahead, 'unexpected transform');\n      }\n      prec = operatorTransform.value.prec;\n      combine = rightTerm => {\n        return this.expandOperator(lookahead, operatorTransform, [rightTerm]);\n      };\n    } else {\n      // all builtins are 16\n      prec = 16;\n      combine = rightTerm => {\n        if (operator.val() === '++' || operator.val() === '--') {\n          return new T.UpdateExpression({\n            operator: operator.val(),\n            operand: this.transformDestructuring(rightTerm),\n            isPrefix: true,\n          });\n        } else {\n          return new T.UnaryExpression({\n            operator: operator.val(),\n            operand: rightTerm,\n          });\n        }\n      };\n    }\n\n    this.opCtx.stack = this.opCtx.stack.push({\n      prec: this.opCtx.prec,\n      combine: this.opCtx.combine,\n    });\n    this.opCtx.prec = prec;\n    this.opCtx.combine = rightTerm => {\n      return combine(rightTerm);\n    };\n    return EXPR_LOOP_OPERATOR;\n  }\n\n  enforestConditionalExpression() {\n    // first, pop the operator stack\n    let test = this.opCtx.combine(this.term);\n    if (this.opCtx.stack.size > 0) {\n      let { prec, combine } = this.opCtx.stack.last();\n      this.opCtx.stack = this.opCtx.stack.pop();\n      this.opCtx.prec = prec;\n      this.opCtx.combine = combine;\n    }\n\n    this.matchPunctuator('?');\n    let enf = new Enforester(this.rest, List(), this.context);\n    let consequent = enf.enforestExpressionLoop();\n    enf.matchPunctuator(':');\n    enf = new Enforester(enf.rest, List(), this.context);\n    let alternate = enf.enforestExpressionLoop();\n    this.rest = enf.rest;\n    return new T.ConditionalExpression({\n      test,\n      consequent,\n      alternate,\n    });\n  }\n\n  enforestBinaryExpression() {\n    let leftTerm = this.term;\n    const opStx = this.peek();\n    if (!opStx) {\n      throw this.createError(opStx, 'assertion failure: opStx is null');\n    }\n\n    let prec, assoc, combine;\n    if (this.isCompiletimeTransform(this.peek())) {\n      const operatorTransform = this.getFromCompiletimeEnvironment(opStx.value);\n      if (!operatorTransform || operatorTransform.value.type !== 'operator') {\n        throw this.createError(opStx.value, 'unexpected transform');\n      }\n      prec = operatorTransform.value.prec;\n      assoc = operatorTransform.value.assoc;\n      combine = (left, right) => {\n        return this.expandOperator(opStx, operatorTransform, [left, right]);\n      };\n    } else {\n      prec = getOperatorPrec(opStx.value.val());\n      assoc = getOperatorAssoc(opStx.value.val());\n      combine = (left, right) =>\n        new T.BinaryExpression({\n          left,\n          right,\n          operator: opStx.value.val(),\n        });\n    }\n\n    if (operatorLt(this.opCtx.prec, prec, assoc)) {\n      this.opCtx.stack = this.opCtx.stack.push({\n        prec: this.opCtx.prec,\n        combine: this.opCtx.combine,\n      });\n      this.opCtx.prec = prec;\n      this.opCtx.combine = rightTerm => {\n        return combine(leftTerm, rightTerm);\n      };\n      this.advance();\n      return EXPR_LOOP_OPERATOR;\n    } else {\n      let term = this.opCtx.combine(leftTerm);\n      // this.rest does not change\n      let { prec, combine } = this.opCtx.stack.last();\n      this.opCtx.stack = this.opCtx.stack.pop();\n      this.opCtx.prec = prec;\n      this.opCtx.combine = combine;\n      return term;\n    }\n  }\n\n  enforestTemplateElements() {\n    let lookahead = this.matchTemplate();\n    let elements = lookahead.token.items.map(it => {\n      if (this.isDelimiter(it)) {\n        let enf = new Enforester(\n          it.inner.slice(1, it.inner.size - 1),\n          List(),\n          this.context,\n        );\n        return enf.enforest('expression');\n      }\n      return new T.TemplateElement({\n        rawValue: it.value.token.slice.text,\n      });\n    });\n    return elements;\n  }\n\n  expandMacro() {\n    let lookahead = this.peek();\n    while (this.isCompiletimeTransform(lookahead)) {\n      let name = this.matchRawSyntax();\n\n      let syntaxTransform = this.getFromCompiletimeEnvironment(name);\n      if (syntaxTransform == null) {\n        throw this.createError(\n          name,\n          `The macro ${name.resolve(this.context.phase)} does not have a bound value`,\n        );\n      } else if (typeof syntaxTransform.value.f !== 'function') {\n        throw this.createError(\n          name,\n          `The macro ${name.resolve(this.context.phase)} was not bound to a callable value: ${syntaxTransform.value.f}`,\n        );\n      }\n      let useSiteScope = freshScope('u');\n      let introducedScope = freshScope('i');\n      // TODO: needs to be a list of scopes I think\n      this.context.useScope = useSiteScope;\n\n      let ctx = new MacroContext(\n        this,\n        name,\n        this.context,\n        useSiteScope,\n        introducedScope,\n      );\n\n      let result = sanitizeReplacementValues(\n        syntaxTransform.value.f.call(null, ctx),\n      );\n      if (!List.isList(result)) {\n        throw this.createError(\n          name,\n          'macro must return a list but got: ' + result,\n        );\n      }\n      let scopeReducer = new ScopeReducer(\n        [{ scope: introducedScope, phase: ALL_PHASES, flip: true }],\n        this.context.bindings,\n        true,\n      );\n      result = result.map(terms => {\n        if (terms instanceof Syntax) {\n          return new T.RawSyntax({\n            value: terms,\n          }).reduce(scopeReducer);\n        } else if (!(terms instanceof Term)) {\n          throw this.createError(\n            name,\n            'macro must return syntax objects or terms but got: ' + terms,\n          );\n        }\n        return terms.reduce(scopeReducer);\n      });\n\n      this.rest = result.concat(ctx._rest(this));\n      lookahead = this.peek();\n    }\n  }\n\n  expandOperator(name: Term, operatorTransform: any, args: Array<Term>) {\n    let useSiteScope = freshScope('u');\n    let introducedScope = freshScope('i');\n    // TODO: needs to be a list of scopes I think\n    this.context.useScope = useSiteScope;\n    args = args.map(arg => {\n      return arg.reduce(\n        new ScopeReducer(\n          [\n            { scope: useSiteScope, phase: ALL_PHASES, flip: false },\n            { scope: introducedScope, phase: ALL_PHASES, flip: true },\n          ],\n          this.context.bindings,\n        ),\n      );\n    });\n    let result = sanitizeReplacementValues(\n      operatorTransform.value.f.apply(null, args),\n    );\n    let scopeReducer = new ScopeReducer(\n      [{ scope: introducedScope, phase: ALL_PHASES, flip: true }],\n      this.context.bindings,\n      true,\n    );\n    result = result.map(terms => {\n      if (terms instanceof Syntax) {\n        return new T.RawSyntax({\n          value: terms,\n        }).reduce(scopeReducer);\n      } else if (!(terms instanceof Term)) {\n        throw this.createError(\n          name,\n          'macro must return syntax objects or terms but got: ' + terms,\n        );\n      }\n      return terms.reduce(scopeReducer);\n    });\n    let enf = new Enforester(result, List(), this.context);\n    return enf.enforestExpressionLoop();\n  }\n\n  consumeSemicolon() {\n    let lookahead = this.peek();\n\n    if (lookahead && this.isPunctuator(lookahead, ';')) {\n      this.advance();\n    }\n  }\n\n  consumeComma() {\n    let lookahead = this.peek();\n\n    if (lookahead && this.isPunctuator(lookahead, ',')) {\n      this.advance();\n    }\n  }\n\n  safeCheck(obj: Syntax | Term, type: any, val: ?string = null) {\n    if (obj instanceof Term) {\n      if (obj instanceof T.RawSyntax) {\n        return (\n          obj.value &&\n          (typeof obj.value.match === 'function'\n            ? obj.value.match(type, val)\n            : false)\n        );\n      } else if (obj instanceof T.RawDelimiter) {\n        return type === 'delimiter' || obj.kind === type;\n      }\n    }\n    return (\n      obj && (typeof obj.match === 'function' ? obj.match(type, val) : false)\n    );\n  }\n\n  isTerm(term: any) {\n    return term && term instanceof Term;\n  }\n\n  isEOF(obj: Syntax | Term) {\n    return this.safeCheck(obj, 'eof');\n  }\n\n  isIdentifier(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'identifier', val);\n  }\n\n  isPropertyName(obj: Syntax | Term) {\n    return (\n      this.isIdentifier(obj) ||\n      this.isKeyword(obj) ||\n      this.isNumericLiteral(obj) ||\n      this.isStringLiteral(obj) ||\n      this.isBrackets(obj)\n    );\n  }\n\n  isNumericLiteral(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'number', val);\n  }\n\n  isStringLiteral(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'string', val);\n  }\n\n  isTemplate(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'template', val);\n  }\n\n  isSyntaxTemplate(obj: Syntax | Term) {\n    return this.safeCheck(obj, 'syntaxTemplate');\n  }\n\n  isBooleanLiteral(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'boolean', val);\n  }\n\n  isNullLiteral(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'null', val);\n  }\n\n  isRegularExpression(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'regularExpression', val);\n  }\n\n  isDelimiter(obj: Syntax | Term) {\n    return this.safeCheck(obj, 'delimiter');\n  }\n\n  isParens(obj: Syntax | Term) {\n    return this.safeCheck(obj, 'parens');\n  }\n\n  isBraces(obj: Syntax | Term) {\n    return this.safeCheck(obj, 'braces');\n  }\n\n  isBrackets(obj: Syntax | Term) {\n    return this.safeCheck(obj, 'brackets');\n  }\n\n  isAssign(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'assign', val);\n  }\n\n  isKeyword(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'keyword', val);\n  }\n\n  isPunctuator(obj: Syntax | Term, val: ?string = null) {\n    return this.safeCheck(obj, 'punctuator', val);\n  }\n\n  isOperator(obj: Syntax | Term) {\n    return (\n      (this.safeCheck(obj, 'punctuator') ||\n        this.safeCheck(obj, 'identifier') ||\n        this.safeCheck(obj, 'keyword')) &&\n      ((obj instanceof T.RawSyntax && isOperator(obj.value)) ||\n        (obj instanceof Syntax && isOperator(obj)))\n    );\n  }\n\n  isCustomPrefixOperator(obj: Term) {\n    if (this.isCompiletimeTransform(obj)) {\n      let t = this.getFromCompiletimeEnvironment(obj.value);\n      return t && t.value.assoc === 'prefix';\n    }\n    return false;\n  }\n\n  isCustomPostfixOperator(obj: Term) {\n    if (this.isCompiletimeTransform(obj)) {\n      let t = this.getFromCompiletimeEnvironment(obj.value);\n      return t && t.value.assoc === 'postfix';\n    }\n    return false;\n  }\n\n  isCustomBinaryOperator(obj: Term) {\n    if (this.isCompiletimeTransform(obj)) {\n      let t = this.getFromCompiletimeEnvironment(obj.value);\n      return t && (t.value.assoc === 'left' || t.value.assoc === 'right');\n    }\n    return false;\n  }\n\n  isUpdateOperator(obj: Syntax | Term) {\n    return (\n      this.safeCheck(obj, 'punctuator', '++') ||\n      this.safeCheck(obj, 'punctuator', '--')\n    );\n  }\n\n  safeResolve(obj: Syntax | Term, phase: number | {}) {\n    if (obj instanceof T.RawSyntax) {\n      return typeof obj.value.resolve === 'function'\n        ? Just(obj.value.resolve(phase))\n        : Nothing();\n    } else if (obj instanceof Syntax) {\n      return typeof obj.resolve === 'function'\n        ? Just(obj.resolve(phase))\n        : Nothing();\n    }\n    return Nothing();\n  }\n\n  isTransform(obj: Syntax | Term, trans: any) {\n    return this.safeResolve(obj, this.context.phase)\n      .map(\n        name =>\n          this.context.env.get(name) === trans ||\n          this.context.store.get(name) === trans,\n      )\n      .getOrElse(false);\n  }\n\n  isTransformInstance(obj: Syntax | Term, trans: any) {\n    return this.safeResolve(obj, this.context.phase)\n      .map(\n        name =>\n          this.context.env.get(name) instanceof trans ||\n          this.context.store.get(name) instanceof trans,\n      )\n      .getOrElse(false);\n  }\n\n  isFnDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, FunctionDeclTransform);\n  }\n\n  isVarDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, VariableDeclTransform);\n  }\n\n  isLetDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, LetDeclTransform);\n  }\n\n  isConstDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ConstDeclTransform);\n  }\n\n  isSyntaxDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, SyntaxDeclTransform);\n  }\n\n  isSyntaxrecDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, SyntaxrecDeclTransform);\n  }\n\n  isReturnStmtTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ReturnStatementTransform);\n  }\n\n  isWhileTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, WhileTransform);\n  }\n\n  isForTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ForTransform);\n  }\n\n  isSwitchTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, SwitchTransform);\n  }\n\n  isBreakTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, BreakTransform);\n  }\n\n  isContinueTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ContinueTransform);\n  }\n\n  isDoTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, DoTransform);\n  }\n\n  isDebuggerTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, DebuggerTransform);\n  }\n\n  isWithTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, WithTransform);\n  }\n\n  isImportTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ImportTransform);\n  }\n\n  isExportTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ExportTransform);\n  }\n\n  isTryTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, TryTransform);\n  }\n\n  isThrowTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ThrowTransform);\n  }\n\n  isOperatorDeclTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, OperatorDeclTransform);\n  }\n\n  isIfTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, IfTransform);\n  }\n\n  isNewTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, NewTransform);\n  }\n\n  isSuperTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, SuperTransform);\n  }\n\n  isThisTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ThisTransform);\n  }\n\n  isClassTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, ClassTransform);\n  }\n\n  isYieldTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, YieldTransform);\n  }\n\n  isDefaultTransform(obj: Syntax | Term) {\n    return this.isTransform(obj, DefaultTransform);\n  }\n\n  isCompiletimeTransform(obj: Syntax | Term) {\n    return this.isTransformInstance(obj, CompiletimeTransform);\n  }\n\n  isModuleNamespaceTransform(obj: Term) {\n    return this.isTransformInstance(obj, ModuleNamespaceTransform);\n  }\n\n  isVarBindingTransform(obj: Syntax | Term) {\n    return this.isTransformInstance(obj, VarBindingTransform);\n  }\n\n  getFromCompiletimeEnvironment(term: Syntax) {\n    if (this.context.env.has(term.resolve(this.context.phase))) {\n      return this.context.env.get(term.resolve(this.context.phase));\n    }\n    return this.context.store.get(term.resolve(this.context.phase));\n  }\n\n  lineNumberEq(a: ?(T.Term | Syntax), b: ?(Syntax | T.Term)) {\n    if (!(a && b)) {\n      return false;\n    }\n    return getLineNumber(a) === getLineNumber(b);\n  }\n\n  matchRawDelimiter(): List<T.SyntaxTerm> {\n    let lookahead = this.advance();\n    if (lookahead instanceof T.RawDelimiter) {\n      return lookahead.inner;\n    }\n    throw this.createError(lookahead, 'expecting a RawDelimiter');\n  }\n\n  matchRawSyntax(): Syntax {\n    let lookahead = this.advance();\n    if (lookahead instanceof T.RawSyntax) {\n      return lookahead.value;\n    }\n    throw this.createError(lookahead, 'expecting a RawSyntax');\n  }\n\n  matchIdentifier(val?: string) {\n    let lookahead = this.peek();\n    if (this.isIdentifier(lookahead, val)) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting an identifier');\n  }\n\n  matchKeyword(val: string) {\n    let lookahead = this.peek();\n    if (this.isKeyword(lookahead, val)) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting ' + val);\n  }\n\n  matchLiteral() {\n    let lookahead = this.peek();\n    if (\n      this.isNumericLiteral(lookahead) ||\n      this.isStringLiteral(lookahead) ||\n      this.isBooleanLiteral(lookahead) ||\n      this.isNullLiteral(lookahead) ||\n      this.isTemplate(lookahead) ||\n      this.isRegularExpression(lookahead)\n    ) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting a literal');\n  }\n\n  matchStringLiteral() {\n    let lookahead = this.peek();\n    if (this.isStringLiteral(lookahead)) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting a string literal');\n  }\n\n  matchTemplate() {\n    let lookahead = this.peek();\n    if (this.isTemplate(lookahead)) {\n      return this.matchRawSyntax();\n    }\n    throw this.createError(lookahead, 'expecting a template literal');\n  }\n\n  matchParens(): List<T.SyntaxTerm> {\n    let lookahead = this.peek();\n    if (this.isParens(lookahead)) {\n      let inner = this.matchRawDelimiter();\n      return inner.slice(1, inner.size - 1);\n    }\n    throw this.createError(lookahead, 'expecting parens');\n  }\n\n  matchCurlies() {\n    let lookahead = this.peek();\n    if (this.isBraces(lookahead)) {\n      let inner = this.matchRawDelimiter();\n      return inner.slice(1, inner.size - 1);\n    }\n    throw this.createError(lookahead, 'expecting curly braces');\n  }\n\n  matchSquares(): List<T.SyntaxTerm> {\n    let lookahead = this.peek();\n    if (this.isBrackets(lookahead)) {\n      let inner = this.matchRawDelimiter();\n      return inner.slice(1, inner.size - 1);\n    }\n    throw this.createError(lookahead, 'expecting square braces');\n  }\n\n  matchUnaryOperator() {\n    let lookahead = this.matchRawSyntax();\n    if (isUnaryOperator(lookahead)) {\n      return lookahead;\n    }\n    throw this.createError(lookahead, 'expecting a unary operator');\n  }\n\n  matchPunctuator(val: string) {\n    let lookahead = this.matchRawSyntax();\n    if (this.isPunctuator(lookahead)) {\n      if (typeof val !== 'undefined') {\n        if (lookahead.val() === val) {\n          return lookahead;\n        } else {\n          throw this.createError(\n            lookahead,\n            'expecting a ' + val + ' punctuator',\n          );\n        }\n      }\n      return lookahead;\n    }\n    throw this.createError(lookahead, 'expecting a punctuator');\n  }\n\n  createError(stx: Syntax | Term, message: string) {\n    let ctx = '';\n    let offending = stx;\n    if (this.rest.size > 0) {\n      ctx = this.rest\n        .slice(0, 20)\n        .map(term => {\n          if (term instanceof T.RawDelimiter) {\n            return term.inner;\n          }\n          return List.of(term);\n        })\n        .flatten()\n        .map(s => {\n          let sval = s instanceof T.RawSyntax ? s.value.val() : s.toString();\n          if (s === offending) {\n            return '__' + sval + '__';\n          }\n          return sval;\n        })\n        .join(' ');\n    } else {\n      ctx = offending.toString();\n    }\n    return new Error(message + '\\n' + ctx);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/env.js":"import {\n  FunctionDeclTransform,\n  VariableDeclTransform,\n  LetDeclTransform,\n  ConstDeclTransform,\n  SyntaxDeclTransform,\n  SyntaxrecDeclTransform,\n  OperatorDeclTransform,\n  ReturnStatementTransform,\n  IfTransform,\n  ForTransform,\n  SwitchTransform,\n  BreakTransform,\n  ContinueTransform,\n  DoTransform,\n  DebuggerTransform,\n  WithTransform,\n  ImportTransform,\n  ExportTransform,\n  SuperTransform,\n  ThisTransform,\n  YieldTransform,\n  ClassTransform,\n  DefaultTransform,\n  TryTransform,\n  ThrowTransform,\n  NewTransform,\n  WhileTransform,\n} from './transforms';\n\nexport default class Env {\n  constructor() {\n    this.map = new Map();\n    this.map.set('function', FunctionDeclTransform);\n    this.map.set('var', VariableDeclTransform);\n    this.map.set('let', LetDeclTransform);\n    this.map.set('const', ConstDeclTransform);\n    this.map.set('syntaxrec', SyntaxrecDeclTransform);\n    this.map.set('syntax', SyntaxDeclTransform);\n    this.map.set('operator', OperatorDeclTransform);\n    this.map.set('return', ReturnStatementTransform);\n    this.map.set('while', WhileTransform);\n    this.map.set('if', IfTransform);\n    this.map.set('for', ForTransform);\n    this.map.set('switch', SwitchTransform);\n    this.map.set('break', BreakTransform);\n    this.map.set('continue', ContinueTransform);\n    this.map.set('do', DoTransform);\n    this.map.set('debugger', DebuggerTransform);\n    this.map.set('with', WithTransform);\n    this.map.set('import', ImportTransform);\n    this.map.set('export', ExportTransform);\n    this.map.set('super', SuperTransform);\n    this.map.set('this', ThisTransform);\n    this.map.set('class', ClassTransform);\n    this.map.set('default', DefaultTransform);\n    this.map.set('try', TryTransform);\n    this.map.set('yield', YieldTransform);\n    this.map.set('throw', ThrowTransform);\n    this.map.set('new', NewTransform);\n  }\n\n  has(key) {\n    return this.map.has(key);\n  }\n\n  get(key) {\n    return this.map.get(key);\n  }\n\n  set(key, val) {\n    return this.map.set(key, val);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/errors.js":"export function expect(cond, message, offendingSyntax, rest) {\n  if (!cond) {\n    let ctx = '';\n    if (rest) {\n      ctx = rest\n        .slice(0, 20)\n        .map(s => {\n          let val = s.isDelimiter() ? '( ... )' : s.val();\n          if (s === offendingSyntax) {\n            return '__' + val + '__';\n          }\n          return val;\n        })\n        .join(' ');\n    }\n    throw new Error('[error]: ' + message + '\\n' + ctx);\n  }\n}\n\nexport function assert(cond, message) {\n  if (!cond) {\n    throw new Error('[assertion error]: ' + message);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/hygiene-utils.js":"import { List } from 'immutable';\n\nimport ASTDispatcher from './ast-dispatcher';\n\nexport class CollectBindingSyntax extends ASTDispatcher {\n  constructor() {\n    super('collect', true);\n    this.names = List();\n  }\n\n  // registerSyntax(stx) {\n  //   let newBinding = gensym(stx.val());\n  //   this.context.bindings.add(stx, {\n  //     binding: newBinding,\n  //     phase: this.context.phase,\n  //     // skip dup because js allows variable redeclarations\n  //     // (technically only for `var` but we can let later stages of the pipeline\n  //     // handle incorrect redeclarations of `const` and `let`)\n  //     skipDup: true\n  //   });\n  //   return stx;\n  // }\n\n  collect(term) {\n    return this.dispatch(term);\n  }\n\n  collectBindingIdentifier(term) {\n    return this.names.concat(term.name);\n  }\n\n  collectBindingPropertyIdentifier(term) {\n    return this.collect(term.binding);\n  }\n\n  collectBindingPropertyProperty(term) {\n    return this.collect(term.binding);\n  }\n\n  collectArrayBinding(term) {\n    let restElement = null;\n    if (term.restElement != null) {\n      restElement = this.collect(term.restElement);\n    }\n    return this.names\n      .concat(restElement)\n      .concat(\n        term.elements.filter(el => el != null).flatMap(el => this.collect(el)),\n      );\n  }\n\n  collectObjectBinding() {\n    // return term.properties.flatMap(prop => this.collect(prop));\n    return List();\n  }\n\n  // registerVariableDeclaration(term) {\n  //   let declarators = term.declarators.map(decl => {\n  //     return decl.extend({\n  //       binding: this.register(decl.binding)\n  //     });\n  //   });\n  //   return term.extend({ declarators });\n  // }\n  //\n  // registerFunctionDeclaration(term) {\n  //   return term.extend({\n  //     name: this.register(term.name)\n  //   });\n  // }\n  //\n  // registerExport(term) {\n  //   return term.extend({\n  //     declaration: this.register(term.declaration)\n  //   });\n  // }\n}\n\nexport function collectBindings(term) {\n  return new CollectBindingSyntax().collect(term);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/load-syntax.js":"import * as S from 'sweet-spec';\nimport * as _ from 'ramda';\nimport { List } from 'immutable';\nimport Syntax from './syntax';\nimport codegen, { FormattedCodeGen } from 'shift-codegen';\nimport SweetToShiftReducer from './sweet-to-shift-reducer';\nimport TermExpander from './term-expander';\nimport Env from './env';\n\nimport { replaceTemplate } from './template-processor';\n\nexport function expandCompiletime(term, context) {\n  // each compiletime value needs to be expanded with a fresh\n  // environment and in the next higher phase\n  let syntaxExpander = new TermExpander(\n    _.merge(context, {\n      phase: context.phase + 1,\n      env: new Env(),\n      store: context.store,\n    }),\n  );\n\n  return syntaxExpander.expand(term);\n}\n\nexport function sanitizeReplacementValues(values) {\n  if (Array.isArray(values)) {\n    return sanitizeReplacementValues(List(values));\n  } else if (List.isList(values)) {\n    return values.map(sanitizeReplacementValues);\n  } else if (values == null) {\n    throw new Error(\n      'replacement values for syntax template must not be null or undefined',\n    );\n  } else if (typeof values.next === 'function') {\n    return sanitizeReplacementValues(List(values));\n  }\n  return values;\n}\n\n// (Expression, Context) -> [function]\nexport function evalCompiletimeValue(expr: S.Expression, context: any) {\n  let sandbox = {\n    syntaxTemplate: function(ident, ...values) {\n      return replaceTemplate(\n        context.templateMap.get(ident),\n        sanitizeReplacementValues(values),\n      );\n    },\n  };\n\n  let sandboxKeys = List(Object.keys(sandbox));\n  let sandboxVals = sandboxKeys.map(k => sandbox[k]).toArray();\n\n  let parsed = new S.Module({\n    directives: List(),\n    items: List.of(\n      new S.ExpressionStatement({\n        expression: new S.FunctionExpression({\n          isGenerator: false,\n          name: null,\n          params: new S.FormalParameters({\n            items: sandboxKeys.map(param => {\n              return new S.BindingIdentifier({\n                name: Syntax.from('identifier', param),\n              });\n            }),\n            rest: null,\n          }),\n          body: new S.FunctionBody({\n            directives: List.of(\n              new S.Directive({\n                rawValue: 'use strict',\n              }),\n            ),\n            statements: List.of(\n              new S.ReturnStatement({\n                expression: expr,\n              }),\n            ),\n          }),\n        }),\n      }),\n    ),\n  }).reduce(new SweetToShiftReducer(context.phase));\n\n  let gen = codegen(parsed, new FormattedCodeGen());\n  let result = context.transform(gen);\n\n  let val = context.loader.eval(result.code, context.store);\n  return val.apply(undefined, sandboxVals);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/macro-context.js":"import { expect } from './errors';\nimport { List } from 'immutable';\nimport { Enforester } from './enforester';\nimport { ALL_PHASES } from './syntax';\nimport * as _ from 'ramda';\nimport ScopeReducer from './scope-reducer';\nimport * as T from 'sweet-spec';\nimport Term, * as S from 'sweet-spec';\nimport Syntax from './syntax';\nimport { isTemplate, isDelimiter, getKind } from './tokens';\nimport type { TokenTree } from './tokens';\n\nexport function wrapInTerms(stx: List<TokenTree>): List<Term> {\n  return stx.map(s => {\n    if (isTemplate(s)) {\n      if (s.items) {\n        s.items = wrapInTerms(s.items);\n        return new T.RawSyntax({\n          value: new Syntax(s),\n        });\n      }\n      return new T.RawSyntax({\n        value: new Syntax(s),\n      });\n    } else if (isDelimiter(s)) {\n      return new S.RawDelimiter({\n        kind: getKind(s),\n        inner: wrapInTerms(s),\n      });\n    }\n    return new S.RawSyntax({\n      value: new Syntax(s),\n    });\n  });\n}\n\nconst privateData = new WeakMap();\n\nfunction cloneEnforester(enf) {\n  const { rest, prev, context } = enf;\n  return new Enforester(rest, prev, context);\n}\n\nfunction Marker() {}\n\n/*\nctx :: {\n  of: (Syntax) -> ctx\n  next: (String) -> Syntax or Term\n}\n*/\nexport default class MacroContext {\n  constructor(enf, name, context, useScope, introducedScope) {\n    const startMarker = new Marker();\n    const startEnf = cloneEnforester(enf);\n    const priv = {\n      name,\n      context,\n      enf: startEnf,\n      startMarker,\n      markers: new Map([[startMarker, enf]]),\n    };\n\n    if (useScope && introducedScope) {\n      priv.noScopes = false;\n      priv.useScope = useScope;\n      priv.introducedScope = introducedScope;\n    } else {\n      priv.noScopes = true;\n    }\n    privateData.set(this, priv);\n    this.reset(); // set current enforester\n\n    this[Symbol.iterator] = () => this;\n  }\n\n  name() {\n    const { name } = privateData.get(this);\n    return new T.RawSyntax({ value: name });\n  }\n\n  contextify(delim: any) {\n    if (!(delim instanceof T.RawDelimiter)) {\n      throw new Error(`Can only contextify a delimiter but got ${delim}`);\n    }\n    const { context } = privateData.get(this);\n\n    let enf = new Enforester(\n      delim.inner.slice(1, delim.inner.size - 1),\n      List(),\n      context,\n    );\n    return new MacroContext(enf, 'inner', context);\n  }\n\n  expand(type) {\n    const { enf } = privateData.get(this);\n    if (enf.rest.size === 0) {\n      return {\n        done: true,\n        value: null,\n      };\n    }\n    enf.expandMacro();\n    let originalRest = enf.rest;\n    let value;\n    switch (type) {\n      case 'AssignmentExpression':\n      case 'expr':\n        value = enf.enforestExpressionLoop();\n        break;\n      case 'Expression':\n        value = enf.enforestExpression();\n        break;\n      case 'Statement':\n      case 'stmt':\n        value = enf.enforestStatement();\n        break;\n      case 'BlockStatement':\n      case 'WhileStatement':\n      case 'IfStatement':\n      case 'ForStatement':\n      case 'SwitchStatement':\n      case 'BreakStatement':\n      case 'ContinueStatement':\n      case 'DebuggerStatement':\n      case 'WithStatement':\n      case 'TryStatement':\n      case 'ThrowStatement':\n      case 'ClassDeclaration':\n      case 'FunctionDeclaration':\n      case 'LabeledStatement':\n      case 'VariableDeclarationStatement':\n      case 'ReturnStatement':\n      case 'ExpressionStatement':\n        value = enf.enforestStatement();\n        expect(\n          _.whereEq({ type }, value),\n          `Expecting a ${type}`,\n          value,\n          originalRest,\n        );\n        break;\n      case 'YieldExpression':\n        value = enf.enforestYieldExpression();\n        break;\n      case 'ClassExpression':\n        value = enf.enforestClass({ isExpr: true });\n        break;\n      case 'ArrowExpression':\n        value = enf.enforestArrowExpression();\n        break;\n      case 'NewExpression':\n        value = enf.enforestNewExpression();\n        break;\n      case 'ThisExpression':\n      case 'FunctionExpression':\n      case 'IdentifierExpression':\n      case 'LiteralNumericExpression':\n      case 'LiteralInfinityExpression':\n      case 'LiteralStringExpression':\n      case 'TemplateExpression':\n      case 'LiteralBooleanExpression':\n      case 'LiteralNullExpression':\n      case 'LiteralRegExpExpression':\n      case 'ObjectExpression':\n      case 'ArrayExpression':\n        value = enf.enforestPrimaryExpression();\n        break;\n      case 'UnaryExpression':\n      case 'UpdateExpression':\n      case 'BinaryExpression':\n      case 'StaticMemberExpression':\n      case 'ComputedMemberExpression':\n      case 'CompoundAssignmentExpression':\n      case 'ConditionalExpression':\n        value = enf.enforestExpressionLoop();\n        expect(\n          _.whereEq({ type }, value),\n          `Expecting a ${type}`,\n          value,\n          originalRest,\n        );\n        break;\n      default:\n        throw new Error('Unknown term type: ' + type);\n    }\n    return {\n      done: false,\n      value: value,\n    };\n  }\n\n  _rest(enf) {\n    const priv = privateData.get(this);\n    if (priv.markers.get(priv.startMarker) === enf) {\n      return priv.enf.rest;\n    }\n    throw Error('Unauthorized access!');\n  }\n\n  reset(marker) {\n    const priv = privateData.get(this);\n    let enf;\n    if (marker == null) {\n      // go to the beginning\n      enf = priv.markers.get(priv.startMarker);\n    } else if (marker && marker instanceof Marker) {\n      // marker could be from another context\n      if (priv.markers.has(marker)) {\n        enf = priv.markers.get(marker);\n      } else {\n        throw new Error('marker must originate from this context');\n      }\n    } else {\n      throw new Error('marker must be an instance of Marker');\n    }\n    priv.enf = cloneEnforester(enf);\n  }\n\n  mark() {\n    const priv = privateData.get(this);\n    let marker;\n\n    // the idea here is that marking at the beginning shouldn't happen more than once.\n    // We can reuse startMarker.\n    if (priv.enf.rest === priv.markers.get(priv.startMarker).rest) {\n      marker = priv.startMarker;\n    } else if (priv.enf.rest.isEmpty()) {\n      // same reason as above\n      if (!priv.endMarker) priv.endMarker = new Marker();\n      marker = priv.endMarker;\n    } else {\n      //TODO(optimization/dubious): check that there isn't already a marker for this index?\n      marker = new Marker();\n    }\n    if (!priv.markers.has(marker)) {\n      priv.markers.set(marker, cloneEnforester(priv.enf));\n    }\n    return marker;\n  }\n\n  next() {\n    const {\n      enf,\n      noScopes,\n      useScope,\n      introducedScope,\n      context,\n    } = privateData.get(this);\n    if (enf.rest.size === 0) {\n      return {\n        done: true,\n        value: null,\n      };\n    }\n    let value = enf.advance();\n    if (!noScopes) {\n      value = value.reduce(\n        new ScopeReducer(\n          [\n            { scope: useScope, phase: ALL_PHASES, flip: false },\n            { scope: introducedScope, phase: ALL_PHASES, flip: true },\n          ],\n          context.bindings,\n        ),\n      );\n    }\n    return {\n      done: false,\n      value: value,\n    };\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/module-visitor.js":"// @flow\nimport { evalCompiletimeValue } from './load-syntax';\nimport * as _ from 'ramda';\nimport * as T from 'sweet-spec';\nimport * as S from './sweet-spec-utils';\nimport { gensym } from './symbol';\nimport { ModuleNamespaceTransform, CompiletimeTransform } from './transforms';\nimport { collectBindings } from './hygiene-utils';\nimport SweetModule from './sweet-module';\nimport { List } from 'immutable';\nimport SweetToShiftReducer from './sweet-to-shift-reducer';\nimport codegen, { FormattedCodeGen } from 'shift-codegen';\n\nimport type { Context } from './sweet-loader';\n\nexport function bindImports(\n  impTerm: T.ImportDeclaration,\n  exModule: SweetModule,\n  phase: any,\n  context: Context,\n) {\n  let names = [];\n  let phaseToBind = impTerm.forSyntax ? phase + 1 : phase;\n  if (impTerm.defaultBinding != null) {\n    let exportName = exModule.exportedNames.find(\n      exName => exName.exportedName.val() === '_default',\n    );\n    let name = impTerm.defaultBinding.name;\n    if (exportName != null) {\n      let newBinding = gensym('_default');\n      let toForward = exportName.exportedName;\n      context.bindings.addForward(name, toForward, newBinding, phaseToBind);\n      names.push(name);\n    }\n  }\n  if (impTerm.namedImports) {\n    impTerm.namedImports.forEach(specifier => {\n      let name = specifier.binding.name;\n      let exportName = exModule.exportedNames.find(\n        exName => exName.exportedName.val() === name.val(),\n      );\n      if (exportName != null) {\n        let newBinding = gensym(name.val());\n        let toForward = exportName.name\n          ? exportName.name\n          : exportName.exportedName;\n        context.bindings.addForward(name, toForward, newBinding, phaseToBind);\n        names.push(name);\n      }\n    });\n  }\n  if (impTerm.namespaceBinding) {\n    let name = impTerm.namespaceBinding.name;\n    let newBinding = gensym(name.val());\n    context.store.set(\n      newBinding.toString(),\n      new ModuleNamespaceTransform(name, exModule),\n    );\n    context.bindings.add(name, {\n      binding: newBinding,\n      phase: phaseToBind,\n      skipDup: false,\n    });\n\n    names.push(name);\n  }\n  return List(names);\n}\n\nexport default class {\n  context: Context;\n\n  constructor(context: Context) {\n    this.context = context;\n  }\n\n  visit(mod: SweetModule, phase: any, store: any) {\n    mod.imports.forEach(imp => {\n      if (imp.forSyntax) {\n        let mod = this.context.loader.get(\n          imp.moduleSpecifier.val(),\n          phase + 1,\n          '',\n        );\n        this.visit(mod, phase + 1, store);\n        this.invoke(mod, phase + 1, store);\n      } else {\n        let mod = this.context.loader.get(imp.moduleSpecifier.val(), phase, '');\n        this.visit(mod, phase, store);\n      }\n      bindImports(imp, mod, phase, this.context);\n    });\n    for (let term of mod.compiletimeItems()) {\n      if (S.isSyntaxDeclarationStatement(term)) {\n        this.registerSyntaxDeclaration(term.declaration, phase, store);\n      }\n    }\n    return store;\n  }\n\n  invoke(mod: any, phase: any, store: any) {\n    mod.imports.forEach(imp => {\n      if (!imp.forSyntax) {\n        let mod = this.context.loader.get(imp.moduleSpecifier.val(), phase, '');\n        this.invoke(mod, phase, store);\n        bindImports(imp, mod, phase, this.context);\n      }\n    });\n    let items = mod.runtimeItems();\n    for (let term of items) {\n      if (S.isVariableDeclarationStatement(term)) {\n        this.registerVariableDeclaration(term.declaration, phase, store);\n      } else if (S.isFunctionDeclaration(term)) {\n        this.registerFunctionOrClass(term, phase, store);\n      }\n    }\n    let parsed = new T.Module({\n      directives: List(),\n      items,\n    }).reduce(new SweetToShiftReducer(phase));\n\n    let gen = codegen(parsed, new FormattedCodeGen());\n    let result = this.context.transform(gen);\n\n    this.context.loader.eval(result.code, store);\n    return store;\n  }\n\n  registerSyntaxDeclaration(\n    term: T.VariableDeclarationStatement,\n    phase: any,\n    store: any,\n  ) {\n    term.declarators.forEach(decl => {\n      let val = evalCompiletimeValue(\n        decl.init,\n        _.merge(this.context, {\n          phase: phase + 1,\n          store,\n        }),\n      );\n\n      collectBindings(decl.binding).forEach(stx => {\n        if (phase !== 0) {\n          // phase 0 bindings extend the binding map during compilation\n          let newBinding = gensym(stx.val());\n          this.context.bindings.add(stx, {\n            binding: newBinding,\n            phase: phase,\n            skipDup: false,\n          });\n        }\n        let resolvedName = stx.resolve(phase);\n        store.set(\n          resolvedName,\n          new CompiletimeTransform({ type: 'syntax', f: val }),\n        );\n      });\n    });\n  }\n\n  registerVariableDeclaration(term: any, phase: any, store: any) {\n    term.declarators.forEach(decl => {\n      collectBindings(decl.binding).forEach(stx => {\n        if (phase !== 0) {\n          // phase 0 bindings extend the binding map during compilation\n          let newBinding = gensym(stx.val());\n          this.context.bindings.add(stx, {\n            binding: newBinding,\n            phase: phase,\n            skipDup: term.kind === 'var',\n          });\n        }\n      });\n    });\n  }\n\n  registerFunctionOrClass(term: any, phase: any, store: any) {\n    collectBindings(term.name).forEach(stx => {\n      if (phase !== 0) {\n        let newBinding = gensym(stx.val());\n        this.context.bindings.add(stx, {\n          binding: newBinding,\n          phase: phase,\n          skipDup: false,\n        });\n      }\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/node-loader.js":"// @flow\nimport SweetLoader, { phaseInModulePathRegexp } from './sweet-loader';\nimport { readFileSync } from 'fs';\nimport { dirname } from 'path';\nimport resolve from 'resolve';\nimport vm from 'vm';\nimport Store from './store';\nimport type { LoaderOptions } from './sweet-loader';\n\ntype NodeLoaderOptions = LoaderOptions & { extensions?: Array<string> };\n\nexport default class NodeLoader extends SweetLoader {\n  extensions: Array<string>;\n\n  constructor(baseDir: string, options: NodeLoaderOptions = {}) {\n    super(baseDir, options);\n    this.extensions = options.extensions || [];\n  }\n\n  normalize(name: string, refererName?: string, refererAddress?: string) {\n    let normName = super.normalize(name, refererName, refererAddress);\n    let match = normName.match(phaseInModulePathRegexp);\n    if (match && match.length >= 3) {\n      let resolvedName = resolve.sync(match[1], {\n        basedir: refererName ? dirname(refererName) : this.baseDir,\n        extensions: this.extensions ? this.extensions : ['.js'],\n      });\n      return `${resolvedName}:${match[2]}`;\n    }\n    throw new Error(`Module ${name} is missing phase information`);\n  }\n\n  fetch({\n    name,\n    address,\n    metadata,\n  }: { name: string, address: { path: string, phase: number }, metadata: {} }) {\n    let src = this.sourceCache.get(address.path);\n    if (src != null) {\n      return src;\n    } else {\n      src = readFileSync(address.path, 'utf8');\n      this.sourceCache.set(address.path, src);\n      return src;\n    }\n  }\n\n  freshStore() {\n    let sandbox = {\n      process: global.process,\n      console: global.console,\n    };\n    return new Store(vm.createContext(sandbox));\n  }\n\n  eval(source: string, store: Store) {\n    return vm.runInContext(source, store.getBackingObject());\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/node-module-loader.js":"import { readFileSync } from 'fs';\n\nexport default function moduleLoader(path) {\n  try {\n    return readFileSync(path, 'utf8');\n  } catch (e) {\n    return '';\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/node-module-resolver.js":"import resolve from 'resolve';\n\nexport default function resolveModule(path, cwd) {\n  return resolve.sync(path, { basedir: cwd });\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/operators.js":"const unaryOperators = {\n  '+': true,\n  '-': true,\n  '!': true,\n  '~': true,\n  '++': true,\n  '--': true,\n  typeof: true,\n  void: true,\n  delete: true,\n};\nconst binaryOperatorPrecedence = {\n  '*': 14,\n  '/': 14,\n  '%': 14,\n  '+': 13,\n  '-': 13,\n  '>>': 12,\n  '<<': 12,\n  '>>>': 12,\n  '<': 11,\n  '<=': 11,\n  '>': 11,\n  '>=': 11,\n  in: 11,\n  instanceof: 11,\n  '==': 10,\n  '!=': 10,\n  '===': 10,\n  '!==': 10,\n  '&': 9,\n  '^': 8,\n  '|': 7,\n  '&&': 6,\n  '||': 5,\n};\n\nvar operatorAssoc = {\n  '*': 'left',\n  '/': 'left',\n  '%': 'left',\n  '+': 'left',\n  '-': 'left',\n  '>>': 'left',\n  '<<': 'left',\n  '>>>': 'left',\n  '<': 'left',\n  '<=': 'left',\n  '>': 'left',\n  '>=': 'left',\n  in: 'left',\n  instanceof: 'left',\n  '==': 'left',\n  '!=': 'left',\n  '===': 'left',\n  '!==': 'left',\n  '&': 'left',\n  '^': 'left',\n  '|': 'left',\n  '&&': 'left',\n  '||': 'left',\n};\n\nexport function operatorLt(left, right, assoc) {\n  if (assoc === 'left') {\n    return left < right;\n  } else {\n    return left <= right;\n  }\n}\n\nexport function getOperatorPrec(op) {\n  return binaryOperatorPrecedence[op];\n}\nexport function getOperatorAssoc(op) {\n  return operatorAssoc[op];\n}\n\nexport function isUnaryOperator(op) {\n  return (\n    (op.match('punctuator') || op.match('identifier') || op.match('keyword')) &&\n    unaryOperators.hasOwnProperty(op.val())\n  );\n}\n\nexport function isOperator(op) {\n  if (op.match('punctuator') || op.match('identifier') || op.match('keyword')) {\n    return (\n      binaryOperatorPrecedence.hasOwnProperty(op) ||\n      unaryOperators.hasOwnProperty(op.val())\n    );\n  }\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/scope.js":"// @flow\nimport { Symbol } from './symbol';\n\nlet scopeIndex = 0;\n\nexport function freshScope(name: string = 'scope') {\n  scopeIndex++;\n  return Symbol(name + '_' + scopeIndex);\n}\n\nexport function Scope(name: string) {\n  return Symbol(name);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/scope-reducer.js":"// @flow\nimport Term, * as S from 'sweet-spec';\nimport type Syntax from './syntax';\nimport type { SymbolClass } from './symbol';\nimport type BindingMap from './binding-map';\n\nexport default class extends Term.CloneReducer {\n  scopes: Array<{ scope: SymbolClass, phase: number | {}, flip: boolean }>;\n  bindings: BindingMap;\n\n  constructor(\n    scopes: Array<{ scope: SymbolClass, phase: number | {}, flip: boolean }>,\n    bindings: BindingMap,\n  ) {\n    super();\n    this.scopes = scopes;\n    this.bindings = bindings;\n  }\n\n  applyScopes(s: Syntax) {\n    return this.scopes.reduce((acc, sc) => {\n      return acc.addScope(sc.scope, this.bindings, sc.phase, {\n        flip: sc.flip,\n      });\n    }, s);\n  }\n\n  reduceBindingIdentifier(t: Term, s: { name: Syntax }) {\n    return new S.BindingIdentifier({\n      name: this.applyScopes(s.name),\n    });\n  }\n\n  reduceIdentifierExpression(t: Term, s: { name: Syntax }) {\n    return new S.IdentifierExpression({\n      name: this.applyScopes(s.name),\n    });\n  }\n\n  reduceRawSyntax(t: Term, s: { value: Syntax }) {\n    // TODO: fix this once reading tokens is reasonable\n    if (s.value.isTemplate() && s.value.items) {\n      s.value.token.items = s.value.token.items.map(t => {\n        if (t instanceof Term) {\n          return t.reduce(this);\n        }\n        return t;\n      });\n    }\n    return new S.RawSyntax({\n      value: this.applyScopes(s.value),\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/store.js":"export default class Store extends Map {\n  constructor(backingObject) {\n    super();\n    this.backingObject = backingObject;\n  }\n\n  set(key, val) {\n    super.set(key, val);\n    this.backingObject[key] = val;\n  }\n\n  getBackingObject() {\n    return this.backingObject;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/store-loader.js":"// @flow\nimport SweetLoader from './sweet-loader';\nimport vm from 'vm';\nimport Store from './store';\n\nexport default class extends SweetLoader {\n  store: Map<string, string>;\n\n  constructor(\n    baseDir: string,\n    store: Map<string, string>,\n    noBabel: boolean = false,\n  ) {\n    super(baseDir, { noBabel });\n    this.store = store;\n  }\n\n  fetch({ name, address }: { name: string, address: any }) {\n    if (this.store.has(address.path)) {\n      return this.store.get(address.path);\n    }\n    throw new Error(\n      `The module ${name} is not in the debug store: addr.path is ${address.path}`,\n    );\n  }\n\n  freshStore() {\n    return new Store(vm.createContext());\n  }\n\n  eval(source: string, store: Store) {\n    return vm.runInContext(source, store.getBackingObject());\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/sweet-module.js":"// @flow\nimport * as T from 'sweet-spec';\nimport * as _ from 'ramda';\nimport * as S from './sweet-spec-utils';\nimport codegen from './codegen';\nimport { List } from 'immutable';\nimport SweetToShiftReducer from './sweet-to-shift-reducer.js';\nimport Syntax from './syntax';\n\nconst extractDeclaration = _.cond([\n  [S.isExport, _.prop('declaration')],\n  [S.isExportDefault, _.prop('body')],\n  [\n    _.T,\n    term => {\n      throw new Error(`Expecting an Export or ExportDefault but got ${term}`);\n    },\n  ],\n]);\n\nconst ExpSpec = x => ({ exportedName: x });\n\nconst extractDeclarationNames = _.cond([\n  [S.isVariableDeclarator, ({ binding }) => List.of(ExpSpec(binding.name))],\n  [\n    S.isVariableDeclaration,\n    ({ declarators }) => declarators.flatMap(extractDeclarationNames),\n  ],\n  [S.isFunctionDeclaration, ({ name }) => List.of(ExpSpec(name.name))],\n  [S.isClassDeclaration, ({ name }) => List.of(ExpSpec(name.name))],\n]);\n\ntype ExportSpecifier = {\n  name?: Syntax,\n  exportedName: Syntax,\n};\n\nfunction extractNames(term: T.ExportDeclaration): List<ExportSpecifier> {\n  if (S.isExport(term)) {\n    return extractDeclarationNames(term.declaration);\n  } else if (S.isExportDefault(term)) {\n    return List();\n  } else if (S.isExportFrom(term)) {\n    return term.namedExports;\n  }\n  throw new Error(`Unknown export type`);\n}\n\nfunction wrapStatement(declaration: T.Term) {\n  if (S.isVariableDeclaration(declaration)) {\n    return new T.VariableDeclarationStatement({ declaration });\n  }\n  return declaration;\n}\n\nconst memoSym = Symbol('memo');\n\nfunction makeVarDeclStmt(name: T.BindingIdentifier, expr: T.Expression) {\n  return new T.VariableDeclarationStatement({\n    declaration: new T.VariableDeclaration({\n      kind: 'var',\n      declarators: List.of(\n        new T.VariableDeclarator({\n          binding: name,\n          init: expr,\n        }),\n      ),\n    }),\n  });\n}\n\nexport default class SweetModule {\n  items: List<T.Term>;\n  imports: List<T.ImportDeclaration>;\n  exports: List<T.ExportDeclaration>;\n  exportedNames: List<ExportSpecifier>;\n\n  runtime: List<T.Term>;\n  compiletime: List<T.Term>;\n\n  constructor(items: List<T.Term>) {\n    let body = [];\n    let imports = [];\n    let exports = [];\n    this.exportedNames = List();\n    for (let item of items) {\n      if (S.isImportDeclaration(item)) {\n        imports.push(item);\n      } else if (S.isExportDeclaration(item)) {\n        exports.push(item);\n        this.exportedNames = this.exportedNames.concat(extractNames(item));\n        if (S.isExport(item)) {\n          body.push(wrapStatement(extractDeclaration(item)));\n        } else if (S.isExportDefault(item)) {\n          let decl = extractDeclaration(item);\n          let defStx = Syntax.fromIdentifier('_default');\n          let def = new T.BindingIdentifier({\n            name: defStx,\n          });\n          this.exportedNames = this.exportedNames.push(ExpSpec(defStx));\n          if (S.isFunctionDeclaration(decl) || S.isClassDeclaration(decl)) {\n            body.push(decl);\n            // extract name and bind it to _default\n            body.push(\n              makeVarDeclStmt(\n                def,\n                new T.IdentifierExpression({ name: decl.name.name }),\n              ),\n            );\n          } else {\n            // expression so bind it to _default\n            body.push(makeVarDeclStmt(def, decl));\n          }\n        }\n      } else {\n        body.push(item);\n      }\n    }\n    this.items = List(body);\n    this.imports = List(imports);\n    this.exports = List(exports);\n  }\n\n  // $FlowFixMe: flow doesn't support computed property keys yet\n  [memoSym]() {\n    let runtime = [], compiletime = [];\n    for (let item of this.items) {\n      if (S.isCompiletimeStatement(item)) {\n        compiletime.push(item);\n      } else {\n        runtime.push(item);\n      }\n    }\n    this.runtime = List(runtime);\n    this.compiletime = List(compiletime);\n  }\n\n  runtimeItems() {\n    if (this.runtime == null) {\n      // $FlowFixMe: flow doesn't support computed property keys yet\n      this[memoSym]();\n    }\n    return this.runtime;\n  }\n\n  compiletimeItems() {\n    if (this.compiletime == null) {\n      // $FlowFixMe: flow doesn't support computed property keys yet\n      this[memoSym]();\n    }\n    return this.compiletime;\n  }\n\n  parse() {\n    return new T.Module({\n      items: this.items,\n      directives: List(),\n    }).reduce(new SweetToShiftReducer(0));\n  }\n\n  codegen() {\n    return codegen(this.parse()).code;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/sweet-spec-utils.js":"// @flow\n\nimport * as T from 'sweet-spec';\nimport * as _ from 'ramda';\n\nexport const isImportDeclaration = _.is(T.ImportDeclaration);\n\nexport const isExportDeclaration = _.is(T.ExportDeclaration);\nexport const isExport = _.is(T.Export);\nexport const isExportDefault = _.is(T.ExportDefault);\nexport const isExportFrom = _.is(T.ExportFrom);\n\nexport const isVariableDeclaration = _.is(T.VariableDeclaration);\nexport const isVariableDeclarator = _.is(T.VariableDeclarator);\nexport const isSyntaxVariableDeclartion = _.both(\n  isVariableDeclaration,\n  _.either(_.propEq('kind', 'syntax'), _.propEq('kind', 'syntaxrec')),\n);\n\nexport const isVariableDeclarationStatement = _.is(\n  T.VariableDeclarationStatement,\n);\nexport const isSyntaxDeclarationStatement = (term: any) => {\n  // syntax m = ...\n  // syntaxrec m = ...\n  return (\n    isVariableDeclarationStatement(term) &&\n    isSyntaxVariableDeclartion(term.declaration)\n  );\n};\n\nexport const isCompiletimeStatement = isSyntaxDeclarationStatement;\n\nexport const isFunctionDeclaration = _.is(T.FunctionDeclaration);\nexport const isClassDeclaration = _.is(T.ClassDeclaration);\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/sweet-to-shift-reducer.js":"// @flow\nimport Term, * as S from 'sweet-spec';\nimport { complement } from 'ramda';\nimport { List } from 'immutable';\n\nimport { isEmptyStatement } from './terms';\n\nimport type Syntax from './syntax.js';\n\nconst notEmptyStatement = complement(isEmptyStatement);\n\nexport default class extends Term.CloneReducer {\n  phase: number;\n\n  constructor(phase: number) {\n    super();\n    this.phase = phase;\n  }\n\n  reduceModule(t: Term, s: { directives: List<any>, items: List<any> }) {\n    return new S.Module({\n      directives: s.directives.toArray(),\n      items: s.items.toArray().filter(notEmptyStatement),\n    });\n  }\n\n  reduceIdentifierExpression(t: Term, s: { name: Syntax }) {\n    return new S.IdentifierExpression({\n      name: s.name.resolve(this.phase),\n    });\n  }\n\n  reduceStaticPropertyName(t: Term, s: { value: Syntax }) {\n    return new S.StaticPropertyName({\n      value: s.value.val().toString(),\n    });\n  }\n\n  reduceBindingIdentifier(t: Term, s: { name: Syntax }) {\n    return new S.BindingIdentifier({\n      name: s.name.resolve(this.phase),\n    });\n  }\n\n  reduceStaticMemberExpression(t: Term, s: { object: any, property: Syntax }) {\n    return new S.StaticMemberExpression({\n      object: s.object,\n      property: s.property.val(),\n    });\n  }\n\n  reduceFunctionBody(\n    t: Term,\n    s: { statements: List<any>, directives: List<any> },\n  ) {\n    return new S.FunctionBody({\n      directives: s.directives.toArray(),\n      statements: s.statements.toArray().filter(notEmptyStatement),\n    });\n  }\n\n  reduceVariableDeclarationStatement(t: Term, s: { declaration: any }) {\n    if (\n      t.declaration.kind === 'syntax' ||\n      t.declaration.kind === 'syntaxrec' ||\n      t.declaration.kind === 'operator'\n    ) {\n      return new S.EmptyStatement();\n    }\n    return new S.VariableDeclarationStatement({\n      declaration: s.declaration,\n    });\n  }\n\n  reduceVariableDeclaration(t: Term, s: { kind: any, declarators: List<any> }) {\n    return new S.VariableDeclaration({\n      kind: s.kind,\n      declarators: s.declarators.toArray(),\n    });\n  }\n\n  reduceCallExpression(t: Term, s: { callee: any, arguments: List<any> }) {\n    return new S.CallExpression({\n      callee: s.callee,\n      arguments: s.arguments.toArray(),\n    });\n  }\n\n  reduceArrayExpression(t: Term, s: { elements: List<any> }) {\n    return new S.ArrayExpression({\n      elements: s.elements.toArray(),\n    });\n  }\n\n  reduceImport() {\n    return new S.EmptyStatement({});\n  }\n\n  reduceBlock(t: Term, s: { statements: List<any> }) {\n    return new S.Block({\n      statements: s.statements.toArray().filter(notEmptyStatement),\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/symbol.js":"// @flow\nlet internedMap: Map<string, Symbol> = new Map();\n\nlet counter = 0;\n\nexport function gensym(name: string) {\n  let prefix = name == null ? 's_' : name + '_';\n  let sym = new Symbol(prefix + counter);\n  counter++;\n  return sym;\n}\n\nclass Symbol {\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n  toString() {\n    return this.name;\n  }\n}\n\nfunction makeSymbol(name: string): Symbol {\n  let s = internedMap.get(name);\n  if (s) {\n    return s;\n  } else {\n    let sym = new Symbol(name);\n    internedMap.set(name, sym);\n    return sym;\n  }\n}\n\nexport { makeSymbol as Symbol, Symbol as SymbolClass };\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/syntax.js":"// @flow\nimport { List, Map } from 'immutable';\nimport { assert } from './errors';\nimport BindingMap from './binding-map';\nimport { Maybe } from 'ramda-fantasy';\nimport * as _ from 'ramda';\nimport * as T from 'sweet-spec';\n\nimport { TokenType, TokenClass, TypeCodes } from './tokens';\n\ntype Token = {\n  type: any,\n  value: any,\n  slice: any,\n};\n\ntype TokenTag =\n  | 'null'\n  | 'number'\n  | 'string'\n  | 'punctuator'\n  | 'keyword'\n  | 'identifier'\n  | 'regularExpression'\n  | 'boolean'\n  | 'braces'\n  | 'parens'\n  | 'delimiter'\n  | 'eof'\n  | 'template'\n  | 'assign'\n  | 'syntaxTemplate'\n  | 'brackets';\n\nfunction getFirstSlice(stx: ?Syntax) {\n  if (!stx || typeof stx.isDelimiter !== 'function') return null; // TODO: should not have to do this\n  if (!stx.isDelimiter()) {\n    return stx.token.slice;\n  }\n  return stx.token.get(0).token.slice;\n}\n\nfunction sizeDecending(a, b) {\n  if (a.scopes.size > b.scopes.size) {\n    return -1;\n  } else if (b.scopes.size > a.scopes.size) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\ntype TypesHelper = {\n  [key: TokenTag]: {\n    match(token: any): boolean,\n    create?: (value: any, stx: ?Syntax) => Syntax,\n  },\n};\n\nexport let Types: TypesHelper = {\n  null: {\n    match: token =>\n      !Types.delimiter.match(token) && token.type === TokenType.NULL,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: TokenType.NULL,\n          value: null,\n          typeCode: TypeCodes.Keyword,\n        },\n        stx,\n      ),\n  },\n  number: {\n    match: token =>\n      !Types.delimiter.match(token) &&\n      token.type.klass === TokenClass.NumericLiteral,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: TokenType.NUMBER,\n          value,\n          typeCode: TypeCodes.NumericLiteral,\n        },\n        stx,\n      ),\n  },\n  string: {\n    match: token =>\n      !Types.delimiter.match(token) &&\n      token.type.klass === TokenClass.StringLiteral,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: TokenType.STRING,\n          str: value,\n          typeCode: TypeCodes.StringLiteral,\n        },\n        stx,\n      ),\n  },\n  punctuator: {\n    match: token =>\n      !Types.delimiter.match(token) &&\n      token.type.klass === TokenClass.Punctuator,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: {\n            klass: TokenClass.Punctuator,\n            name: value,\n          },\n          typeCode: TypeCodes.Punctuator,\n          value,\n        },\n        stx,\n      ),\n  },\n  keyword: {\n    match: token =>\n      !Types.delimiter.match(token) && token.type.klass === TokenClass.Keyword,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: {\n            klass: TokenClass.Keyword,\n            name: value,\n          },\n          typeCode: TypeCodes.Keyword,\n          value,\n        },\n        stx,\n      ),\n  },\n  identifier: {\n    match: token =>\n      !Types.delimiter.match(token) && token.type.klass === TokenClass.Ident,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: TokenType.IDENTIFIER,\n          value,\n          typeCode: TypeCodes.Identifier,\n        },\n        stx,\n      ),\n  },\n  regularExpression: {\n    match: token =>\n      !Types.delimiter.match(token) &&\n      token.type.klass === TokenClass.RegularExpression,\n    create: (value, stx) =>\n      new Syntax(\n        {\n          type: TokenType.REGEXP,\n          value,\n          typeCode: TypeCodes.RegExp,\n        },\n        stx,\n      ),\n  },\n  braces: {\n    match: token =>\n      Types.delimiter.match(token) &&\n      token.get(0).token.type === TokenType.LBRACE,\n    create: (inner, stx) => {\n      let left = new T.RawSyntax({\n        value: new Syntax({\n          type: TokenType.LBRACE,\n          typeCode: TypeCodes.Punctuator,\n          value: '{',\n          slice: getFirstSlice(stx),\n        }),\n      });\n      let right = new T.RawSyntax({\n        value: new Syntax({\n          type: TokenType.RBRACE,\n          typeCode: TypeCodes.Punctuator,\n          value: '}',\n          slice: getFirstSlice(stx),\n        }),\n      });\n      return new T.RawDelimiter({\n        kind: 'braces',\n        inner: List.of(left).concat(inner).push(right),\n      });\n    },\n  },\n  brackets: {\n    match: token =>\n      Types.delimiter.match(token) &&\n      token.get(0).token.type === TokenType.LBRACK,\n    create: (inner, stx) => {\n      let left = new T.RawSyntax({\n        value: new Syntax({\n          type: TokenType.LBRACK,\n          typeCode: TypeCodes.Punctuator,\n          value: '[',\n          slice: getFirstSlice(stx),\n        }),\n      });\n      let right = new T.RawSyntax({\n        value: new Syntax({\n          type: TokenType.RBRACK,\n          typeCode: TypeCodes.Punctuator,\n          value: ']',\n          slice: getFirstSlice(stx),\n        }),\n      });\n      return new T.RawDelimiter({\n        kind: 'brackets',\n        inner: List.of(left).concat(inner).push(right),\n      });\n    },\n  },\n  parens: {\n    match: token =>\n      Types.delimiter.match(token) &&\n      token.get(0).token.type === TokenType.LPAREN,\n    create: (inner, stx) => {\n      let left = new T.RawSyntax({\n        value: new Syntax({\n          type: TokenType.LPAREN,\n          typeCode: TypeCodes.Punctuator,\n          value: '(',\n          slice: getFirstSlice(stx),\n        }),\n      });\n      let right = new T.RawSyntax({\n        value: new Syntax({\n          type: TokenType.RPAREN,\n          typeCode: TypeCodes.Punctuator,\n          value: ')',\n          slice: getFirstSlice(stx),\n        }),\n      });\n      return new T.RawDelimiter({\n        kind: 'parens',\n        inner: List.of(left).concat(inner).push(right),\n      });\n    },\n  },\n\n  assign: {\n    match: token => {\n      if (Types.punctuator.match(token)) {\n        switch (token.value) {\n          case '=':\n          case '|=':\n          case '^=':\n          case '&=':\n          case '<<=':\n          case '>>=':\n          case '>>>=':\n          case '+=':\n          case '-=':\n          case '*=':\n          case '/=':\n          case '%=':\n            return true;\n          default:\n            return false;\n        }\n      }\n      return false;\n    },\n  },\n\n  boolean: {\n    match: token =>\n      (!Types.delimiter.match(token) && token.type === TokenType.TRUE) ||\n      token.type === TokenType.FALSE,\n  },\n\n  template: {\n    match: token =>\n      !Types.delimiter.match(token) && token.type === TokenType.TEMPLATE,\n  },\n\n  delimiter: {\n    match: token => List.isList(token),\n  },\n\n  syntaxTemplate: {\n    match: token => Types.delimiter.match(token) && token.get(0).val() === '#`',\n  },\n\n  eof: {\n    match: token =>\n      !Types.delimiter.match(token) && token.type === TokenType.EOS,\n  },\n};\nexport const ALL_PHASES = {};\n\ntype Scopeset = {\n  all: List<any>,\n  phase: Map<number | {}, any>,\n};\n\nexport default class Syntax {\n  // token: Token | List<Token>;\n  token: any;\n  bindings: BindingMap;\n  scopesets: Scopeset;\n\n  constructor(token: any, oldstx: ?{ bindings: any, scopesets: any }) {\n    this.token = token;\n    this.bindings = oldstx && oldstx.bindings != null\n      ? oldstx.bindings\n      : new BindingMap();\n    this.scopesets = oldstx && oldstx.scopesets != null\n      ? oldstx.scopesets\n      : {\n          all: List(),\n          phase: Map(),\n        };\n    Object.freeze(this);\n  }\n\n  static of(token: Token, stx: ?Syntax) {\n    return new Syntax(token, stx);\n  }\n\n  static from(type, value, stx: ?Syntax) {\n    if (!Types[type]) {\n      throw new Error(type + ' is not a valid type');\n    } else if (!Types[type].create) {\n      throw new Error('Cannot create a syntax from type ' + type);\n    }\n    let newstx = Types[type].create(value, stx);\n    let slice = getFirstSlice(stx);\n    if (slice != null && newstx.token != null) {\n      newstx.token.slice = slice;\n    }\n    return newstx;\n  }\n\n  from(type: TokenTag, value: any) {\n    // TODO: this is gross, fix\n    let s = Syntax.from(type, value, this);\n    if (s instanceof Syntax) {\n      return new T.RawSyntax({ value: s });\n    }\n    return s;\n  }\n\n  fromNull() {\n    return this.from('null', null);\n  }\n\n  fromNumber(value: number) {\n    return this.from('number', value);\n  }\n\n  fromString(value: string) {\n    return this.from('string', value);\n  }\n\n  fromPunctuator(value: string) {\n    return this.from('punctuator', value);\n  }\n\n  fromKeyword(value: string) {\n    return this.from('keyword', value);\n  }\n\n  fromIdentifier(value: string) {\n    return this.from('identifier', value);\n  }\n\n  fromRegularExpression(value: any) {\n    return this.from('regularExpression', value);\n  }\n\n  static fromNull(stx: Syntax) {\n    return Syntax.from('null', null, stx);\n  }\n\n  static fromNumber(value, stx) {\n    return Syntax.from('number', value, stx);\n  }\n\n  static fromString(value, stx) {\n    return Syntax.from('string', value, stx);\n  }\n\n  static fromPunctuator(value, stx) {\n    return Syntax.from('punctuator', value, stx);\n  }\n\n  static fromKeyword(value, stx) {\n    return Syntax.from('keyword', value, stx);\n  }\n\n  static fromIdentifier(value, stx) {\n    return Syntax.from('identifier', value, stx);\n  }\n\n  static fromRegularExpression(value, stx) {\n    return Syntax.from('regularExpression', value, stx);\n  }\n\n  // () -> string\n  resolve(phase: any) {\n    assert(phase != null, 'must provide a phase to resolve');\n    let allScopes = this.scopesets.all;\n    let stxScopes = this.scopesets.phase.has(phase)\n      ? this.scopesets.phase.get(phase)\n      : List();\n    stxScopes = allScopes.concat(stxScopes);\n    if (\n      stxScopes.size === 0 ||\n      !(this.match('identifier') ||\n        this.match('keyword') ||\n        this.match('punctuator'))\n    ) {\n      return this.token.value;\n    }\n    let scope = stxScopes.last();\n    let bindings = this.bindings;\n    if (scope) {\n      // List<{ scopes: List<Scope>, binding: Symbol }>\n      let scopesetBindingList = bindings.get(this);\n\n      if (scopesetBindingList) {\n        // { scopes: List<Scope>, binding: Symbol }\n        let biggestBindingPair = scopesetBindingList\n          .filter(({ scopes }) => {\n            return scopes.isSubset(stxScopes);\n          })\n          .sort(sizeDecending);\n\n        if (\n          biggestBindingPair.size >= 2 &&\n          biggestBindingPair.get(0).scopes.size ===\n            biggestBindingPair.get(1).scopes.size\n        ) {\n          let debugBase =\n            '{' + stxScopes.map(s => s.toString()).join(', ') + '}';\n          let debugAmbigousScopesets = biggestBindingPair\n            .map(({ scopes }) => {\n              return '{' + scopes.map(s => s.toString()).join(', ') + '}';\n            })\n            .join(', ');\n          throw new Error(\n            'Scopeset ' +\n              debugBase +\n              ' has ambiguous subsets ' +\n              debugAmbigousScopesets,\n          );\n        } else if (biggestBindingPair.size !== 0) {\n          let bindingStr = biggestBindingPair.get(0).binding.toString();\n          if (Maybe.isJust(biggestBindingPair.get(0).alias)) {\n            // null never happens because we just checked if it is a Just\n            return biggestBindingPair\n              .get(0)\n              .alias.getOrElse(null)\n              .resolve(phase);\n          }\n          return bindingStr;\n        }\n      }\n    }\n    return this.token.value;\n  }\n\n  val(): any {\n    assert(!this.match('delimiter'), 'cannot get the val of a delimiter');\n    if (this.match('string')) {\n      return this.token.str;\n    }\n    if (this.match('template')) {\n      if (!this.token.items) return this.token.value;\n      return this.token.items\n        .map(el => {\n          if (typeof el.match === 'function' && el.match('delimiter')) {\n            return '${...}';\n          }\n          return el.slice.text;\n        })\n        .join('');\n    }\n    return this.token.value;\n  }\n\n  lineNumber() {\n    if (!this.match('delimiter')) {\n      return this.token.slice.startLocation.line;\n    } else {\n      return this.token.get(0).lineNumber();\n    }\n  }\n\n  setLineNumber(line: number) {\n    let newTok = {};\n    if (this.isDelimiter()) {\n      newTok = this.token.map(s => s.setLineNumber(line));\n    } else {\n      for (let key of Object.keys(this.token)) {\n        newTok[key] = this.token[key];\n      }\n      assert(\n        newTok.slice && newTok.slice.startLocation,\n        'all tokens must have line info',\n      );\n      newTok.slice.startLocation.line = line;\n    }\n    return new Syntax(newTok, this);\n  }\n\n  // () -> List<Syntax>\n  // inner() {\n  //   assert(this.match(\"delimiter\"), \"can only get the inner of a delimiter\");\n  //   return this.token.slice(1, this.token.size - 1);\n  // }\n\n  addScope(\n    scope: any,\n    bindings: any,\n    phase: number | {},\n    options: any = { flip: false },\n  ) {\n    let token = this.match('delimiter')\n      ? this.token.map(s => s.addScope(scope, bindings, phase, options))\n      : this.token;\n    if (this.match('template')) {\n      token = _.merge(token, {\n        items: token.items.map(it => {\n          if (it instanceof Syntax && it.match('delimiter')) {\n            return it.addScope(scope, bindings, phase, options);\n          }\n          return it;\n        }),\n      });\n    }\n    let oldScopeset;\n    if (phase === ALL_PHASES) {\n      oldScopeset = this.scopesets.all;\n    } else {\n      oldScopeset = this.scopesets.phase.has(phase)\n        ? this.scopesets.phase.get(phase)\n        : List();\n    }\n    let newScopeset;\n    if (options.flip) {\n      let index = oldScopeset.indexOf(scope);\n      if (index !== -1) {\n        newScopeset = oldScopeset.remove(index);\n      } else {\n        newScopeset = oldScopeset.push(scope);\n      }\n    } else {\n      newScopeset = oldScopeset.push(scope);\n    }\n    let newstx = {\n      bindings,\n      scopesets: {\n        all: this.scopesets.all,\n        phase: this.scopesets.phase,\n      },\n    };\n\n    if (phase === ALL_PHASES) {\n      newstx.scopesets.all = newScopeset;\n    } else {\n      newstx.scopesets.phase = newstx.scopesets.phase.set(phase, newScopeset);\n    }\n    return new Syntax(token, newstx);\n  }\n\n  removeScope(scope: any, phase: number) {\n    let token = this.match('delimiter')\n      ? this.token.map(s => s.removeScope(scope, phase))\n      : this.token;\n    let phaseScopeset = this.scopesets.phase.has(phase)\n      ? this.scopesets.phase.get(phase)\n      : List();\n    let allScopeset = this.scopesets.all;\n    let newstx = {\n      bindings: this.bindings,\n      scopesets: {\n        all: this.scopesets.all,\n        phase: this.scopesets.phase,\n      },\n    };\n\n    let phaseIndex = phaseScopeset.indexOf(scope);\n    let allIndex = allScopeset.indexOf(scope);\n    if (phaseIndex !== -1) {\n      newstx.scopesets.phase = this.scopesets.phase.set(\n        phase,\n        phaseScopeset.remove(phaseIndex),\n      );\n    } else if (allIndex !== -1) {\n      newstx.scopesets.all = allScopeset.remove(allIndex);\n    }\n    return new Syntax(token, newstx);\n  }\n\n  match(type: TokenTag, value: any) {\n    if (!Types[type]) {\n      throw new Error(type + ' is an invalid type');\n    }\n    return (\n      Types[type].match(this.token) &&\n      (value == null ||\n        (value instanceof RegExp\n          ? value.test(this.val())\n          : this.val() == value))\n    );\n  }\n\n  isIdentifier(value: string) {\n    return this.match('identifier', value);\n  }\n\n  isAssign(value: string) {\n    return this.match('assign', value);\n  }\n\n  isBooleanLiteral(value: boolean) {\n    return this.match('boolean', value);\n  }\n\n  isKeyword(value: string) {\n    return this.match('keyword', value);\n  }\n\n  isNullLiteral(value: any) {\n    return this.match('null', value);\n  }\n\n  isNumericLiteral(value: number) {\n    return this.match('number', value);\n  }\n\n  isPunctuator(value: string) {\n    return this.match('punctuator', value);\n  }\n\n  isStringLiteral(value: string) {\n    return this.match('string', value);\n  }\n\n  isRegularExpression(value: any) {\n    return this.match('regularExpression', value);\n  }\n\n  isTemplate(value: any) {\n    return this.match('template', value);\n  }\n\n  isDelimiter(value: any) {\n    return this.match('delimiter', value);\n  }\n\n  isParens(value: any) {\n    return this.match('parens', value);\n  }\n\n  isBraces(value: any) {\n    return this.match('braces', value);\n  }\n\n  isBrackets(value: any) {\n    return this.match('brackets', value);\n  }\n\n  isSyntaxTemplate(value: any) {\n    return this.match('syntaxTemplate', value);\n  }\n\n  isEOF(value: any) {\n    return this.match('eof', value);\n  }\n\n  toString() {\n    if (this.match('delimiter')) {\n      return this.token.map(s => s.toString()).join(' ');\n    }\n    if (this.match('string')) {\n      return `'${this.token.str}'`;\n    }\n    if (this.match('template')) {\n      return this.val();\n    }\n    return this.token.value;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/template-processor.js":"// @flow\nimport { List } from 'immutable';\nimport _ from 'ramda';\nimport { assert } from './errors';\nimport * as T from 'sweet-spec';\nimport Syntax from './syntax';\n\n/*\nGiven a syntax list like:\n\n  [foo, bar, $, { 42, +, 24 }, baz]\n\nconvert it to:\n\n  [foo, bar, $, { 0 }, baz]\n\nand return another list with the interpolated values at the corresponding\npositions.\n\nRequires either lookahead/lookbehind of one (to see the $).\n*/\n\nconst isDolar = (s: T.SyntaxTerm) =>\n  s instanceof T.RawSyntax &&\n  typeof s.value.match === 'function' &&\n  s.value.match('identifier') &&\n  s.value.val() === '$';\nconst isDelimiter = (s: T.SyntaxTerm) => s instanceof T.RawDelimiter;\nconst isBraces = (s: T.SyntaxTerm) =>\n  s instanceof T.RawDelimiter && s.kind === 'braces';\nconst isParens = (s: T.SyntaxTerm) =>\n  s instanceof T.RawDelimiter && s.kind === 'parens';\nconst isBrackets = (s: T.SyntaxTerm) =>\n  s instanceof T.RawDelimiter && s.kind === 'brackets';\n\ntype DelimKind = 'braces' | 'parens' | 'brackets';\n\nconst mkDelimiter = (\n  kind: DelimKind,\n  inner: List<T.SyntaxTerm>,\n  from: T.RawDelimiter,\n) => {\n  return new T.RawDelimiter({\n    kind,\n    inner: List.of(from.inner.first()).concat(inner).concat(from.inner.last()),\n  });\n};\n\nconst insertIntoDelimiter = _.cond([\n  [isBraces, (s, r) => mkDelimiter('braces', r, s)],\n  [isParens, (s, r) => mkDelimiter('parens', r, s)],\n  [isBrackets, (s, r) => mkDelimiter('brackets', r, s)],\n]);\n\nconst process = (\n  acc: { template: List<T.SyntaxTerm>, interp: List<List<T.SyntaxTerm>> },\n  s: T.SyntaxTerm,\n) => {\n  if (isBraces(s) && isDolar(acc.template.last())) {\n    let idx = Syntax.fromNumber(acc.interp.size, s.inner.first().value);\n    return {\n      template: acc.template.push(\n        mkDelimiter(\n          'braces',\n          List.of(\n            new T.RawSyntax({\n              value: idx,\n            }),\n          ),\n          s,\n        ),\n      ),\n      interp: acc.interp.push(s.inner.slice(1, s.inner.size - 1)),\n    };\n  } else if (isDelimiter(s)) {\n    let innerResult = processTemplate(\n      s.inner.slice(1, s.inner.size - 1),\n      acc.interp,\n    );\n    return {\n      template: acc.template.push(insertIntoDelimiter(s, innerResult.template)),\n      interp: innerResult.interp,\n    };\n  } else {\n    return {\n      template: acc.template.push(s),\n      interp: acc.interp,\n    };\n  }\n};\n\nfunction getLineNumber(t: T.SyntaxTerm) {\n  if (t instanceof T.RawSyntax) {\n    return t.value.lineNumber();\n  }\n  return t.inner.first().value.lineNumber();\n}\n\nfunction setLineNumber(t: T.Term | List<T.Term>, lineNumber: number) {\n  if (t instanceof T.RawSyntax) {\n    return t.extend({\n      value: t.value.setLineNumber(lineNumber),\n    });\n  } else if (t instanceof T.RawDelimiter) {\n    return t.extend({\n      inner: t.inner.map(tt => setLineNumber(tt, lineNumber)),\n    });\n  } else if (List.isList(t)) {\n    return t.map(tt => setLineNumber(tt, lineNumber));\n  }\n  // TODO: need to handle line numbers for all AST nodes\n  return t;\n}\n\nfunction cloneLineNumber(to: T.Term, from: T.SyntaxTerm) {\n  if (from && to) {\n    return setLineNumber(to, getLineNumber(from));\n  }\n  return to;\n}\n\nconst replace = (\n  acc: { template: List<T.SyntaxTerm>, rep: List<T.Term | List<T.Term>> },\n  s: T.SyntaxTerm,\n) => {\n  let last = acc.template.get(-1);\n  let beforeLast = acc.template.get(-2);\n  if (isBraces(s) && isDolar(last)) {\n    let index = s.inner.get(1).value.val();\n    assert(acc.rep.size > index, 'unknown replacement value');\n    // TODO: figure out holistic solution to line nubmers and ASI\n    let replacement = cloneLineNumber(acc.rep.get(index), beforeLast);\n    // let replacement = acc.rep.get(index);\n    return {\n      template: acc.template.pop().concat(replacement),\n      rep: acc.rep,\n    };\n  } else if (isDelimiter(s)) {\n    let innerResult = replaceTemplate(\n      s.inner.slice(1, s.inner.size - 1),\n      acc.rep,\n    );\n    return {\n      template: acc.template.push(insertIntoDelimiter(s, innerResult)),\n      rep: acc.rep,\n    };\n  } else {\n    return {\n      template: acc.template.push(s),\n      rep: acc.rep,\n    };\n  }\n};\n\nexport function processTemplate(\n  temp: List<T.SyntaxTerm>,\n  interp: List<T.SyntaxTerm> = List(),\n) {\n  return temp.reduce(process, { template: List(), interp });\n}\n\nexport function replaceTemplate(temp: List<T.SyntaxTerm>, rep: any) {\n  return temp.reduce(replace, { template: List(), rep }).template;\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/term-expander.js":"import { List } from 'immutable';\nimport { isExpressionStatement, isLiteralStringExpression } from './terms';\nimport Term, * as T from 'sweet-spec';\nimport { freshScope } from './scope';\nimport Compiler from './compiler';\nimport { ALL_PHASES } from './syntax';\nimport { Enforester } from './enforester';\nimport { processTemplate } from './template-processor';\nimport ASTDispatcher from './ast-dispatcher';\nimport ScopeReducer from './scope-reducer';\nimport { gensym } from './symbol';\nimport { VarBindingTransform } from './transforms';\nimport Syntax from './syntax';\n\nexport default class TermExpander extends ASTDispatcher {\n  constructor(context) {\n    super('expand', true);\n    this.context = context;\n  }\n\n  expand(term) {\n    return this.dispatch(term);\n  }\n\n  expandRawSyntax(term) {\n    return term;\n  }\n\n  expandRawDelimiter(term) {\n    return term;\n  }\n\n  expandTemplateExpression(term) {\n    return new T.TemplateExpression({\n      tag: term.tag == null ? null : this.expand(term.tag),\n      elements: term.elements.toArray(),\n    });\n  }\n\n  expandBreakStatement(term) {\n    return new T.BreakStatement({\n      label: term.label ? term.label.val() : null,\n    });\n  }\n\n  expandDoWhileStatement(term) {\n    return new T.DoWhileStatement({\n      body: this.expand(term.body),\n      test: this.expand(term.test),\n    });\n  }\n\n  expandWithStatement(term) {\n    return new T.WithStatement({\n      body: this.expand(term.body),\n      object: this.expand(term.object),\n    });\n  }\n\n  expandDebuggerStatement(term) {\n    return term;\n  }\n\n  expandContinueStatement(term) {\n    return new T.ContinueStatement({\n      label: term.label ? term.label.val() : null,\n    });\n  }\n\n  expandSwitchStatementWithDefault(term) {\n    return new T.SwitchStatementWithDefault({\n      discriminant: this.expand(term.discriminant),\n      preDefaultCases: term.preDefaultCases.map(c => this.expand(c)).toArray(),\n      defaultCase: this.expand(term.defaultCase),\n      postDefaultCases: term.postDefaultCases\n        .map(c => this.expand(c))\n        .toArray(),\n    });\n  }\n\n  expandComputedMemberExpression(term) {\n    return new T.ComputedMemberExpression({\n      object: this.expand(term.object),\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandSwitchStatement(term) {\n    return new T.SwitchStatement({\n      discriminant: this.expand(term.discriminant),\n      cases: term.cases.map(c => this.expand(c)).toArray(),\n    });\n  }\n\n  expandFormalParameters(term) {\n    let rest = term.rest == null ? null : this.expand(term.rest);\n    return new T.FormalParameters({\n      items: term.items.map(i => this.expand(i)),\n      rest,\n    });\n  }\n\n  expandArrowExpressionE(term) {\n    return this.doFunctionExpansion(term, 'ArrowExpression');\n  }\n\n  expandArrowExpression(term) {\n    return this.doFunctionExpansion(term, 'ArrowExpression');\n  }\n\n  expandSwitchDefault(term) {\n    return new T.SwitchDefault({\n      consequent: term.consequent.map(c => this.expand(c)).toArray(),\n    });\n  }\n\n  expandSwitchCase(term) {\n    return new T.SwitchCase({\n      test: this.expand(term.test),\n      consequent: term.consequent.map(c => this.expand(c)).toArray(),\n    });\n  }\n\n  expandForInStatement(term) {\n    return new T.ForInStatement({\n      left: this.expand(term.left),\n      right: this.expand(term.right),\n      body: this.expand(term.body),\n    });\n  }\n\n  expandTryCatchStatement(term) {\n    return new T.TryCatchStatement({\n      body: this.expand(term.body),\n      catchClause: this.expand(term.catchClause),\n    });\n  }\n\n  expandTryFinallyStatement(term) {\n    let catchClause = term.catchClause == null\n      ? null\n      : this.expand(term.catchClause);\n    return new T.TryFinallyStatement({\n      body: this.expand(term.body),\n      catchClause,\n      finalizer: this.expand(term.finalizer),\n    });\n  }\n\n  expandCatchClause(term) {\n    return new T.CatchClause({\n      binding: this.expand(term.binding),\n      body: this.expand(term.body),\n    });\n  }\n\n  expandThrowStatement(term) {\n    return new T.ThrowStatement({\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandForOfStatement(term) {\n    return new T.ForOfStatement({\n      left: this.expand(term.left),\n      right: this.expand(term.right),\n      body: this.expand(term.body),\n    });\n  }\n\n  expandBindingIdentifier(term) {\n    return term;\n  }\n\n  expandBindingPropertyIdentifier(term) {\n    return term;\n  }\n  expandBindingPropertyProperty(term) {\n    return new T.BindingPropertyProperty({\n      name: this.expand(term.name),\n      binding: this.expand(term.binding),\n    });\n  }\n\n  expandComputedPropertyName(term) {\n    return new T.ComputedPropertyName({\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandObjectBinding(term) {\n    return new T.ObjectBinding({\n      properties: term.properties.map(t => this.expand(t)).toArray(),\n    });\n  }\n\n  expandArrayBinding(term) {\n    let restElement = term.restElement == null\n      ? null\n      : this.expand(term.restElement);\n    return new T.ArrayBinding({\n      elements: term.elements\n        .map(t => (t == null ? null : this.expand(t)))\n        .toArray(),\n      restElement,\n    });\n  }\n\n  expandBindingWithDefault(term) {\n    return new T.BindingWithDefault({\n      binding: this.expand(term.binding),\n      init: this.expand(term.init),\n    });\n  }\n\n  expandShorthandProperty(term) {\n    // because hygiene, shorthand properties must turn into DataProperties\n    return new T.DataProperty({\n      name: new T.StaticPropertyName({\n        value: term.name,\n      }),\n      expression: new T.IdentifierExpression({\n        name: term.name,\n      }),\n    });\n  }\n\n  expandForStatement(term) {\n    let init = term.init == null ? null : this.expand(term.init);\n    let test = term.test == null ? null : this.expand(term.test);\n    let update = term.update == null ? null : this.expand(term.update);\n    let body = this.expand(term.body);\n    return new T.ForStatement({ init, test, update, body });\n  }\n\n  expandYieldExpression(term) {\n    let expr = term.expression == null ? null : this.expand(term.expression);\n    return new T.YieldExpression({\n      expression: expr,\n    });\n  }\n\n  expandYieldGeneratorExpression(term) {\n    let expr = term.expression == null ? null : this.expand(term.expression);\n    return new T.YieldGeneratorExpression({\n      expression: expr,\n    });\n  }\n\n  expandWhileStatement(term) {\n    return new T.WhileStatement({\n      test: this.expand(term.test),\n      body: this.expand(term.body),\n    });\n  }\n\n  expandIfStatement(term) {\n    let consequent = term.consequent == null\n      ? null\n      : this.expand(term.consequent);\n    let alternate = term.alternate == null ? null : this.expand(term.alternate);\n    return new T.IfStatement({\n      test: this.expand(term.test),\n      consequent: consequent,\n      alternate: alternate,\n    });\n  }\n\n  expandBlockStatement(term) {\n    return new T.BlockStatement({\n      block: this.expand(term.block),\n    });\n  }\n\n  expandBlock(term) {\n    let scope = freshScope('block');\n    this.context.currentScope.push(scope);\n    let compiler = new Compiler(\n      this.context.phase,\n      this.context.env,\n      this.context.store,\n      this.context,\n    );\n\n    let markedBody, bodyTerm;\n    markedBody = term.statements.map(b =>\n      b.reduce(\n        new ScopeReducer(\n          [{ scope, phase: ALL_PHASES, flip: false }],\n          this.context.bindings,\n        ),\n      ),\n    );\n    bodyTerm = new T.Block({\n      statements: compiler.compile(markedBody),\n    });\n    this.context.currentScope.pop();\n    return bodyTerm;\n  }\n\n  expandVariableDeclarationStatement(term) {\n    return new T.VariableDeclarationStatement({\n      declaration: this.expand(term.declaration),\n    });\n  }\n  expandReturnStatement(term) {\n    if (term.expression == null) {\n      return term;\n    }\n    return new T.ReturnStatement({\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandClassDeclaration(term) {\n    return new T.ClassDeclaration({\n      name: term.name == null ? null : this.expand(term.name),\n      super: term.super == null ? null : this.expand(term.super),\n      elements: term.elements.map(el => this.expand(el)).toArray(),\n    });\n  }\n\n  expandClassExpression(term) {\n    return new T.ClassExpression({\n      name: term.name == null ? null : this.expand(term.name),\n      super: term.super == null ? null : this.expand(term.super),\n      elements: term.elements.map(el => this.expand(el)).toArray(),\n    });\n  }\n\n  expandClassElement(term) {\n    return new T.ClassElement({\n      isStatic: term.isStatic,\n      method: this.expand(term.method),\n    });\n  }\n\n  expandThisExpression(term) {\n    return term;\n  }\n\n  expandSyntaxTemplate(term) {\n    let r = processTemplate(term.template.slice(1, term.template.size - 1));\n    let ident = this.context.getTemplateIdentifier();\n    this.context.templateMap.set(ident, r.template);\n    let name = Syntax.fromIdentifier(\n      'syntaxTemplate',\n      term.template.first().value,\n    );\n    let callee = new T.IdentifierExpression({\n      name: name,\n    });\n\n    let expandedInterps = r.interp.map(i => {\n      let enf = new Enforester(i, List(), this.context);\n      return this.expand(enf.enforest('expression'));\n    });\n\n    let args = List.of(new T.LiteralNumericExpression({ value: ident })).concat(\n      expandedInterps,\n    );\n\n    return new T.CallExpression({\n      callee,\n      arguments: args,\n    });\n  }\n\n  expandStaticMemberExpression(term) {\n    return new T.StaticMemberExpression({\n      object: this.expand(term.object),\n      property: term.property,\n    });\n  }\n\n  expandArrayExpression(term) {\n    return new T.ArrayExpression({\n      elements: term.elements.map(t => (t == null ? t : this.expand(t))),\n    });\n  }\n\n  expandImport(term) {\n    return term;\n  }\n\n  expandImportNamespace(term) {\n    return term;\n  }\n\n  expandExport(term) {\n    return new T.Export({\n      declaration: this.expand(term.declaration),\n    });\n  }\n\n  expandExportDefault(term) {\n    return new T.ExportDefault({\n      body: this.expand(term.body),\n    });\n  }\n\n  expandExportFrom(term) {\n    return term;\n  }\n\n  expandExportAllFrom(term) {\n    return term;\n  }\n\n  expandExportSpecifier(term) {\n    return term;\n  }\n\n  expandStaticPropertyName(term) {\n    return term;\n  }\n\n  expandDataProperty(term) {\n    return new T.DataProperty({\n      name: this.expand(term.name),\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandObjectExpression(term) {\n    return new T.ObjectExpression({\n      properties: term.properties.map(t => this.expand(t)),\n    });\n  }\n\n  expandVariableDeclarator(term) {\n    let init = term.init == null ? null : this.expand(term.init);\n    return new T.VariableDeclarator({\n      binding: this.expand(term.binding),\n      init: init,\n    });\n  }\n\n  expandVariableDeclaration(term) {\n    if (\n      term.kind === 'syntax' ||\n      term.kind === 'syntaxrec' ||\n      term.kind === 'operator'\n    ) {\n      return term;\n    }\n    return new T.VariableDeclaration({\n      kind: term.kind,\n      declarators: term.declarators.map(d => this.expand(d)),\n    });\n  }\n\n  expandParenthesizedExpression(term) {\n    if (term.inner.size === 0) {\n      throw new Error('unexpected end of input');\n    }\n    let enf = new Enforester(term.inner, List(), this.context);\n    let lookahead = enf.peek();\n    let t = enf.enforestExpression();\n    if (t == null || enf.rest.size > 0) {\n      if (enf.rest.size === 0) {\n        throw enf.createError(')', 'unexpected token');\n      }\n      throw enf.createError(lookahead, 'unexpected syntax');\n    }\n    return this.expand(t);\n  }\n\n  expandUnaryExpression(term) {\n    return new T.UnaryExpression({\n      operator: term.operator,\n      operand: this.expand(term.operand),\n    });\n  }\n\n  expandUpdateExpression(term) {\n    return new T.UpdateExpression({\n      isPrefix: term.isPrefix,\n      operator: term.operator,\n      operand: this.expand(term.operand),\n    });\n  }\n\n  expandBinaryExpression(term) {\n    let left = this.expand(term.left);\n    let right = this.expand(term.right);\n    return new T.BinaryExpression({\n      left: left,\n      operator: term.operator,\n      right: right,\n    });\n  }\n\n  expandConditionalExpression(term) {\n    return new T.ConditionalExpression({\n      test: this.expand(term.test),\n      consequent: this.expand(term.consequent),\n      alternate: this.expand(term.alternate),\n    });\n  }\n\n  expandNewTargetExpression(term) {\n    return term;\n  }\n\n  expandNewExpression(term) {\n    let callee = this.expand(term.callee);\n    let enf = new Enforester(term.arguments, List(), this.context);\n    let args = enf.enforestArgumentList().map(arg => this.expand(arg));\n    return new T.NewExpression({\n      callee,\n      arguments: args.toArray(),\n    });\n  }\n\n  expandSuper(term) {\n    return term;\n  }\n\n  expandCallExpressionE(term) {\n    let callee = this.expand(term.callee);\n    let enf = new Enforester(term.arguments, List(), this.context);\n    let args = enf.enforestArgumentList().map(arg => this.expand(arg));\n    return new T.CallExpression({\n      callee: callee,\n      arguments: args,\n    });\n  }\n\n  expandSpreadElement(term) {\n    return new T.SpreadElement({\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandExpressionStatement(term) {\n    let child = this.expand(term.expression);\n    return new T.ExpressionStatement({\n      expression: child,\n    });\n  }\n\n  expandLabeledStatement(term) {\n    return new T.LabeledStatement({\n      label: term.label.val(),\n      body: this.expand(term.body),\n    });\n  }\n\n  doFunctionExpansion(term, type) {\n    let scope = freshScope('fun');\n    let params;\n    let self = this;\n    if (type !== 'Getter' && type !== 'Setter') {\n      // TODO: need to register the parameter bindings again\n      params = term.params.reduce(\n        new class extends Term.CloneReducer {\n          reduceBindingIdentifier(term) {\n            let name = term.name.addScope(\n              scope,\n              self.context.bindings,\n              ALL_PHASES,\n            );\n            let newBinding = gensym(name.val());\n\n            self.context.env.set(\n              newBinding.toString(),\n              new VarBindingTransform(name),\n            );\n            self.context.bindings.add(name, {\n              binding: newBinding,\n              phase: self.context.phase,\n              skipDup: true,\n            });\n            return new T.BindingIdentifier({ name });\n          }\n        }(),\n      );\n      params = this.expand(params);\n    }\n    this.context.currentScope.push(scope);\n    let compiler = new Compiler(\n      this.context.phase,\n      this.context.env,\n      this.context.store,\n      this.context,\n    );\n\n    let bodyTerm;\n    let scopeReducer = new ScopeReducer(\n      [{ scope, phase: ALL_PHASES, flip: false }],\n      this.context.bindings,\n    );\n    if (term.body instanceof Term) {\n      // Arrow functions have a single term as their body\n      bodyTerm = this.expand(term.body.reduce(scopeReducer));\n    } else {\n      let compiledBody = compiler.compile(\n        term.body.map(b => b.reduce(scopeReducer)),\n      );\n      const directives = compiledBody\n        .takeWhile(\n          s =>\n            isExpressionStatement(s) && isLiteralStringExpression(s.expression),\n        )\n        .map(s => new T.Directive({ rawValue: s.expression.value }));\n      bodyTerm = new T.FunctionBody({\n        directives: directives,\n        statements: compiledBody.slice(directives.size),\n      });\n    }\n    this.context.currentScope.pop();\n\n    switch (type) {\n      case 'Getter':\n        return new T.Getter({\n          name: this.expand(term.name),\n          body: bodyTerm,\n        });\n      case 'Setter':\n        return new T.Setter({\n          name: this.expand(term.name),\n          param: term.param,\n          body: bodyTerm,\n        });\n      case 'Method':\n        return new T.Method({\n          name: term.name,\n          isGenerator: term.isGenerator,\n          params: params,\n          body: bodyTerm,\n        });\n      case 'ArrowExpression':\n        return new T.ArrowExpression({\n          params: params,\n          body: bodyTerm,\n        });\n      case 'FunctionExpression':\n        return new T.FunctionExpression({\n          name: term.name,\n          isGenerator: term.isGenerator,\n          params: params,\n          body: bodyTerm,\n        });\n      case 'FunctionDeclaration':\n        return new T.FunctionDeclaration({\n          name: term.name,\n          isGenerator: term.isGenerator,\n          params: params,\n          body: bodyTerm,\n        });\n      default:\n        throw new Error(`Unknown function type: ${type}`);\n    }\n  }\n\n  expandMethod(term) {\n    return this.doFunctionExpansion(term, 'Method');\n  }\n\n  expandSetter(term) {\n    return this.doFunctionExpansion(term, 'Setter');\n  }\n\n  expandGetter(term) {\n    return this.doFunctionExpansion(term, 'Getter');\n  }\n\n  expandFunctionDeclarationE(term) {\n    return this.doFunctionExpansion(term, 'FunctionDeclaration');\n  }\n\n  expandFunctionExpressionE(term) {\n    return this.doFunctionExpansion(term, 'FunctionExpression');\n  }\n\n  expandCompoundAssignmentExpression(term) {\n    return new T.CompoundAssignmentExpression({\n      binding: this.expand(term.binding),\n      operator: term.operator,\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandAssignmentExpression(term) {\n    return new T.AssignmentExpression({\n      binding: this.expand(term.binding),\n      expression: this.expand(term.expression),\n    });\n  }\n\n  expandEmptyStatement(term) {\n    return term;\n  }\n\n  expandLiteralBooleanExpression(term) {\n    return term;\n  }\n\n  expandLiteralNumericExpression(term) {\n    return term;\n  }\n  expandLiteralInfinityExpression(term) {\n    return term;\n  }\n\n  expandIdentifierExpression(term) {\n    let trans = this.context.env.get(term.name.resolve(this.context.phase));\n    if (trans) {\n      return new T.IdentifierExpression({\n        name: trans.id,\n      });\n    }\n    return term;\n  }\n\n  expandLiteralNullExpression(term) {\n    return term;\n  }\n\n  expandLiteralStringExpression(term) {\n    return term;\n  }\n\n  expandLiteralRegExpExpression(term) {\n    return term;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/terms.js":"import * as R from 'ramda';\nimport Term from 'sweet-spec';\n\n// bindings\nexport const isBindingWithDefault = R.whereEq({ type: 'BindingWithDefault' });\nexport const isBindingIdentifier = R.whereEq({ type: 'BindingIdentifier' });\nexport const isArrayBinding = R.whereEq({ type: 'ArrayBinding' });\nexport const isObjectBinding = R.whereEq({ type: 'ObjectBinding' });\nexport const isBindingPropertyIdentifier = R.whereEq({\n  type: 'BindingPropertyIdentifier',\n});\nexport const isBindingPropertyProperty = R.whereEq({\n  type: 'BindingPropertyIdentifier',\n});\n\n// class\nexport const isClassExpression = R.whereEq({ type: 'ClassExpression' });\nexport const isClassDeclaration = R.whereEq({ type: 'ClassDeclaration' });\nexport const isClassElement = R.whereEq({ type: 'ClassElement' });\n\n// modules\nexport const isModule = R.whereEq({ type: 'Module' });\nexport const isImport = R.whereEq({ type: 'Import' });\nexport const isImportNamespace = R.whereEq({ type: 'ImportNamespace' });\nexport const isImportSpecifier = R.whereEq({ type: 'ImportSpecifier' });\nexport const isExportAllFrom = R.whereEq({ type: 'ExportAllFrom' });\nexport const isExportFrom = R.whereEq({ type: 'ExportFrom' });\nexport const isExport = R.whereEq({ type: 'Export' });\nexport const isExportDefault = R.whereEq({ type: 'ExportDefault' });\nexport const isExportSpecifier = R.whereEq({ type: 'ExportSpecifier' });\n\n// property definition\nexport const isMethod = R.whereEq({ type: 'Method' });\nexport const isGetter = R.whereEq({ type: 'Getter' });\nexport const isSetter = R.whereEq({ type: 'Setter' });\nexport const isDataProperty = R.whereEq({ type: 'DataProperty' });\nexport const isShorthandProperty = R.whereEq({ type: 'ShorthandProperty' });\nexport const isComputedPropertyName = R.whereEq({\n  type: 'ComputedPropertyName',\n});\nexport const isStaticPropertyName = R.whereEq({ type: 'StaticPropertyName' });\n\n// literals\nexport const isLiteralBooleanExpression = R.whereEq({\n  type: 'LiteralBooleanExpression',\n});\nexport const isLiteralInfinityExpression = R.whereEq({\n  type: 'LiteralInfinityExpression',\n});\nexport const isLiteralNullExpression = R.whereEq({\n  type: 'LiteralNullExpression',\n});\nexport const isLiteralNumericExpression = R.whereEq({\n  type: 'LiteralNumericExpression',\n});\nexport const isLiteralRegExpExpression = R.whereEq({\n  type: 'LiteralRegExpExpression',\n});\nexport const isLiteralStringExpression = R.whereEq({\n  type: 'LiteralStringExpression',\n});\n\n// expressions\nexport const isArrayExpression = R.whereEq({ type: 'ArrayExpression' });\nexport const isArrowExpression = R.whereEq({ type: 'ArrowExpression' });\nexport const isAssignmentExpression = R.whereEq({\n  type: 'AssignmentExpression',\n});\nexport const isBinaryExpression = R.whereEq({ type: 'BinaryExpression' });\nexport const isCallExpression = R.whereEq({ type: 'CallExpression' });\nexport const isComputedAssignmentExpression = R.whereEq({\n  type: 'ComputedAssignmentExpression',\n});\nexport const isComputedMemberExpression = R.whereEq({\n  type: 'ComputedMemberExpression',\n});\nexport const isConditionalExpression = R.whereEq({\n  type: 'ConditionalExpression',\n});\nexport const isFunctionExpression = R.whereEq({ type: 'FunctionExpression' });\nexport const isIdentifierExpression = R.whereEq({\n  type: 'IdentifierExpression',\n});\nexport const isNewExpression = R.whereEq({ type: 'NewExpression' });\nexport const isNewTargetExpression = R.whereEq({ type: 'NewTargetExpression' });\nexport const isObjectExpression = R.whereEq({ type: 'ObjectExpression' });\nexport const isUnaryExpression = R.whereEq({ type: 'UnaryExpression' });\nexport const isStaticMemberExpression = R.whereEq({\n  type: 'StaticMemberExpression',\n});\nexport const isTemplateExpression = R.whereEq({ type: 'TemplateExpression' });\nexport const isThisExpression = R.whereEq({ type: 'ThisExpression' });\nexport const isUpdateExpression = R.whereEq({ type: 'UpdateExpression' });\nexport const isYieldExpression = R.whereEq({ type: 'YieldExpression' });\nexport const isYieldGeneratorExpression = R.whereEq({\n  type: 'YieldGeneratorExpression',\n});\n\n// statements\nexport const isBlockStatement = R.whereEq({ type: 'BlockStatement' });\nexport const isBreakStatement = R.whereEq({ type: 'BreakStatement' });\nexport const isContinueStatement = R.whereEq({ type: 'ContinueStatement' });\nexport const isCompoundAssignmentExpression = R.whereEq({\n  type: 'CompoundAssignmentExpression',\n});\nexport const isDebuggerStatement = R.whereEq({ type: 'DebuggerStatement' });\nexport const isDoWhileStatement = R.whereEq({ type: 'DoWhileStatement' });\nexport const isEmptyStatement = R.whereEq({ type: 'EmptyStatement' });\nexport const isExpressionStatement = R.whereEq({ type: 'ExpressionStatement' });\nexport const isForInStatement = R.whereEq({ type: 'ForInStatement' });\nexport const isForOfStatement = R.whereEq({ type: 'ForOfStatement' });\nexport const isForStatement = R.whereEq({ type: 'ForStatement' });\nexport const isIfStatement = R.whereEq({ type: 'IfStatement' });\nexport const isLabeledStatement = R.whereEq({ type: 'LabeledStatement' });\nexport const isReturnStatement = R.whereEq({ type: 'ReturnStatement' });\nexport const isSwitchStatement = R.whereEq({ type: 'SwitchStatement' });\nexport const isSwitchStatementWithDefault = R.whereEq({\n  type: 'SwitchStatementWithDefault',\n});\nexport const isThrowStatement = R.whereEq({ type: 'ThrowStatement' });\nexport const isTryCatchStatement = R.whereEq({ type: 'TryCatchStatement' });\nexport const isTryFinallyStatement = R.whereEq({ type: 'TryFinallyStatement' });\nexport const isVariableDeclarationStatement = R.whereEq({\n  type: 'VariableDeclarationStatement',\n});\nexport const isWhileStatement = R.whereEq({ type: 'WhileStatement' });\nexport const isWithStatement = R.whereEq({ type: 'WithStatement' });\n\n// other\nexport const isBlock = R.whereEq({ type: 'Block' });\nexport const isCatchClause = R.whereEq({ type: 'CatchClause' });\nexport const isDirective = R.whereEq({ type: 'Directive' });\nexport const isFormalParameters = R.whereEq({ type: 'FormalParameters' });\nexport const isFunctionBody = R.whereEq({ type: 'FunctionBody' });\nexport const isFunctionDeclaration = R.whereEq({ type: 'FunctionDeclaration' });\nexport const isScript = R.whereEq({ type: 'Script' });\nexport const isSpreadElement = R.whereEq({ type: 'SpreadElement' });\nexport const isSuper = R.whereEq({ type: 'Super' });\nexport const isSwitchCase = R.whereEq({ type: 'SwitchCase' });\nexport const isSwitchDefault = R.whereEq({ type: 'SwitchDefault' });\nexport const isTemplateElement = R.whereEq({ type: 'TemplateElement' });\nexport const isSyntaxTemplate = R.whereEq({ type: 'SyntaxTemplate' });\nexport const isVariableDeclaration = R.whereEq({ type: 'VariableDeclaration' });\nexport const isVariableDeclarator = R.whereEq({ type: 'VariableDeclarator' });\nexport const isEOF = R.whereEq({ type: 'EOF' });\nexport const isSyntaxDeclaration = R.both(\n  isVariableDeclaration,\n  R.whereEq({ kind: 'syntax' }),\n);\nexport const isSyntaxrecDeclaration = R.both(\n  isVariableDeclaration,\n  R.whereEq({ kind: 'syntaxrec' }),\n);\nexport const isFunctionTerm = R.either(\n  isFunctionDeclaration,\n  isFunctionExpression,\n);\nexport const isFunctionWithName = R.and(\n  isFunctionTerm,\n  R.complement(R.where({ name: R.isNil })),\n);\nexport const isParenthesizedExpression = R.whereEq({\n  type: 'ParenthesizedExpression',\n});\nexport const isExportSyntax = R.both(isExport, exp =>\n  R.or(\n    isSyntaxDeclaration(exp.declaration),\n    isSyntaxrecDeclaration(exp.declaration),\n  ),\n);\nexport const isSyntaxDeclarationStatement = R.both(\n  isVariableDeclarationStatement,\n  decl => isCompiletimeDeclaration(decl.declaration),\n);\n\nexport const isCompiletimeDeclaration = R.either(\n  isSyntaxDeclaration,\n  isSyntaxrecDeclaration,\n);\nexport const isCompiletimeStatement = term => {\n  return (\n    term instanceof Term &&\n    isVariableDeclarationStatement(term) &&\n    isCompiletimeDeclaration(term.declaration)\n  );\n};\nexport const isImportDeclaration = R.either(isImport, isImportNamespace);\nexport const isExportDeclaration = R.either(\n  isExport,\n  isExportDefault,\n  isExportFrom,\n  isExportAllFrom,\n);\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/token-expander.js":"// @flow\nimport Term, * as S from 'sweet-spec';\nimport { List } from 'immutable';\nimport { Enforester } from './enforester';\nimport TermExpander from './term-expander.js';\nimport Env from './env';\nimport * as _ from 'ramda';\nimport * as T from './terms';\nimport { gensym } from './symbol';\nimport { VarBindingTransform, CompiletimeTransform } from './transforms';\nimport { evalCompiletimeValue } from './load-syntax';\nimport { freshScope } from './scope';\nimport { ALL_PHASES } from './syntax';\nimport ASTDispatcher from './ast-dispatcher';\nimport Syntax from './syntax.js';\nimport ScopeReducer from './scope-reducer';\nimport ModuleVisitor, { bindImports } from './module-visitor';\n\nclass RegisterBindingsReducer extends Term.CloneReducer {\n  useScope: any;\n  phase: number;\n  bindings: any;\n  skipDup: boolean;\n  env: Env;\n\n  constructor(\n    useScope: any,\n    phase: number,\n    skipDup: boolean,\n    bindings: any,\n    env: Env,\n  ) {\n    super();\n    this.useScope = useScope;\n    this.phase = phase;\n    this.bindings = bindings;\n    this.skipDup = skipDup;\n    this.env = env;\n  }\n\n  reduceBindingIdentifier(t: Term, s: { name: Syntax }) {\n    let newName = s.name.removeScope(this.useScope, this.phase);\n    let newBinding = gensym(newName.val());\n    this.bindings.add(newName, {\n      binding: newBinding,\n      phase: this.phase,\n      skipDup: this.skipDup,\n    });\n    this.env.set(newBinding.toString(), new VarBindingTransform(newName));\n    return t.extend({\n      name: newName,\n    });\n  }\n}\n\nclass RegisterSyntaxBindingsReducer extends Term.CloneReducer {\n  useScope: any;\n  phase: number;\n  bindings: any;\n  env: Env;\n  val: any;\n\n  constructor(useScope: any, phase: number, bindings: any, env: Env, val: any) {\n    super();\n    this.useScope = useScope;\n    this.phase = phase;\n    this.bindings = bindings;\n    this.env = env;\n    this.val = val;\n  }\n\n  reduceBindingIdentifier(t: Term, s: { name: Syntax }) {\n    let newName = s.name.removeScope(this.useScope, this.phase);\n    let newBinding = gensym(newName.val());\n    this.bindings.add(newName, {\n      binding: newBinding,\n      phase: this.phase,\n      skipDup: false,\n    });\n    let resolvedName = newName.resolve(this.phase);\n    this.env.set(resolvedName, new CompiletimeTransform(this.val));\n    return t.extend({\n      name: newName,\n    });\n  }\n}\n\nexport default class TokenExpander extends ASTDispatcher {\n  constructor(context: any) {\n    super('expand', false);\n    this.context = context;\n  }\n\n  expand(stxl: List<Syntax>) {\n    let result = [];\n    if (stxl.size === 0) {\n      return List(result);\n    }\n    let prev = List();\n    let enf = new Enforester(stxl, prev, this.context);\n\n    while (!enf.done) {\n      result.push(this.dispatch(enf.enforest()));\n    }\n\n    return List(result);\n  }\n\n  expandVariableDeclarationStatement(term: S.VariableDeclarationStatement) {\n    return term.extend({\n      declaration: this.registerVariableDeclaration(term.declaration),\n    });\n  }\n\n  expandFunctionDeclaration(term: Term) {\n    return this.registerFunctionOrClass(term);\n  }\n\n  // TODO: think about function expressions\n\n  registerImport(term: S.Import | S.ImportNamespace) {\n    let path = term.moduleSpecifier.val();\n    let mod;\n    let visitor = new ModuleVisitor(this.context);\n    if (term.forSyntax) {\n      mod = this.context.loader.get(\n        path,\n        this.context.phase + 1,\n        this.context.cwd,\n      );\n      this.context.store = visitor.visit(\n        mod,\n        this.context.phase + 1,\n        this.context.store,\n      );\n      this.context.store = visitor.invoke(\n        mod,\n        this.context.phase + 1,\n        this.context.store,\n      );\n    } else {\n      mod = this.context.loader.get(path, this.context.phase, this.context.cwd);\n      this.context.store = visitor.visit(\n        mod,\n        this.context.phase,\n        this.context.store,\n      );\n    }\n    bindImports(term, mod, this.context.phase, this.context);\n    return term;\n  }\n\n  expandImport(term: S.Import) {\n    return this.registerImport(term);\n  }\n\n  expandImportNamespace(term: S.ImportNamespace) {\n    return this.registerImport(term);\n  }\n\n  expandExport(term: Term) {\n    if (\n      T.isFunctionDeclaration(term.declaration) ||\n      T.isClassDeclaration(term.declaration)\n    ) {\n      return term.extend({\n        declaration: this.registerFunctionOrClass(term.declaration),\n      });\n    } else if (T.isVariableDeclaration(term.declaration)) {\n      return term.extend({\n        declaration: this.registerVariableDeclaration(term.declaration),\n      });\n    }\n    return term;\n  }\n\n  registerFunctionOrClass(term: Term) {\n    let red = new RegisterBindingsReducer(\n      this.context.useScope,\n      this.context.phase,\n      false,\n      this.context.bindings,\n      this.context.env,\n    );\n    return term.extend({\n      name: term.name.reduce(red),\n    });\n  }\n\n  registerVariableDeclaration(term: Term) {\n    if (\n      term.kind === 'syntax' ||\n      term.kind === 'syntaxrec' ||\n      term.kind === 'operator'\n    ) {\n      return this.registerSyntaxDeclaration(term);\n    }\n    let red = new RegisterBindingsReducer(\n      this.context.useScope,\n      this.context.phase,\n      term.kind === 'var',\n      this.context.bindings,\n      this.context.env,\n    );\n    return term.extend({\n      declarators: term.declarators.map(decl => {\n        return decl.extend({\n          binding: decl.binding.reduce(red),\n        });\n      }),\n    });\n  }\n\n  registerSyntaxDeclaration(term: Term) {\n    if (term.kind === 'syntax' || term.kind === 'operator') {\n      // syntax id^{a, b} = <init>^{a, b}\n      // ->\n      // syntaxrec id^{a,b,c} = function() { return <<id^{a}>> }\n      // syntaxrec id^{a,b} = <init>^{a,b,c}\n      let scope = freshScope('nonrec');\n      let scopeReducer = new ScopeReducer(\n        [{ scope: scope, phase: ALL_PHASES, flip: false }],\n        this.context.bindings,\n      );\n      term = term.extend({\n        declarators: term.declarators.map(decl => {\n          let name = decl.binding.name;\n          let nameAdded = name.addScope(\n            scope,\n            this.context.bindings,\n            ALL_PHASES,\n          );\n          let nameRemoved = name.removeScope(\n            this.context.currentScope[this.context.currentScope.length - 1],\n            this.context.phase,\n          );\n          let newBinding = gensym(name.val());\n          this.context.bindings.addForward(\n            nameAdded,\n            nameRemoved,\n            newBinding,\n            this.context.phase,\n          );\n          return decl.extend({\n            init: decl.init.reduce(scopeReducer),\n          });\n        }),\n      });\n    }\n    // for syntax declarations we need to load the compiletime value\n    // into the environment\n    let compiletimeType = term.kind === 'operator' ? 'operator' : 'syntax';\n    return term.extend({\n      declarators: term.declarators.map(decl => {\n        // each compiletime value needs to be expanded with a fresh\n        // environment and in the next higher phase\n        let syntaxExpander = new TermExpander(\n          _.merge(this.context, {\n            phase: this.context.phase + 1,\n            env: new Env(),\n            store: this.context.store,\n          }),\n        );\n\n        let init = syntaxExpander.expand(decl.init);\n        let val = evalCompiletimeValue(\n          init,\n          _.merge(this.context, {\n            phase: this.context.phase + 1,\n          }),\n        );\n        let red = new RegisterSyntaxBindingsReducer(\n          this.context.useScope,\n          this.context.phase,\n          this.context.bindings,\n          this.context.env,\n          {\n            type: compiletimeType,\n            prec: decl.prec == null ? void 0 : decl.prec.val(),\n            assoc: decl.assoc == null ? void 0 : decl.assoc.val(),\n            f: val,\n          },\n        );\n        return decl.extend({ binding: decl.binding.reduce(red), init });\n      }),\n    });\n  }\n\n  // registerSyntaxDeclarator(term) {\n  //\n  // }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/tokens.js":"// @flow\n\nimport type { List } from 'immutable';\n\nexport type LocationInfo = {\n  filename: string,\n  position: number,\n  line: number,\n  column: number,\n};\n\nexport const TokenClass = {\n  Eof: { name: '<End>' },\n  Ident: { name: 'Identifier', isIdentifierName: true },\n  Keyword: { name: 'Keyword', isIdentifierName: true },\n  NumericLiteral: { name: 'Numeric' },\n  TemplateElement: { name: 'Template' },\n  Punctuator: { name: 'Punctuator' },\n  StringLiteral: { name: 'String' },\n  RegularExpression: { name: 'RegularExpression' },\n  Illegal: { name: 'Illegal' },\n};\n\nconst TC = TokenClass;\n\nexport const TokenType = {\n  EOS: { klass: TC.Eof, name: 'EOS' },\n  LPAREN: { klass: TC.Punctuator, name: '(' },\n  RPAREN: { klass: TC.Punctuator, name: ')' },\n  LBRACK: { klass: TC.Punctuator, name: '[' },\n  RBRACK: { klass: TC.Punctuator, name: ']' },\n  LBRACE: { klass: TC.Punctuator, name: '{' },\n  RBRACE: { klass: TC.Punctuator, name: '}' },\n  LSYNTAX: { klass: TC.Punctuator, name: 'left-syntax' },\n  RSYNTAX: { klass: TC.Punctuator, name: 'right-syntax' },\n  COLON: { klass: TC.Punctuator, name: ':' },\n  SEMICOLON: { klass: TC.Punctuator, name: ';' },\n  PERIOD: { klass: TC.Punctuator, name: '.' },\n  ELLIPSIS: { klass: TC.Punctuator, name: '...' },\n  ARROW: { klass: TC.Punctuator, name: '=>' },\n  CONDITIONAL: { klass: TC.Punctuator, name: '?' },\n  INC: { klass: TC.Punctuator, name: '++' },\n  DEC: { klass: TC.Punctuator, name: '--' },\n  ASSIGN: { klass: TC.Punctuator, name: '=' },\n  ASSIGN_BIT_OR: { klass: TC.Punctuator, name: '|=' },\n  ASSIGN_BIT_XOR: { klass: TC.Punctuator, name: '^=' },\n  ASSIGN_BIT_AND: { klass: TC.Punctuator, name: '&=' },\n  ASSIGN_SHL: { klass: TC.Punctuator, name: '<<=' },\n  ASSIGN_SHR: { klass: TC.Punctuator, name: '>>=' },\n  ASSIGN_SHR_UNSIGNED: { klass: TC.Punctuator, name: '>>>=' },\n  ASSIGN_ADD: { klass: TC.Punctuator, name: '+=' },\n  ASSIGN_SUB: { klass: TC.Punctuator, name: '-=' },\n  ASSIGN_MUL: { klass: TC.Punctuator, name: '*=' },\n  ASSIGN_DIV: { klass: TC.Punctuator, name: '/=' },\n  ASSIGN_MOD: { klass: TC.Punctuator, name: '%=' },\n  ASSIGN_EXP: { klass: TC.Punctuator, name: '**=' },\n  COMMA: { klass: TC.Punctuator, name: ',' },\n  OR: { klass: TC.Punctuator, name: '||' },\n  AND: { klass: TC.Punctuator, name: '&&' },\n  BIT_OR: { klass: TC.Punctuator, name: '|' },\n  BIT_XOR: { klass: TC.Punctuator, name: '^' },\n  BIT_AND: { klass: TC.Punctuator, name: '&' },\n  SHL: { klass: TC.Punctuator, name: '<<' },\n  SHR: { klass: TC.Punctuator, name: '>>' },\n  SHR_UNSIGNED: { klass: TC.Punctuator, name: '>>>' },\n  ADD: { klass: TC.Punctuator, name: '+' },\n  SUB: { klass: TC.Punctuator, name: '-' },\n  MUL: { klass: TC.Punctuator, name: '*' },\n  DIV: { klass: TC.Punctuator, name: '/' },\n  MOD: { klass: TC.Punctuator, name: '%' },\n  EXP: { klass: TC.Punctuator, name: '**' },\n  EQ: { klass: TC.Punctuator, name: '==' },\n  NE: { klass: TC.Punctuator, name: '!=' },\n  EQ_STRICT: { klass: TC.Punctuator, name: '===' },\n  NE_STRICT: { klass: TC.Punctuator, name: '!==' },\n  LT: { klass: TC.Punctuator, name: '<' },\n  GT: { klass: TC.Punctuator, name: '>' },\n  LTE: { klass: TC.Punctuator, name: '<=' },\n  GTE: { klass: TC.Punctuator, name: '>=' },\n  INSTANCEOF: { klass: TC.Keyword, name: 'instanceof' },\n  IN: { klass: TC.Keyword, name: 'in' },\n  NOT: { klass: TC.Punctuator, name: '!' },\n  BIT_NOT: { klass: TC.Punctuator, name: '~' },\n  AWAIT: { klass: TC.Keyword, name: 'await' },\n  DELETE: { klass: TC.Keyword, name: 'delete' },\n  TYPEOF: { klass: TC.Keyword, name: 'typeof' },\n  VOID: { klass: TC.Keyword, name: 'void' },\n  BREAK: { klass: TC.Keyword, name: 'break' },\n  CASE: { klass: TC.Keyword, name: 'case' },\n  CATCH: { klass: TC.Keyword, name: 'catch' },\n  CLASS: { klass: TC.Keyword, name: 'class' },\n  CONTINUE: { klass: TC.Keyword, name: 'continue' },\n  DEBUGGER: { klass: TC.Keyword, name: 'debugger' },\n  DEFAULT: { klass: TC.Keyword, name: 'default' },\n  DO: { klass: TC.Keyword, name: 'do' },\n  ELSE: { klass: TC.Keyword, name: 'else' },\n  EXPORT: { klass: TC.Keyword, name: 'export' },\n  EXTENDS: { klass: TC.Keyword, name: 'extends' },\n  FINALLY: { klass: TC.Keyword, name: 'finally' },\n  FOR: { klass: TC.Keyword, name: 'for' },\n  FUNCTION: { klass: TC.Keyword, name: 'function' },\n  IF: { klass: TC.Keyword, name: 'if' },\n  IMPORT: { klass: TC.Keyword, name: 'import' },\n  LET: { klass: TC.Keyword, name: 'let' },\n  NEW: { klass: TC.Keyword, name: 'new' },\n  RETURN: { klass: TC.Keyword, name: 'return' },\n  SUPER: { klass: TC.Keyword, name: 'super' },\n  SWITCH: { klass: TC.Keyword, name: 'switch' },\n  THIS: { klass: TC.Keyword, name: 'this' },\n  THROW: { klass: TC.Keyword, name: 'throw' },\n  TRY: { klass: TC.Keyword, name: 'try' },\n  VAR: { klass: TC.Keyword, name: 'var' },\n  WHILE: { klass: TC.Keyword, name: 'while' },\n  WITH: { klass: TC.Keyword, name: 'with' },\n  NULL: { klass: TC.Keyword, name: 'null' },\n  TRUE: { klass: TC.Keyword, name: 'true' },\n  FALSE: { klass: TC.Keyword, name: 'false' },\n  YIELD: { klass: TC.Keyword, name: 'yield' },\n  NUMBER: { klass: TC.NumericLiteral, name: '' },\n  STRING: { klass: TC.StringLiteral, name: '' },\n  REGEXP: { klass: TC.RegularExpression, name: '' },\n  IDENTIFIER: { klass: TC.Ident, name: '' },\n  CONST: { klass: TC.Keyword, name: 'const' },\n  TEMPLATE: { klass: TC.TemplateElement, name: '' },\n  ILLEGAL: { klass: TC.Illegal, name: '' },\n};\n\nconst TT = TokenType;\n\nexport const punctuatorTable = {\n  '(': TT.LPAREN,\n  ')': TT.RPAREN,\n  '[': TT.LBRACK,\n  ']': TT.RBRACK,\n  '{': TT.LBRACE,\n  '}': TT.RBRACE,\n  ':': TT.COLON,\n  ';': TT.SEMICOLON,\n  '.': TT.PERIOD,\n  '...': TT.ELLIPSIS,\n  '=>': TT.ARROW,\n  '?': TT.CONDITIONAL,\n  '++': TT.INC,\n  '--': TT.DEC,\n  '=': TT.ASSIGN,\n  '|=': TT.ASSIGN_BIT_OR,\n  '^=': TT.ASSIGN_BIT_XOR,\n  '&=': TT.ASSIGN_BIT_AND,\n  '<<=': TT.ASSIGN_SHL,\n  '>>=': TT.ASSIGN_SHR,\n  '>>>=': TT.ASSIGN_SHR_UNSIGNED,\n  '+=': TT.ASSIGN_ADD,\n  '-=': TT.ASSIGN_SUB,\n  '*=': TT.ASSIGN_MUL,\n  '/=': TT.ASSIGN_DIV,\n  '%=': TT.ASSIGN_MOD,\n  '**=': TT.ASSIGN_EXP,\n  ',': TT.COMMA,\n  '||': TT.OR,\n  '&&': TT.AND,\n  '|': TT.BIT_OR,\n  '&': TT.BIT_AND,\n  '^': TT.BIT_XOR,\n  '<<': TT.SHL,\n  '>>': TT.SHR,\n  '>>>': TT.SHR_UNSIGNED,\n  '+': TT.ADD,\n  '-': TT.SUB,\n  '*': TT.MUL,\n  '/': TT.DIV,\n  '%': TT.MOD,\n  '**': TT.EXP,\n  '==': TT.EQ,\n  '!=': TT.NE,\n  '===': TT.EQ_STRICT,\n  '!==': TT.NE_STRICT,\n  '<': TT.LT,\n  '>': TT.GT,\n  '<=': TT.LTE,\n  '>=': TT.GTE,\n  '!': TT.NOT,\n  '~': TT.BIT_NOT,\n};\n\nexport const keywordTable = {\n  // 'await': TT.AWAIT, TODO: uncomment when new version of shift is used\n  // TODO: add 'async'\n  break: TT.BREAK,\n  case: TT.CASE,\n  catch: TT.CATCH,\n  class: TT.CLASS,\n  const: TT.CONST,\n  continue: TT.CONTINUE,\n  delete: TT.DELETE,\n  debugger: TT.DEBUGGER,\n  default: TT.DEFAULT,\n  do: TT.DO,\n  else: TT.ELSE,\n  export: TT.EXPORT,\n  extends: TT.EXTENDS,\n  false: TT.FALSE,\n  finally: TT.FINALLY,\n  for: TT.FOR,\n  function: TT.FUNCTION,\n  if: TT.IF,\n  import: TT.IMPORT,\n  in: TT.IN,\n  instanceof: TT.INSTANCEOF,\n  let: TT.LET,\n  new: TT.NEW,\n  null: TT.NULL,\n  return: TT.RETURN,\n  super: TT.SUPER,\n  switch: TT.SWITCH,\n  this: TT.THIS,\n  throw: TT.THROW,\n  true: TT.TRUE,\n  try: TT.TRY,\n  typeof: TT.TYPEOF,\n  var: TT.VAR,\n  void: TT.VOID,\n  while: TT.WHILE,\n  with: TT.WITH,\n  yield: TT.YIELD,\n};\n\nexport const EmptyToken = {};\n\nexport type StartLocation = {\n  line: number,\n  column: number,\n  filename: string,\n  position: number,\n};\n\nexport type Slice = {\n  text: string,\n  start: number,\n  startLocation: StartLocation,\n  end: number,\n};\n\ntype TokenTypeType = {\n  klass: { name: string, isIdentifierName?: boolean },\n  name: string,\n};\n\nfunction hasType(x: any, type?: {}) {\n  if (type) {\n    return x && typeof x.type === 'object' && x.type === type;\n  }\n  return x && typeof x.type === 'object';\n}\n\nfunction hasKlass(x: any, klass?: {}) {\n  if (klass) {\n    return hasType(x) && x.type.klass === klass;\n  }\n  return hasType(x) && typeof x.type.klass === 'object';\n}\n\nclass BaseToken {\n  typeCode: number;\n  type: TokenTypeType;\n  value: ?string | ?number;\n  slice: ?Slice;\n\n  constructor({\n    typeCode,\n    type,\n    value,\n    slice,\n  }: {\n    typeCode: number,\n    type: TokenTypeType,\n    value?: string | number,\n    slice?: Slice,\n  }) {\n    this.typeCode = typeCode;\n    this.type = type;\n    this.value = value;\n    this.slice = slice;\n  }\n}\n\nexport function isString(x: any, value?: string) {\n  let r = hasType(x, TT.STRING);\n  if (value != null) {\n    return r && x.str === value;\n  }\n  return r;\n}\n\nexport class StringToken {\n  type: TokenTypeType;\n  str: string;\n  octal: ?string;\n  slice: ?Slice;\n  typeCode: number;\n  constructor({\n    str,\n    octal,\n    slice,\n  }: { str: string, octal: ?string, slice?: Slice }) {\n    this.type = TT.STRING;\n    this.typeCode = TypeCodes.StringLiteral;\n    this.str = str;\n    this.octal = octal;\n    this.slice = slice;\n  }\n}\n\nexport const TypeCodes = {\n  Identifier: 0,\n  Keyword: 1,\n  Punctuator: 2,\n  NumericLiteral: 3,\n  StringLiteral: 4,\n  TemplateElement: 5,\n  Template: 6,\n  RegExp: 7,\n};\n\nexport function isIdentifier(x: any, value?: string) {\n  let r = hasType(x, TT.IDENTIFIER);\n  if (value != null) {\n    return r && x.value === value;\n  }\n  return r;\n}\n\nexport class IdentifierToken extends BaseToken {\n  constructor({ value, slice }: { value: string, slice?: Slice }) {\n    super({\n      typeCode: TypeCodes.Identifier,\n      type: TT.IDENTIFIER,\n      value,\n      slice,\n    });\n  }\n}\n\nexport function isKeyword(x: any, value?: string | string[]) {\n  let r = hasKlass(x, TC.Keyword);\n  if (value != null) {\n    if (typeof value === 'string') {\n      return r && x.value === value;\n    } else if (typeof value.some === 'function') {\n      return value.some(v => v === x.value);\n    }\n  }\n  return r;\n}\n\nexport class KeywordToken extends BaseToken {\n  constructor({ value, slice }: { value: string, slice?: Slice }) {\n    super({\n      typeCode: TypeCodes.Keyword,\n      type: keywordTable[value],\n      value,\n      slice,\n    });\n  }\n}\n\nexport function isPunctuator(x: any, value?: string) {\n  let r = hasKlass(x, TC.Punctuator);\n  if (value != null) {\n    return r && x.value === value;\n  }\n  return r;\n}\nexport class PunctuatorToken extends BaseToken {\n  constructor({ value, slice }: { value: string, slice?: Slice }) {\n    super({\n      typeCode: TypeCodes.Punctuator,\n      type: punctuatorTable[value],\n      value,\n      slice,\n    });\n  }\n}\n\nexport function isNumeric(x: any, value?: number) {\n  let r = hasType(x, TT.NUMBER);\n  if (value != null) {\n    return r && x.value === value;\n  }\n  return r;\n}\nexport class NumericToken extends BaseToken {\n  octal: boolean;\n  noctal: boolean;\n\n  constructor({\n    value,\n    octal = false,\n    noctal = false,\n    slice,\n  }: { value: number, octal?: boolean, noctal?: boolean, slice?: Slice }) {\n    super({\n      typeCode: TypeCodes.NumericLiteral,\n      type: TT.NUMBER,\n      value,\n      slice,\n    });\n    this.octal = octal;\n    this.noctal = noctal;\n  }\n}\n\nexport function isTemplateElement(x: any, value?: string) {\n  let r = hasType(x, TT.TEMPLATE) && x.items == null;\n  if (value != null) {\n    return r && x.value === value;\n  }\n  return r;\n}\n\nexport class TemplateElementToken extends BaseToken {\n  tail: boolean;\n  interp: boolean;\n\n  constructor({\n    value,\n    tail,\n    interp,\n    slice,\n  }: { value: string, tail: boolean, interp: boolean, slice?: Slice }) {\n    super({\n      type: TT.TEMPLATE,\n      typeCode: TypeCodes.TemplateElement,\n      value,\n      slice,\n    });\n    this.tail = tail;\n    this.interp = interp;\n  }\n}\n\nexport function isTemplate(x: any) {\n  return hasType(x, TT.TEMPLATE) && x.items != null;\n}\nexport class TemplateToken extends BaseToken {\n  items: List<Token>;\n\n  constructor({ items, slice }: { items: List<Token>, slice?: Slice }) {\n    super({ type: TT.TEMPLATE, typeCode: TypeCodes.Template, slice });\n    this.items = items;\n  }\n}\n\nexport function isRegExp(x: any, value?: string) {\n  let r = hasType(x, TT.REGEXP);\n  if (value != null) {\n    return r && x.value === value;\n  }\n  return r;\n}\nexport class RegExpToken extends BaseToken {\n  constructor({ value, slice }: { value: string, slice?: Slice }) {\n    super({ type: TT.REGEXP, typeCode: TypeCodes.RegExp, value, slice });\n  }\n}\n\nconst isDelimiterType = (x, type) => {\n  if (x && x[Symbol.iterator] && ([x] = x)) {\n    return x && hasType(x, type);\n  }\n  return false;\n};\n\nexport const isParens = (x: any) => isDelimiterType(x, TT.LPAREN);\nexport const isBraces = (x: any) => isDelimiterType(x, TT.LBRACE);\nexport const isBrackets = (x: any) => isDelimiterType(x, TT.LBRACK);\nexport const isSyntaxTemplate = (x: any) => isDelimiterType(x, TT.LSYNTAX);\n\nexport const isDelimiter = (x: any) =>\n  isParens(x) || isBraces(x) || isBrackets(x) || isSyntaxTemplate(x);\n\nexport function getKind(x: List<TokenTree>) {\n  return isParens(x)\n    ? 'parens'\n    : isBraces(x)\n        ? 'braces'\n        : isBrackets(x)\n            ? 'brackets'\n            : isSyntaxTemplate(x) ? 'syntaxTemplate' : '';\n}\n\nexport function getLineNumber(t: any) {\n  if (t.slice && t.slice.startLocation) {\n    return t.slice.startLocation.line;\n  } else if (t[Symbol.iterator] && ([t] = t)) {\n    return getLineNumber(t);\n  }\n  return null;\n}\n\nexport type Token =\n  | StringToken\n  | IdentifierToken\n  | KeywordToken\n  | PunctuatorToken\n  | NumericToken\n  | TemplateElementToken\n  | TemplateToken\n  | RegExpToken;\nexport type TokenTree = Token | List<TokenTree>;\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/transforms.js":"// @flow\nimport SweetModule from './sweet-module';\nimport Syntax from './syntax';\n\nexport class FunctionDeclTransform {}\nexport class VariableDeclTransform {}\nexport class NewTransform {}\nexport class ThrowTransform {}\nexport class LetDeclTransform {}\nexport class ConstDeclTransform {}\nexport class TryTransform {}\nexport class WhileTransform {}\nexport class IfTransform {}\nexport class ForTransform {}\nexport class SwitchTransform {}\nexport class BreakTransform {}\nexport class ContinueTransform {}\nexport class DoTransform {}\nexport class WithTransform {}\nexport class ImportTransform {}\nexport class ExportTransform {}\nexport class SuperTransform {}\nexport class YieldTransform {}\nexport class ThisTransform {}\nexport class ClassTransform {}\nexport class DefaultTransform {}\nexport class DebuggerTransform {}\nexport class SyntaxrecDeclTransform {}\nexport class SyntaxDeclTransform {}\nexport class OperatorDeclTransform {}\nexport class ReturnStatementTransform {}\nexport class ModuleNamespaceTransform {\n  namespace: Syntax;\n  mod: SweetModule;\n\n  constructor(namespace: Syntax, mod: SweetModule) {\n    this.namespace = namespace;\n    this.mod = mod;\n  }\n}\nexport class VarBindingTransform {\n  id: Syntax;\n\n  constructor(id: Syntax) {\n    this.id = id;\n  }\n}\nexport class CompiletimeTransform {\n  value: any;\n\n  constructor(value: any) {\n    this.value = value;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/editor.js":"(function(global, requirejs, require) {\n\nvar storage_code  = \"editor_code\",\n    storage_mode  = \"editor_mode\",\n    slice  = Array.prototype.slice,\n    concat = Array.prototype.concat,\n    push   = Array.prototype.push;\n\nrequirejs.config({\n    shim: {\n        'underscore': {\n            exports: '_'\n        }\n    }\n});\n\nrequire([\"./sweet\", \"./source-map\", 'underscore', \"./rx.jquery.min\", \"text!./helpers.js\", \"./rx.dom.compat.min\"], function (sweet,  srcmap, _, Rx, helpers) {\n\nsrcmap = srcmap || sourceMap;\n/**\n* Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.\n* @param {Function} resourceFactory Factory function to obtain a resource object.\n* @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.\n* @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.\n*/\nRx.Observable.using = function (resourceFactory, observableFactory) {\n    return Rx.Observable.create(function (observer) {\n        var disposable = Rx.Disposable.empty, resource, source;\n        try {\n            resource = resourceFactory();\n            resource && (disposable = resource);\n            source = observableFactory(resource);\n        } catch (exception) {\n            return new Rx.CompositeDisposable(Rx.Observable.throw(exception).subscribe(observer), disposable);\n        }\n        return new Rx.CompositeDisposable(source.subscribe(observer), disposable);\n    });\n};\n\nvar documentReadyObs = $(window).readyAsObservable().take(1).publishLast(),\n    windowResizeObs  = $(window).resizeAsObservable().startWith(true),\n\n    initEditorObs = documentReadyObs\n        .map(_.partial($, \"#editor\", undefined))\n        .map(_.partial(initEditor, getEditorOptions))\n        .map(initEditorKeyMap),\n\n    initOutputObs = documentReadyObs\n        .map(_.partial($, \"#output\", undefined))\n        .map(_.partial(initEditor, getOutputOptions)),\n\n    // Initialize both CodeMirror instances on document\n    // ready, then select them into a list together.\n    mirrors = initEditorObs.zip(initOutputObs, concat.bind([])).publish(),\n\n    keyMapSelector = _.partial(selectKeyMapClicks, $('#btn-vim'), $('#btn-emacs'), $('#btn-default')),\n    mirrorDragSelector = _.partial(selectMirrorDrags, $(\"#edit-box\")),\n    commitResizes = _.partial(commitMirrorResizes, $(\"#edit-box\"), $(\"#error-box\"), $(\"#output-box\")),\n\n    errorRecoverySelector = _.partial(\n        recoverFromError,\n        $(\"#edit-box\"),\n        $(\"#error-box\"),\n        $(\"#error-text\"),\n        $(\"#show-error-line\")\n    ),\n    compileTypeSelector = _.partial(\n        selectCompileType,\n        $(\"#ck-auto-compile\"),\n        $(\"#ck-readable-names\"),\n        $(\"#ck-highlighting\"),\n        $(\"#input-step-label\"),\n        $(\"#input-step\"),\n        $(\"#btn-compile\"),\n        errorRecoverySelector\n    ),\n    commitOutput = _.partial(commitEditorOutput, $(\"#edit-box\"), $(\"#error-box\"));\n\n// Select the keyMap button clicks into their\n// keyMap values, then commit them in the editor.\nmirrors\n    .flatMapLatest(applyArgs(keyMapSelector))\n    .subscribe(applyArgs(commitKeyMap));\n\nmirrors\n    .flatMapLatest(applyArgs(_.partial(selectEvalClicks, $(\"#btn-eval\"))))\n    .subscribe(safeEvalOutput);\n\nmirrors\n    // Combine the codeMirror instances with each window resize event.\n    .combineLatest(windowResizeObs, concat.bind([]))\n    // select each codeMirror/resize event pair into a mouse drag Observable.\n    .flatMapLatest(applyArgs(mirrorDragSelector))\n    // Set the size of the editor and output boxes to the latest drag result.\n    .subscribe(applyArgs(commitResizes));\n\nmirrors\n    // Combine the event sources that can cause us to\n    // compile the editor contents. When the user compiles,\n    // handle errors internally so they don't surface later.\n    // Forward on the compilation result.\n    .flatMapLatest(applyArgs(compileTypeSelector))\n    // When we successfully compile the source, forward\n    // on the editor's \"cursorActivity\" events.\n    .flatMapLatest(applyArgs(selectCursorPosition))\n    // Write the results of the compilation into the output window\n    .doAction(applyArgs(commitOutput))\n    // If we compiled with macro highlighting, cross-\n    // reference the cursor position with the matched\n    // macro syntaxes and onNext tuples of [codeMirror, [highlight]]\n    .flatMap(applyArgs(selectEditorHightlights))\n    // Apply the highlights for each codeMirror instance\n    // as CodeMirror overlays.\n    .subscribe(applyArgs(commitHighlights));\n\n// macrofication\nvar candidates = mirrors.flatMap(editorChange).\n    combineLatest(ckMacrofy(), concat.bind([])).\n    map(applyArgs(macroCandidates));\n\n// highlight macro candidates\ncandidates.\n    subscribe(applyArgs(commitHighlights));\n\n// popup dialog on macro candidate\ncandidates.\n    combineLatest(mirrors.flatMap(editorCursor), concat.bind([])).\n    flatMap(applyArgs(selectMacroficationHighlight)).\n    debounce(100).\n    subscribe(applyArgs(popupMacrofication));\n\nreturn mirrors.connect() && documentReadyObs.connect();\n\nfunction applyArgs(f, x) {\n    return function(a) {\n        return f.apply(x, a);\n    };\n}\n\nfunction selectKeyMapClicks(vim, emacs, defaultBtn, editor) {\n    return Rx.Observable.empty()\n        .merge(vim\n            .clickAsObservable()\n            .map(Rx.helpers.just(\"vim\")))\n        .merge(emacs\n            .clickAsObservable()\n            .map(Rx.helpers.just(\"emacs\")))\n        .merge(defaultBtn\n            .clickAsObservable()\n            .map(Rx.helpers.just(\"default\")))\n        .map(concat.bind([editor]));\n}\n\nfunction commitKeyMap(editor, keyMap) {\n    localStorage[storage_mode] = keyMap;\n    editor.setOption(\"keyMap\", keyMap);\n    editor.focus();\n}\n\nfunction selectEvalClicks(btnEval, editor, output) {\n    return btnEval.clickAsObservable().map(output.getValue.bind(output, undefined));\n}\n\nfunction safeEvalOutput(code) {\n    try {\n        eval(code);\n    } catch(e) {\n        console.error(e && e.stack || e);\n    }\n}\n\nfunction selectMirrorDrags(editBox, editor, output, resizeEvent) {\n\n    var windowWidth = $(window).width(),\n        editorGutter = $(editor.getGutterElement()),\n        resizeGutter = $(output.getGutterElement()).css({ \"cursor\": \"ew-resize\" }),\n        leftGutterWidth = editorGutter.outerWidth(),\n        rightGutterWidth = resizeGutter.outerWidth(),\n        downObs = resizeGutter.mousedownAsObservable(),\n        moveObs = $(window).mousemoveAsObservable(),\n        upObs = $(window).mouseupAsObservable();\n\n    // project each mousedown event into a series of future mousemove events.\n    return downObs.flatMap(function (downEvent) {\n            var editorWidth = editBox.outerWidth();\n            leftGutterWidth = editorGutter.outerWidth();\n            rightGutterWidth = resizeGutter.outerWidth();\n\n            // project each mousemove event into an editorWidth integer\n            return moveObs.map(function (moveEvent) {\n                    return editorWidth + (moveEvent.pageX - downEvent.pageX);\n                })\n                // stop listening to mousemoves when we receive a mouseup\n                .takeUntil(upObs);\n        })\n        // don't update the DOM between browser repaints\n        .debounce(0, Rx.Scheduler.requestAnimationFrameScheduler)\n        .startWith(editBox.outerWidth())\n        .map(function (codeAreaWidth) {\n            return [editor, output, {\n                editBoxWidth: Math.max(Math.min(codeAreaWidth, windowWidth - leftGutterWidth), leftGutterWidth),\n                outputBoxLeft: Math.max(Math.min(codeAreaWidth, windowWidth - leftGutterWidth), leftGutterWidth),\n                editBoxRight: Math.min(Math.max(windowWidth - codeAreaWidth, rightGutterWidth), windowWidth - rightGutterWidth),\n                outputBoxWidth: Math.min(Math.max(windowWidth - codeAreaWidth, rightGutterWidth), windowWidth - rightGutterWidth),\n            }];\n        });\n}\n\nfunction commitMirrorResizes(editBox, errorsBox, outputBox, editor, output, coords) {\n    editBox.css(\"right\", coords.editBoxRight + \"px\");\n    errorsBox.css(\"right\", coords.editBoxRight + \"px\");\n    outputBox.css(\"left\", coords.outputBoxLeft + \"px\");\n    editor.setSize(coords.editBoxWidth, null);\n    output.setSize(coords.outputBoxWidth, null);\n}\n\nfunction initEditor(getOptions, $editor) {\n    var options = getOptions($editor),\n        initial = options.value,\n        compile = options.initialCompile,\n        editor  = CodeMirror.fromTextArea($editor[0], options);\n    if(initial) { editor.setValue(initial); }\n    if(compile) { editor.initialCompile = compile; }\n    return editor;\n}\n\nfunction initEditorKeyMap(editor) {\n    if(localStorage[storage_mode]) {\n        editor.setOption(\"keyMap\", localStorage[storage_mode]);\n    }\n    return editor;\n}\n\nfunction getEditorOptions($editor) {\n    var starting_code, initial_code = $editor.text();\n    if(window.location.hash) {\n        starting_code = decodeURI(window.location.hash.slice(1));\n    } else if(localStorage[storage_code]) {\n        starting_code = localStorage[storage_code];\n    } else {\n        starting_code = initial_code;\n    }\n    return {\n        initialCompile: starting_code === initial_code,\n        lineNumbers: true,\n        smartIndent: false,\n        indentWithTabs: false,\n        tabSize: 4,\n        indentUnit: 4,\n        autofocus: true,\n        theme: 'solarized dark',\n        showCursorWhenSelecting: true,\n        value: starting_code,\n        extraKeys: {\n            Tab: function (cm) {\n                if (cm.somethingSelected()) {\n                    return cm.indentSelection(\"add\");\n                } else if (cm.options.indentWithTabs) {\n                    return cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n                } else {\n                    return cm.execCommand(\"insertSoftTab\");\n                }\n            },\n            Left: function (cm) {\n                return cm.setSelections(cm.listSelections().map(function (selection) {\n                    selection = cm.somethingSelected() && ((\n                            selection.anchor.ch <= selection.head.ch) && (\n                            selection.anchor.line <= selection.head.line) &&\n                        selection.anchor || selection.head) || nextCursorPos(-1, 0, cm, selection.anchor).cursor;\n                    return {\n                        anchor: selection,\n                        head: selection\n                    };\n                }));\n            },\n            Right: function (cm) {\n                return cm.setSelections(cm.listSelections().map(function (selection) {\n                    selection = cm.somethingSelected() && ((\n                            selection.anchor.ch <= selection.head.ch) && (\n                            selection.anchor.line <= selection.head.line) &&\n                        selection.head || selection.anchor) || nextCursorPos(1, 0, cm, selection.anchor).cursor;\n                    return {\n                        anchor: selection,\n                        head: selection\n                    };\n                }));\n            },\n            Backspace: function (cm) {\n                var selected = cm.somethingSelected(),\n                    coords;\n                return cm.setSelections(cm.listSelections().map(function (selection) {\n                    coords = selected ? {\n                        left: selection.anchor,\n                        right: selection.head,\n                        cursor: ((\n                                selection.anchor.ch <= selection.head.ch) && (\n                                selection.anchor.line <= selection.head.line) &&\n                            selection.anchor || selection.head)\n                    } : nextCursorPos(-1, 1, cm, selection.anchor);\n                    cm.replaceRange(\"\", coords.left, coords.right, cm.getRange(coords.left, coords.right));\n                    return {\n                        anchor: coords.cursor,\n                        head: coords.cursor\n                    };\n                }));\n            }\n        }\n    };\n\n    function nextCursorPos(dir, tabStop, cm, position) {\n\n        // 0 if dir == -1, else 1\n        var rightOffset = Number(Boolean(~dir));\n        // 0 if dir == !1, else -1\n        var leftOffset = -1 * Number(Boolean(dir - 1));\n\n        var line = position.line;\n        var ch = position.ch;\n        var content = cm.getLine(line);\n\n        var hBound = ~dir ? content.length - ch : ch;\n        var vBound = rightOffset * (cm.lineCount() - 1);\n        var unit = cm.options.indentUnit;\n        var tabSpaces = Array(cm.options.tabSize + 1).join(\" \");\n        var range, left, right, cursor;\n\n        // Is there enough room to jump over a tab-width of spaces?\n        if (hBound < unit) {\n            // should we jump lines?\n            if (hBound === 0) {\n                // Are we on the top or bottom line?\n                if (line === vBound) {\n                    left = position;\n                    right = position;\n                    cursor = position;\n                } else {\n                    // jump to the next/previous line\n                    content = cm.getLine(line + dir);\n                    left = {\n                        line: line + (rightOffset - 1),\n                        ch: (content.length * leftOffset * -1) + (ch * rightOffset)\n                    };\n                    right = {\n                        line: line + rightOffset,\n                        ch: 0\n                    };\n                    cursor = rightOffset && right || left;\n                }\n            } else {\n                // jump one space left or right\n                left = {\n                    line: line,\n                    ch: ch + leftOffset\n                };\n                right = {\n                    line: line,\n                    ch: ch + rightOffset\n                };\n                cursor = rightOffset && right || left;\n            }\n        } else {\n            left = {\n                line: line,\n                ch: ch + ((((ch % unit) || unit) * tabStop) * leftOffset)\n            };\n            right = {\n                line: line,\n                ch: ch + ((((ch % unit) || unit) * tabStop) * rightOffset)\n            };\n            range = cm.getRange(left, right);\n            // is the range to the left/right up to a tab's width of spaces?\n            if (range !== tabSpaces) {\n                // no, only jump one space left/right\n                left = {\n                    line: line,\n                    ch: ch + leftOffset\n                };\n                right = {\n                    line: line,\n                    ch: ch + rightOffset\n                };\n                cursor = rightOffset && right || left;\n            } else {\n                tabStop *= -1;\n                left.ch = ch + ((ch % unit) * tabStop) + (unit * leftOffset);\n                right.ch = ch + ((ch % unit) * tabStop) + (unit * rightOffset);\n                cursor = {\n                    line: line,\n                    ch: ch + (unit * dir)\n                };\n            }\n        }\n        return {\n            left: left,\n            right: right,\n            cursor: cursor\n        };\n    }\n}\n\nfunction getOutputOptions() {\n    return {\n        lineNumbers: true,\n        theme: 'solarized dark',\n        readOnly: true\n    };\n}\n\nfunction selectCompileType(\n        autoCompile, readableNames, highlight,\n        stepLabel, stepper,\n        compileMacrosBtn,\n        errorRecoverySelector,\n        editor, output\n    ) {\n\n    var compileButtonObs    = compileMacrosBtn\n            .clickAsObservable()\n            .doAction(stepper.val.bind(stepper, 0))\n            .publish(),\n        lastCompileType     = \"full\",\n        initialCompile      = editor.initialCompile,\n        compileChangeSubj   = new Rx.Subject(),\n        compileChangeObs    = Rx.Observable.defer(function() {\n            return autoCompile\n                .changeAsObservable()\n                // Select each change event into a Boolean that flips on each click.\n                .scan(autoCompile.is(\":checked\"), Rx.helpers.not)\n                .startWith(autoCompile.is(\":checked\"));\n        })\n        .multicast(compileChangeSubj).refCount(),\n\n        namesChangeObs      = Rx.Observable.defer(function() {\n            return readableNames\n                .changeAsObservable()\n                .scan(readableNames.is(\":checked\"), Rx.helpers.not)\n                .startWith(readableNames.is(\":checked\"));\n        }),\n\n        reverseChangeObs      = Rx.Observable.defer(function() {\n            return readableNames\n                .changeAsObservable()\n                .scan(readableNames.is(\":checked\"), Rx.helpers.not)\n                .startWith(readableNames.is(\":checked\"));\n        }),\n\n        highlightChangeObs  = Rx.Observable.defer(function() {\n            return highlight\n                .changeAsObservable()\n                .scan(highlight.is(\":checked\"), Rx.helpers.not)\n                .doAction(function(checked) {\n                    if(checked === true) {\n                        autoCompile.prop(\"checked\", checked);\n                        compileChangeSubj.onNext(checked);\n                    }\n                })\n                .startWith(highlight.is(\":checked\"));\n        })\n        .publish().refCount(),\n\n        editorChangeObs   = Rx.Observable.defer(function() {\n\n            var changeEventObs = Rx.Observable.fromEvent(editor, \"change\");\n\n            if(initialCompile === true) {\n                initialCompile = false;\n                changeEventObs = changeEventObs\n                    .pausable(compileChangeObs)\n                    .debounce(750)\n                    .startWith(0);\n            } else {\n                changeEventObs = changeEventObs\n                    .debounce(750)\n                    .startWith(0)\n                    .pausable(compileChangeObs);\n\n                if(!startWithInitialValue(\"full\")) {\n                    changeEventObs = changeEventObs.merge(highlightChangeObs);\n                }\n            }\n\n            return changeEventObs.map(_.bind(editor.getCursor, editor));\n        }),\n\n        stepLabelClicks = Rx.Observable.defer(function() {\n\n            var clickEventObs = stepLabel.clickAsObservable();\n\n            if(startWithInitialValue(\"partial\")) {\n                clickEventObs = clickEventObs.startWith(0);\n            }\n\n            return clickEventObs.map(function(val) {\n                return stepper.\n                    val(val = Math.max(parseInt(stepper.val()) || 0, 0) + 1) &&\n                    val || val;\n            });\n        }),\n\n        stepperChanges = stepper\n            .changeAsObservable()\n            .map(function(val) {\n                return (val = Math.max(parseInt(stepper.val()) || 0, 1)) &&\n                    stepper.val(val) && val || val;\n            }),\n\n        compileFullBtnObs = compileButtonObs.map(getFullValues),\n\n        compileFullEvents = namesChangeObs\n            .combineLatest(\n                highlightChangeObs,\n                editorChangeObs,\n                concat.bind([])\n            )\n            .merge(compileFullBtnObs)\n            .doAction(saveCompileType(\"full\"))\n            .map(concat.bind([editor, output]))\n            .map(applyArgs(compileFull)),\n\n        compilePartialEvents = stepLabelClicks\n            .merge(stepperChanges)\n            .combineLatest(namesChangeObs, concat.bind([]))\n            .doAction(saveCompileType(\"partial\"))\n            .map(concat.bind([editor, output]))\n            .map(applyArgs(compilePartial));\n\n    return Rx.Observable.using(\n        function() { return compileButtonObs.connect(); },\n        function() {\n            return compileFullEvents\n                .merge(compilePartialEvents)\n                .switchLatest()\n                .catchException(function(err) {\n                    return Rx.Observable.throwException(err)\n                        .startWith([editor, output, false, {}]);\n                })\n                .retryWhen(function(errors) {\n                    return errors.flatMapLatest(function(error) {\n                        return errorRecoverySelector(editor, stepLabel, stepper, compileButtonObs, error);\n                    });\n                });\n        });\n\n    function saveCompileType(type) {\n        return function() {\n            lastCompileType = type;\n        };\n    }\n\n    function startWithInitialValue(type) {\n        return lastCompileType === type && (\n            autoCompile.is(\":checked\") || (\n            initialCompile && !(initialCompile = false)));\n    }\n\n    function getFullValues() {\n        return [\n            readableNames.is(\":checked\"),\n            highlight.is(\":checked\"),\n            editor.getCursor()\n        ];\n    }\n}\n\nfunction compileFull(editor, output, readableNames, highlight, cursor) {\n    return Rx.Observable.create(function(observer) {\n\n        var code = editor.getValue(), result;\n\n        window.location = \"editor.html#\" + encodeURI(code);\n        localStorage[storage_code] = code;\n\n        observer.onNext([\n            editor, output, highlight,\n            sweet.compile(code, helpers)\n          ]);\n        observer.onCompleted();\n    });\n}\n\nfunction compilePartial(editor, output, currentStep, readableNames) {\n    return Rx.Observable.create(function(observer) {\n\n        var code = editor.getValue(),\n            unparsedStr = syn.prettyPrint(sweet.expand(\n                code, undefined,\n                { maxExpands: currentStep }\n            ), !readableNames);\n\n        observer.onNext([\n            editor, output, false,\n            { code: unparsedStr }\n        ]);\n        observer.onCompleted();\n    });\n}\n\nfunction recoverFromError(\n    editBox, errorsBox, errorsText, showErrorBtn,\n    editor, stepLabel, stepper, compileMacrosObs,\n    error) {\n\n    errorsBox.css(\"height\", \"65px\");\n    editBox.css(\"top\", \"130px\");\n    errorsText.text(error);\n\n    return showErrorBtn\n        .clickAsObservable()\n        .doAction(_.partial(highlightError, editor, error))\n        .ignoreElements()\n        .merge(compileMacrosObs)\n        .merge(stepLabel.clickAsObservable())\n        .merge(stepper.changeAsObservable())\n        .merge(Rx.Observable.fromEvent(editor, \"change\"))\n        .take(1);\n}\n\nfunction highlightError(editor, error) {\n    error = {\n        line: error.lineNumber - 1,\n        ch: error.column\n    };\n    editor.scrollIntoView({\n        from: error,\n        to: error\n    }, 100);\n    editor.setCursor(error);\n    editor.focus();\n}\n\nfunction selectCursorPosition(editor, output, highlight, result) {\n    var obs = Rx.Observable.returnValue(undefined);\n    if(highlight === true) {\n        obs = Rx.Observable\n            .fromEvent(editor, \"cursorActivity\")\n            .startWith(0)\n            .map(_.bind(editor.getCursor, editor));\n    }\n    return obs.map(concat.bind([editor, output, result]));\n}\n\nfunction commitEditorOutput(editBox, errorsBox, editor, output, result, cursor) {\n    output.setValue(result.code || \"\");\n    errorsBox.css(\"height\", \"0px\");\n    editBox.css(\"top\", \"65px\");\n    editor.focus();\n}\n\nfunction selectEditorHightlights(editor, output, result, cursor) {\n\n    var logs      = result.log || [],\n        sourcemap = result.sourceMap || \"\",\n        macro     = _(logs).find(function(log) {\n            var nameCol = log.name.range[0] - log.name.lineStart;\n            return log.name.lineNumber == cursor.line + 1\n                && nameCol <= cursor.ch\n                && nameCol + log.name.value.length >= cursor.ch;\n        });\n\n    // only show macro highlights if cursor on macro name\n    if (!sourcemap || !macro || !logs.length) {\n        return [\n            [editor, \"macro\", []],\n            [output, \"macro\", []]\n        ];\n    }\n\n    var consumer   = new srcmap.SourceMapConsumer(sourcemap),\n        mappings   = [],\n        outHighlights,\n        srcHighlights = [\n                tokenToHighlight(macro.next, true),\n                tokenToHighlight(macro.name, false, true)\n            ].concat(macro.matchedTokens.map(tokenToHighlight));\n\n    consumer.eachMapping(function(mapping) { mappings.push(mapping); });\n\n    outHighlights = mappings.reduce(reduceMappingsToOutHighlights, [undefined, []]).pop();\n\n    return [\n        [editor, \"macro\", slice.call(srcHighlights, 1)],\n        [output, \"macro\", outHighlights]\n    ];\n\n    function reduceMappingsToOutHighlights(tuple, mapping) {\n\n        var prev = tuple[0], list = tuple[1], macro;\n\n        if(!!prev) {\n            prev.end = {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n            };\n        }\n\n        macro = _.any(srcHighlights, function(x) {\n            return (\n                mapping.originalLine > x.start.line || (\n                    mapping.originalLine === x.start.line &&\n                    mapping.originalColumn >= x.start.column)) && (\n                mapping.originalLine < x.end.line || (\n                    mapping.originalLine === x.end.line &&\n                    mapping.originalColumn < x.end.column));\n        });\n\n        if(!macro) {\n            prev = undefined;\n        } else if(!prev) {\n            list.push(prev = {\n                start: {\n                    line: mapping.generatedLine,\n                    column: mapping.generatedColumn\n                },\n                end: {\n                    line: mapping.generatedLine,\n                    column: mapping.generatedColumn\n                }\n            });\n        }\n\n        tuple[0] = prev;\n        tuple[1] = list;\n\n        return tuple;\n    }\n}\n\nfunction commitHighlights(editor, name, highlights) {\n    editor.removeOverlay(name);\n    if (highlights.length === 0) return;\n    highlights.sort(function(a, b) {\n        if (a.start.line < b.start.line) return -1;\n        if (a.start.line > b.start.line) return 1;\n        return a.start.column - b.start.column;\n    });\n    var line = 0, currentIdx = 0;\n    editor.addOverlay({\n        name: name,\n        token: function(stream) {\n            if (stream.sol()) line++;\n            if (currentIdx >= highlights.length) { // no more highlights\n                stream.skipToEnd();\n                return null;\n            }\n            var current = highlights[currentIdx];\n            if (current.start.line > line) { // no highlights on this line\n                stream.skipToEnd();\n                return null;\n            }\n            if (current.start.column > stream.pos) { // skip to highlight\n                stream.pos = current.start.column;\n                return null;\n            }\n            if (current.start.column < stream.pos) { // omit past highlight\n                currentIdx++;\n                return null;\n            }\n            // highlight current token\n            if (current.end.line == line && stream.pos < current.end.column) {\n                stream.pos = current.end.column;\n                currentIdx++;\n            } else if (current.end.line <= line) { // omit empty highlight\n                currentIdx++;\n            } else { // multi-line token -> move to next line\n                current.start.column = 0;\n                stream.skipToEnd();\n            }\n            return current.name ? name + \"-name\" : name;\n        },\n        blankLine: function() { line++; }\n    });\n}\n\nfunction editorChange(editors) {\n    return Rx.Observable.fromEvent(editors[0], \"change\").\n        debounce(750).\n        startWith(0).\n        map(function() { return editors[0]; });\n}\n\nfunction editorCursor(editors) {\n    return Rx.Observable.fromEvent(editors[0], \"cursorActivity\").\n        debounce(750).\n        map(function() { return editors[0].doc.getCursor(); });\n}\n\nfunction macroCandidates(editor, macrofy) {\n    var highlights = [];\n    if (macrofy) {\n        try {\n            var highlights = reverse.findReverseMatches(editor.getValue()).\n                map(function(match) {\n                    var start = useOriginalLoc(match.matchedTokens[0].token);\n                    var end = useOriginalLoc(_.last(match.matchedTokens).token);\n                    return {\n                        start: tokenToHighlight(start).start,\n                        end: tokenToHighlight(end).end,\n                        match: match\n                    }\n                });\n        } catch(e) { }\n    }\n    return [editor, \"candidate\", highlights];\n\n    function useOriginalLoc(token) {\n        var props = ['lineStart', 'lineNumber', 'range', 'startLineStart',\n            'startLineNumber', 'startRange', 'endLineStart',\n            'endLineNumber', 'endRange'];\n        var obj = _.clone(token);\n        for (var i = 0; i < props.length; i++) {\n            if (obj.hasOwnProperty('sm_' + props[i])) {\n                obj[props[i]] = obj['sm_' + props[i]];\n            }\n        }\n        return obj;\n    }\n}\n\nfunction tokenToHighlight(token, isStart, isName) {\n    var highlight = (token.type === parser.Token.Delimiter) ?\n        {\n            start: {\n                line: token.startLineNumber,\n                column: token.startRange[0] - token.startLineStart\n            },\n            end: {\n                line: token.endLineNumber,\n                column: token.endRange[1] - token.endLineStart\n            }\n        } :\n        {\n            start: {\n                line: token.lineNumber,\n                column: token.range[0] - token.lineStart\n            },\n            end: {\n                line: token.lineNumber,\n                column: token.range[1] - token.lineStart\n            }\n        };\n\n    if(isStart === true) {\n        highlight.end = highlight.start;\n    }\n    if(isName === true) {\n        highlight.name = true;\n    }\n    return highlight;\n}\n\nfunction ckMacrofy() {\n    var highlightMacrofy = $(\"#ck-macrofy\");\n    return highlightMacrofy\n        .changeAsObservable()\n        .scan(highlightMacrofy.is(\":checked\"), Rx.helpers.not)\n        .startWith(highlightMacrofy.is(\":checked\"))\n}\n\nfunction selectMacroficationHighlight(editor, name, highlights, cursor) {\n    $('.replace').hide('fast', function() { $(this).remove(); });\n    return highlights.\n        filter(function(highlight) {\n            return  (highlight.start.line < cursor.line + 1 ||\n                        (highlight.start.line === cursor.line + 1 &&\n                        highlight.start.column < cursor.ch)) &&\n                    (highlight.end.line > cursor.line + 1 ||\n                        (highlight.end.line === cursor.line + 1 &&\n                        highlight.end.column > cursor.ch)); }).\n        map(function(highlight) {\n            return [editor, highlight.match];\n        });\n}\n\nfunction popupMacrofication(editor, highlight) {\n    var coords = editor.cursorCoords();\n    var options = {\n        theme: 'solarized dark',\n        readOnly: 'nocursor',\n        lineNumbers: false,\n        scrollbarStyle: 'null'\n    };\n    var srcView = $('<textarea class=\"CodeMirror cm-s-solarized cm-s-dark\">' + highlight.replacement + '</textarea>');\n    $('<div class=\"replace\"></div>').\n        css('left', coords.left).\n        css('top', coords.top).\n        css('display', 'none').\n        append($('<span>Replace with macro?</span>')).\n        append(srcView).\n        click(function() {\n            editor.removeOverlay('candidates');\n            editor.setValue(highlight.replacedSrc);\n            $(this).hide('fast', function() { $(this).remove(); });\n        }).\n        appendTo('#edit-box').\n        show('fast');\n    _.defer(function() { CodeMirror.fromTextArea(srcView[0], options) });\n}\n\n});\n}(this, requirejs, require));\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/emacs.js":"(function() {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  function kill(cm, from, to, mayGrow, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, true))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, by, dir) {\n    var pos = cm.getCursor(), prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir) {\n    kill(cm, cm.getCursor(), findEnd(cm, by, dir), true);\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt, \"end\", \"+input\");\n    }\n  }\n\n  function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  function setMark(cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(true);\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(msg + \": <input type=\\\"text\\\" style=\\\"width: 10em\\\"/>\", f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Actual keymap\n\n  var keyMap = CodeMirror.keyMap.emacs = {\n    \"Ctrl-W\": function(cm) {kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"));},\n    \"Ctrl-K\": repeated(function(cm) {\n      var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n      var text = cm.getRange(start, end);\n      if (!/\\S/.test(text)) {\n        text += \"\\n\";\n        end = Pos(start.line + 1, 0);\n      }\n      kill(cm, start, end, true, text);\n    }),\n    \"Alt-W\": function(cm) {\n      addToRing(cm.getSelection());\n    },\n    \"Ctrl-Y\": function(cm) {\n      var start = cm.getCursor();\n      cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n      cm.setSelection(start, cm.getCursor());\n    },\n    \"Alt-Y\": function(cm) {cm.replaceSelection(popFromRing());},\n\n    \"Ctrl-Space\": setMark, \"Ctrl-Shift-2\": setMark,\n\n    \"Ctrl-F\": move(byChar, 1), \"Ctrl-B\": move(byChar, -1),\n    \"Right\": move(byChar, 1), \"Left\": move(byChar, -1),\n    \"Ctrl-D\": function(cm) { killTo(cm, byChar, 1); },\n    \"Delete\": function(cm) { killTo(cm, byChar, 1); },\n    \"Ctrl-H\": function(cm) { killTo(cm, byChar, -1); },\n    \"Backspace\": function(cm) { killTo(cm, byChar, -1); },\n\n    \"Alt-F\": move(byWord, 1), \"Alt-B\": move(byWord, -1),\n    \"Alt-D\": function(cm) { killTo(cm, byWord, 1); },\n    \"Alt-Backspace\": function(cm) { killTo(cm, byWord, -1); },\n\n    \"Ctrl-N\": move(byLine, 1), \"Ctrl-P\": move(byLine, -1),\n    \"Down\": move(byLine, 1), \"Up\": move(byLine, -1),\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStart\",\n\n    \"Alt-V\": move(byPage, -1), \"Ctrl-V\": move(byPage, 1),\n    \"PageUp\": move(byPage, -1), \"PageDown\": move(byPage, 1),\n\n    \"Ctrl-Up\": move(byParagraph, -1), \"Ctrl-Down\": move(byParagraph, 1),\n\n    \"Alt-A\": move(bySentence, -1), \"Alt-E\": move(bySentence, 1),\n    \"Alt-K\": function(cm) { killTo(cm, bySentence, 1); },\n\n    \"Ctrl-Alt-K\": function(cm) { killTo(cm, byExpr, 1); },\n    \"Ctrl-Alt-Backspace\": function(cm) { killTo(cm, byExpr, -1); },\n    \"Ctrl-Alt-F\": move(byExpr, 1), \"Ctrl-Alt-B\": move(byExpr, -1),\n\n    \"Shift-Ctrl-Alt-2\": function(cm) {\n      cm.setSelection(findEnd(cm, byExpr, 1), cm.getCursor());\n    },\n    \"Ctrl-Alt-T\": function(cm) {\n      var leftStart = byExpr(cm, cm.getCursor(), -1), leftEnd = byExpr(cm, leftStart, 1);\n      var rightEnd = byExpr(cm, leftEnd, 1), rightStart = byExpr(cm, rightEnd, -1);\n      cm.replaceRange(cm.getRange(rightStart, rightEnd) + cm.getRange(leftEnd, rightStart) +\n                      cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n    },\n    \"Ctrl-Alt-U\": repeated(toEnclosingExpr),\n\n    \"Alt-Space\": function(cm) {\n      var pos = cm.getCursor(), from = pos.ch, to = pos.ch, text = cm.getLine(pos.line);\n      while (from && /\\s/.test(text.charAt(from - 1))) --from;\n      while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n      cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n    },\n    \"Ctrl-O\": repeated(function(cm) { cm.replaceSelection(\"\\n\", \"start\"); }),\n    \"Ctrl-T\": repeated(function(cm) {\n      var pos = cm.getCursor();\n      if (pos.ch < cm.getLine(pos.line).length) pos = Pos(pos.line, pos.ch + 1);\n      var from = cm.findPosH(pos, -2, \"char\");\n      var range = cm.getRange(from, pos);\n      if (range.length != 2) return;\n      cm.setSelection(from, pos);\n      cm.replaceSelection(range.charAt(1) + range.charAt(0), \"end\");\n    }),\n\n    \"Alt-C\": repeated(function(cm) {\n      operateOnWord(cm, function(w) {\n        var letter = w.search(/\\w/);\n        if (letter == -1) return w;\n        return w.slice(0, letter) + w.charAt(letter).toUpperCase() + w.slice(letter + 1).toLowerCase();\n      });\n    }),\n    \"Alt-U\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toUpperCase(); });\n    }),\n    \"Alt-L\": repeated(function(cm) {\n      operateOnWord(cm, function(w) { return w.toLowerCase(); });\n    }),\n\n    \"Alt-;\": \"toggleComment\",\n\n    \"Ctrl-/\": repeated(\"undo\"), \"Shift-Ctrl--\": repeated(\"undo\"),\n    \"Ctrl-Z\": repeated(\"undo\"), \"Cmd-Z\": repeated(\"undo\"),\n    \"Shift-Alt-,\": \"goDocStart\", \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findNext\", \"Ctrl-R\": \"findPrev\", \"Ctrl-G\": \"clearSearch\", \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Ctrl-J\": \"newlineAndIndent\", \"Enter\": false, \"Tab\": \"indentAuto\",\n\n    \"Alt-G\": function(cm) {cm.setOption(\"keyMap\", \"emacs-Alt-G\");},\n    \"Ctrl-X\": function(cm) {cm.setOption(\"keyMap\", \"emacs-Ctrl-X\");},\n    \"Ctrl-Q\": function(cm) {cm.setOption(\"keyMap\", \"emacs-Ctrl-Q\");},\n    \"Ctrl-U\": addPrefixMap\n  };\n\n  CodeMirror.keyMap[\"emacs-Ctrl-X\"] = {\n    \"Tab\": function(cm) {\n      cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n    },\n    \"Ctrl-X\": function(cm) {\n      cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n    },\n\n    \"Ctrl-S\": \"save\", \"Ctrl-W\": \"save\", \"S\": \"saveAll\", \"F\": \"open\", \"U\": repeated(\"undo\"), \"K\": \"close\",\n    \"Delete\": function(cm) { kill(cm, cm.getCursor(), sentenceEnd(cm, 1), true); },\n    auto: \"emacs\", nofallthrough: true, disableInput: true\n  };\n\n  CodeMirror.keyMap[\"emacs-Alt-G\"] = {\n    \"G\": function(cm) {\n      var prefix = getPrefix(cm, true);\n      if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n      getInput(cm, \"Goto line\", function(str) {\n        var num;\n        if (str && !isNaN(num = Number(str)) && num == num|0 && num > 0)\n          cm.setCursor(num - 1);\n      });\n    },\n    auto: \"emacs\", nofallthrough: true, disableInput: true\n  };\n\n  CodeMirror.keyMap[\"emacs-Ctrl-Q\"] = {\n    \"Tab\": repeated(\"insertTab\"),\n    auto: \"emacs\", nofallthrough: true\n  };\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n})();\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/jquery.js":"/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */\n(function( window, undefined ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\"use strict\";\nvar\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// Support: IE9\n\t// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n\tcore_strundefined = typeof undefined,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tlocation = window.location,\n\tdocument = window.document,\n\tdocElem = document.documentElement,\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// [[Class]] -> type pairs\n\tclass2type = {},\n\n\t// List of deleted data cache ids, so we can reuse them\n\tcore_deletedIds = [],\n\n\tcore_version = \"2.0.3\",\n\n\t// Save a reference to some core methods\n\tcore_concat = core_deletedIds.concat,\n\tcore_push = core_deletedIds.push,\n\tcore_slice = core_deletedIds.slice,\n\tcore_indexOf = core_deletedIds.indexOf,\n\tcore_toString = class2type.toString,\n\tcore_hasOwn = class2type.hasOwnProperty,\n\tcore_trim = core_version.trim,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Used for matching numbers\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n\t// Used for splitting on whitespace\n\tcore_rnotwhite = /\\S+/g,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t},\n\n\t// The ready event handler and self cleanup method\n\tcompleted = function() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\t\tjQuery.ready();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: core_version,\n\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn core_slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: core_push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\tnoConflict: function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn String( obj );\n\t\t}\n\t\t// Support: Safari <= 5.1 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: Firefox <20\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n\t\ttry {\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!core_hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tparseHTML: function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\t\tif ( scripts ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t},\n\n\tparseJSON: JSON.parse,\n\n\t// Cross-browser xml parsing\n\tparseXML: function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE9\n\t\ttry {\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\ttrim: function( text ) {\n\t\treturn text == null ? \"\" : core_trim.call( text );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcore_push.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : core_indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar l = second.length,\n\t\t\ti = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof l === \"number\" ) {\n\t\t\tfor ( ; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar retVal,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn core_concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = core_slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlength = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t},\n\n\tnow: Date.now,\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\t// Note: this method belongs to the css module but it's needed here for the support module.\n\t// If support gets modularized, this method should be moved back to the css module.\n\tswap: function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || type !== \"function\" &&\n\t\t( length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n/*!\n * Sizzle CSS Selector Engine v1.9.4-pre\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-06-03\n */\n(function( window, undefined ) {\n\nvar i,\n\tsupport,\n\tcachedruns,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\toutermostContext,\n\tsortInput,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\thasDuplicate = false,\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trsibling = new RegExp( whitespace + \"*[+~]\" ),\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\t// BMP codepoint\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( documentIsHTML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect xml\n * @param {Element|Object} elem An element or a document\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar doc = node ? node.ownerDocument || node : preferredDoc,\n\t\tparent = doc.defaultView;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsHTML = !isXML( doc );\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent.attachEvent && parent !== parent.top ) {\n\t\tparent.attachEvent( \"onbeforeunload\", function() {\n\t\t\tsetDocument();\n\t\t});\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getElementsByClassName = assert(function( div ) {\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t// Support: Safari<4\n\t\t// Catch class over-caching\n\t\tdiv.firstChild.className = \"i\";\n\t\t// Support: Opera<10\n\t\t// Catch gEBCN failure to find non-leading classes\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t});\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\n\t\t\t// Support: Opera 10-12/IE8\n\t\t\t// ^= $= *= and empty values\n\t\t\t// Should not select anything\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type attribute is restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"t\", \"\" );\n\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = docElem.compareDocumentPosition ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\n\n\t\tif ( compare ) {\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === doc || contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t}\n\n\t\t// Not directly comparable, sort on existence of method\n\t\treturn a.compareDocumentPosition ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\t} else if ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val === undefined ?\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull :\n\t\tval;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\tfor ( ; (node = elem[i]); i++ ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (see #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] && match[4] !== undefined ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n\t\t\t//   not comment, processing instructions, or others\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n\t\t\t// use getAttribute instead to test this case\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( tokens = [] );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar data, cache, outerCache,\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\n\t\t\t\t\t\t\t\treturn data === true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t// A counter to specify which element is currently being matched\n\tvar matcherCachedRuns = 0,\n\t\tbySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tsetMatched = [],\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\toutermost = expandContext != null,\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\tcachedruns = matcherCachedRuns;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector )\n\t);\n\treturn results;\n}\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn (val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\telem[ name ] === true ? name.toLowerCase() : null;\n\t\t}\n\t});\n}\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})( window );\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\njQuery.support = (function( support ) {\n\tvar input = document.createElement(\"input\"),\n\t\tfragment = document.createDocumentFragment(),\n\t\tdiv = document.createElement(\"div\"),\n\t\tselect = document.createElement(\"select\"),\n\t\topt = select.appendChild( document.createElement(\"option\") );\n\n\t// Finish early in limited environments\n\tif ( !input.type ) {\n\t\treturn support;\n\t}\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Must access the parent to make an option select properly\n\t// Support: IE9, IE10\n\tsupport.optSelected = opt.selected;\n\n\t// Will be defined later\n\tsupport.reliableMarginRight = true;\n\tsupport.boxSizingReliable = true;\n\tsupport.pixelPosition = false;\n\n\t// Make sure checked status is properly cloned\n\t// Support: IE9, IE10\n\tinput.checked = true;\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Check if an input maintains its value after becoming a radio\n\t// Support: IE9, IE10\n\tinput = document.createElement(\"input\");\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tinput.setAttribute( \"checked\", \"t\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tfragment.appendChild( input );\n\n\t// Support: Safari 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: Firefox, Chrome, Safari\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\tsupport.focusinBubbles = \"onfocusin\" in window;\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Run tests that need a body at doc ready\n\tjQuery(function() {\n\t\tvar container, marginDiv,\n\t\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\n\t\t\tbody = document.getElementsByTagName(\"body\")[ 0 ];\n\n\t\tif ( !body ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n\t\t// Check box-sizing and margin behavior.\n\t\tbody.appendChild( container ).appendChild( div );\n\t\tdiv.innerHTML = \"\";\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\";\n\n\t\t// Workaround failing boxSizing test due to offsetWidth returning wrong value\n\t\t// with some non-1 values of body zoom, ticket #13543\n\t\tjQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\n\t\t\tsupport.boxSizing = div.offsetWidth === 4;\n\t\t});\n\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\tsupport.reliableMarginRight =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\t\t}\n\n\t\tbody.removeChild( container );\n\t});\n\n\treturn support;\n})( {} );\n\n/*\n\tImplementation Summary\n\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t2. Improve the module's maintainability by reducing the storage\n\t\tpaths to a single mechanism.\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n*/\nvar data_user, data_priv,\n\trbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction Data() {\n\t// Support: Android < 4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Math.random();\n}\n\nData.uid = 1;\n\nData.accepts = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType ?\n\t\towner.nodeType === 1 || owner.nodeType === 9 : true;\n};\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android < 4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( core_rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\n\n// These may be used throughout the jQuery core codebase\ndata_user = new Data();\ndata_priv = new Data();\n\n\njQuery.extend({\n\tacceptData: Data.accepts,\n\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar attrs, name,\n\t\t\telem = this[ 0 ],\n\t\t\ti = 0,\n\t\t\tdata = null;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\tattrs = elem.attributes;\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\n\t\t\t\t\t\tname = attrs[ i ].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? JSON.parse( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar nodeHook, boolHook,\n\trclass = /[\\t\\r\\n\\f]/g,\n\trreturn = /\\r/g,\n\trfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t},\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = jQuery.trim( cur );\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map(val, function ( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t// uses .value. See #6932\n\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t},\n\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( core_rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\n\n\tjQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar fn = jQuery.expr.attrHandle[ name ],\n\t\t\tret = isXML ?\n\t\t\t\tundefined :\n\t\t\t\t/* jshint eqeqeq: false */\n\t\t\t\t// Temporarily disable this handler to check existence\n\t\t\t\t(jQuery.expr.attrHandle[ name ] = undefined) !=\n\t\t\t\t\tgetter( elem, name, isXML ) ?\n\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\n\t\t// Restore handler\n\t\tjQuery.expr.attrHandle[ name ] = fn;\n\n\t\treturn ret;\n\t};\n});\n\n// Support: IE9+\n// Selectedness for an option in an optgroup can be inaccurate\nif ( !jQuery.support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !jQuery.support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\nvar rkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = core_slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome < 28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Create \"bubbling\" focus and blur events\n// Support: Firefox, Chrome, Safari\nif ( !jQuery.support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\t\tvar attaches = 0,\n\t\t\thandler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tif ( attaches++ === 0 ) {\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tif ( --attaches === 0 ) {\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\nvar isSimple = /^.[^:#\\[\\.,]*$/,\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\trneedsContext = jQuery.expr.match.needsContext,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tret = [],\n\t\t\tself = this,\n\t\t\tlen = self.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = ( rneedsContext.test( selectors ) || typeof selectors !== \"string\" ) ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tcur = matched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn core_indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn core_indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( jQuery.unique(all) );\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}));\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( core_indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\nvar rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE 9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE 9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar\n\t\t\t// Snapshot the DOM in case .domManip sweeps something relevant into its fragment\n\t\t\targs = jQuery.map( this, function( elem ) {\n\t\t\t\treturn [ elem.nextSibling, elem.parentNode ];\n\t\t\t}),\n\t\t\ti = 0;\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\tvar next = args[ i++ ],\n\t\t\t\tparent = args[ i++ ];\n\n\t\t\tif ( parent ) {\n\t\t\t\t// Don't use the snapshot next if it has moved (#13810)\n\t\t\t\tif ( next && next.parentNode !== parent ) {\n\t\t\t\t\tnext = this.nextSibling;\n\t\t\t\t}\n\t\t\t\tjQuery( this ).remove();\n\t\t\t\tparent.insertBefore( elem, next );\n\t\t\t}\n\t\t// Allow new content to include elements from the context set\n\t\t}, true );\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn i ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback, allowIntersection ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = core_concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback, allowIntersection );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Hope ajax is available...\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because core_push.apply(_, arraylike) throws\n\t\t\tcore_push.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Support: IE >= 9\n\t\t// Fix Cloning issues\n\t\tif ( !jQuery.support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\ti = 0,\n\t\t\tl = elems.length,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [];\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Fixes #12346\n\t\t\t\t\t// Support: Webkit, IE\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, events, type, key, j,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( Data.accepts( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tevents = Object.keys( data.events || {} );\n\t\t\t\t\tif ( events.length ) {\n\t\t\t\t\t\tfor ( j = 0; (type = events[j]) !== undefined; j++ ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t},\n\n\t_evalUrl: function( url ) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t}\n});\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar l = elems.length,\n\t\ti = 0;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Support: IE >= 9\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\nvar curCSS, iframe,\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trmargin = /^margin/,\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n\telemdisplay = { BODY: \"block\" },\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction isHidden( elem, el ) {\n\t// isHidden might be called from jQuery#filter function;\n\t// in that case, element will be second argument\n\telem = el || elem;\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\n// NOTE: we've included the \"window\" in window.getComputedStyle\n// because jsdom on node.js will break without it.\nfunction getStyles( elem ) {\n\treturn window.getComputedStyle( elem, null );\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn jQuery.access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\ncurCSS = function( elem, name, _computed ) {\n\tvar width, minWidth, maxWidth,\n\t\tcomputed = _computed || getStyles( elem ),\n\n\t\t// Support: IE9\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n\t\tstyle = elem.style;\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: Safari 5.1\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe ||\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\n\t\t\t).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n// Called ONLY from within css_defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\n\telem.remove();\n\treturn display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n\t// Support: Android 2.3\n\tif ( !jQuery.support.reliableMarginRight ) {\n\t\tjQuery.cssHooks.marginRight = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\t\tjQuery.cssHooks[ prop ] = {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\t\tcomputed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\tajax_nonce = jQuery.now(),\n\n\tajax_rquery = /\\?/,\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n\tjQuery.fn[ type ] = function( fn ){\n\t\treturn this.on( type, fn );\n\t};\n});\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrSupported = jQuery.ajaxSettings.xhr(),\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\t// Support: IE9\n\t// We need to keep track of outbound xhr and abort them manually\n\t// because IE is not smart enough to do it all by itself\n\txhrId = 0,\n\txhrCallbacks = {};\n\nif ( window.ActiveXObject ) {\n\tjQuery( window ).on( \"unload\", function() {\n\t\tfor( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t\txhrCallbacks = undefined;\n\t});\n}\n\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\njQuery.support.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( jQuery.support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i, id,\n\t\t\t\t\txhr = options.xhr();\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file protocol always yields status 0, assume 404\n\t\t\t\t\t\t\t\t\txhr.status || 404,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// #11426: When requesting binary data, IE9 will throw an exception\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[( id = xhrId++ )] = callback(\"abort\");\n\t\t\t\t// Do send the request\n\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar fxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth? 1 : 0;\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\t}\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tif ( timer() && jQuery.timers.push( timer ) ) {\n\t\tjQuery.fx.start();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\njQuery.fn.offset = function( options ) {\n\tif ( arguments.length ) {\n\t\treturn options === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t}\n\n\tvar docElem, win,\n\t\telem = this[ 0 ],\n\t\tbox = { top: 0, left: 0 },\n\t\tdoc = elem && elem.ownerDocument;\n\n\tif ( !doc ) {\n\t\treturn;\n\t}\n\n\tdocElem = doc.documentElement;\n\n\t// Make sure it's not a disconnected DOM node\n\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\treturn box;\n\t}\n\n\t// If we don't have gBCR, just use 0,0 rather than error\n\t// BlackBerry 5, iOS 3 (original iPhone)\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n\t\tbox = elem.getBoundingClientRect();\n\t}\n\twin = getWindow( doc );\n\treturn {\n\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t};\n};\n\njQuery.offset = {\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && ( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn jQuery.access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n// })();\nif ( typeof module === \"object\" && module && typeof module.exports === \"object\" ) {\n\t// Expose jQuery as module.exports in loaders that implement the Node\n\t// module pattern (including browserify). Do not create the global, since\n\t// the user will be storing it themselves locally, and globals are frowned\n\t// upon in the Node module world.\n\tmodule.exports = jQuery;\n} else {\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\tif ( typeof define === \"function\" && define.amd ) {\n\t\tdefine( \"jquery\", [], function () { return jQuery; } );\n\t}\n}\n\n// If there is a window object, that at least has a document property,\n// define jQuery and $ identifiers\nif ( typeof window === \"object\" && typeof window.document === \"object\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n})( window );\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/main.js":"requirejs.config({\n    shim: {\n        'underscore': {\n            exports: '_'\n        }\n    }\n});\n\nrequire([\"sweet\",\"./parser\", \"./expander\", \"./escodegen\"], function(sweet, parser, expander, escodegen) {\n    var read = parser.read;\n    var expand = expander.expand;\n    var flatten = expander.flatten;\n\n    var editor = CodeMirror.fromTextArea($('#editor')[0], {\n        lineNumbers: true,\n        smartIndent: false,\n        tabSize: 2,\n        autofocus: true,\n        theme: 'solarized dark'\n    });\n    editor.setValue(localStorage['code'] ? localStorage['code'] : \"\");\n\n    var output = CodeMirror.fromTextArea($('#output')[0], {\n        lineNumbers: true,\n        theme: 'solarized dark',\n        readOnly: true\n    });\n\n    var updateTimeout;\n    editor.on(\"change\", function(e) {\n        clearTimeout(updateTimeout);\n        updateTimeout = setTimeout(updateExpand, 200);\n    });\n\n    function updateExpand() {\n        var code = editor.getValue();\n        var expanded, compiled;\n        try {\n            expanded = expand(read(code));\n            compiled = escodegen.generate(parser.parse(expanded));\n            output.setValue(compiled);\n            localStorage['code'] = code;\n\n            $('#errors').text('');\n        } catch (e) {\n            $('#errors').text(e);\n        }\n\n        $('#syntax').empty();\n        expanded.forEach(function(stx) {\n            $newdiv = $(\"<div class='box-entry'>\" + stx.toString() + \"</div>\");\n            $('#syntax').append($newdiv);\n\n            $newdiv.click(function(e) {\n                updateContextBox(stx);\n            });\n        });\n    }\n\n    function mkContextString(ctx) {\n        var div_string;\n        if (typeof ctx.mark !== 'undefined') {\n            div_string = \"<div class='box-entry'>mark: \" + ctx.mark + \"</div>\";\n        } else if (typeof ctx.name !== 'undefined') {\n            div_string = \"<div class='box-entry'>rename: \" + ctx.name + \"</div>\";\n        } else if (typeof ctx.defctx !== 'undefined') {\n            var sigma_map = ctx.defctx.map(function(def) {\n                return def.id.token.value + \" -> \" + def.name;\n            }).join(\", \");\n            div_string = \"<div class='box-entry'>σ [\" + sigma_map + \"]</div>\";\n        } else {\n            div_string = \"<div class='box-entry'>unknown</div>\";\n        }\n        return div_string;\n    }\n\n    function updateContextBox(stx) {\n        var $box = $('#context');\n        $box.empty();\n        var stx_value = stx.token.value;\n        var stx_resolve = expander.resolve(stx);\n        $box.append(\"<div class='box-entry'>resolve(\" + stx_value + \") = \" + stx_resolve + \"</div>\");\n        function appendCtx(ctx) {\n            if(ctx === null) {\n                return;\n            }\n            var $newdiv = $(mkContextString(ctx));\n            $box.append($newdiv);\n            $newdiv.click(function(e) {\n                updateIdBox(ctx);\n            });\n\n            appendCtx(ctx.context);\n        }\n        appendCtx(stx.context);\n    }\n\n    function updateIdBox(ctx) {\n        if(typeof ctx.id === 'undefined') {\n            return;\n        }\n        var stx = ctx.id;\n        var $box = $('#id-context');\n        $box.empty();\n        var stx_value = stx.token.value;\n        var stx_resolve = expander.resolve(stx);\n        $box.append(\"<div class='box-entry'>resolve(\" + stx_value + \") = \" + stx_resolve + \"</div>\");\n\n        function appendCtx(ctx) {\n            if(ctx === null) {\n                return;\n            }\n            var $newdiv = $(mkContextString(ctx));\n            $box.append($newdiv);\n            appendCtx(ctx.context);\n        }\n        appendCtx(stx.context);\n    }\n\n    updateExpand();\n});","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/require.js":"/*\n RequireJS 2.1.1 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n Available via the MIT or new BSD license.\n see: http://github.com/jrburke/requirejs for details\n*/\nvar requirejs,require,define;\n(function(W){function D(b){return M.call(b)===\"[object Function]\"}function E(b){return M.call(b)===\"[object Array]\"}function t(b,c){if(b){var d;for(d=0;d<b.length;d+=1)if(b[d]&&c(b[d],d,b))break}}function N(b,c){if(b){var d;for(d=b.length-1;d>-1;d-=1)if(b[d]&&c(b[d],d,b))break}}function A(b,c){for(var d in b)if(b.hasOwnProperty(d)&&c(b[d],d))break}function O(b,c,d,g){c&&A(c,function(c,j){if(d||!F.call(b,j))g&&typeof c!==\"string\"?(b[j]||(b[j]={}),O(b[j],c,d,g)):b[j]=c});return b}function r(b,c){return function(){return c.apply(b,\narguments)}}function X(b){if(!b)return b;var c=W;t(b.split(\".\"),function(b){c=c[b]});return c}function G(b,c,d,g){c=Error(c+\"\\nhttp://requirejs.org/docs/errors.html#\"+b);c.requireType=b;c.requireModules=g;if(d)c.originalError=d;return c}function ba(){if(H&&H.readyState===\"interactive\")return H;N(document.getElementsByTagName(\"script\"),function(b){if(b.readyState===\"interactive\")return H=b});return H}var g,s,u,y,q,B,H,I,Y,Z,ca=/(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,da=/[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,\n$=/\\.js$/,ea=/^\\.\\//;s=Object.prototype;var M=s.toString,F=s.hasOwnProperty,fa=Array.prototype.splice,v=!!(typeof window!==\"undefined\"&&navigator&&document),aa=!v&&typeof importScripts!==\"undefined\",ga=v&&navigator.platform===\"PLAYSTATION 3\"?/^complete$/:/^(complete|loaded)$/,R=typeof opera!==\"undefined\"&&opera.toString()===\"[object Opera]\",w={},n={},P=[],J=!1;if(typeof define===\"undefined\"){if(typeof requirejs!==\"undefined\"){if(D(requirejs))return;n=requirejs;requirejs=void 0}typeof require!==\"undefined\"&&\n!D(require)&&(n=require,require=void 0);g=requirejs=function(b,c,d,p){var i,j=\"_\";!E(b)&&typeof b!==\"string\"&&(i=b,E(c)?(b=c,c=d,d=p):b=[]);if(i&&i.context)j=i.context;(p=w[j])||(p=w[j]=g.s.newContext(j));i&&p.configure(i);return p.require(b,c,d)};g.config=function(b){return g(b)};g.nextTick=typeof setTimeout!==\"undefined\"?function(b){setTimeout(b,4)}:function(b){b()};require||(require=g);g.version=\"2.1.1\";g.jsExtRegExp=/^\\/|:|\\?|\\.js$/;g.isBrowser=v;s=g.s={contexts:w,newContext:function(b){function c(a,\nf,x){var e,m,b,c,d,h,i,g=f&&f.split(\"/\");e=g;var j=k.map,l=j&&j[\"*\"];if(a&&a.charAt(0)===\".\")if(f){e=k.pkgs[f]?g=[f]:g.slice(0,g.length-1);f=a=e.concat(a.split(\"/\"));for(e=0;f[e];e+=1)if(m=f[e],m===\".\")f.splice(e,1),e-=1;else if(m===\"..\")if(e===1&&(f[2]===\"..\"||f[0]===\"..\"))break;else e>0&&(f.splice(e-1,2),e-=2);e=k.pkgs[f=a[0]];a=a.join(\"/\");e&&a===f+\"/\"+e.main&&(a=f)}else a.indexOf(\"./\")===0&&(a=a.substring(2));if(x&&(g||l)&&j){f=a.split(\"/\");for(e=f.length;e>0;e-=1){b=f.slice(0,e).join(\"/\");if(g)for(m=\ng.length;m>0;m-=1)if(x=j[g.slice(0,m).join(\"/\")])if(x=x[b]){c=x;d=e;break}if(c)break;!h&&l&&l[b]&&(h=l[b],i=e)}!c&&h&&(c=h,d=i);c&&(f.splice(0,d,c),a=f.join(\"/\"))}return a}function d(a){v&&t(document.getElementsByTagName(\"script\"),function(f){if(f.getAttribute(\"data-requiremodule\")===a&&f.getAttribute(\"data-requirecontext\")===h.contextName)return f.parentNode.removeChild(f),!0})}function p(a){var f=k.paths[a];if(f&&E(f)&&f.length>1)return d(a),f.shift(),h.require.undef(a),h.require([a]),!0}function i(a){var f,\nb=a?a.indexOf(\"!\"):-1;b>-1&&(f=a.substring(0,b),a=a.substring(b+1,a.length));return[f,a]}function j(a,f,b,e){var m,K,d=null,g=f?f.name:null,j=a,l=!0,k=\"\";a||(l=!1,a=\"_@r\"+(M+=1));a=i(a);d=a[0];a=a[1];d&&(d=c(d,g,e),K=o[d]);a&&(d?k=K&&K.normalize?K.normalize(a,function(a){return c(a,g,e)}):c(a,g,e):(k=c(a,g,e),a=i(k),d=a[0],k=a[1],b=!0,m=h.nameToUrl(k)));b=d&&!K&&!b?\"_unnormalized\"+(N+=1):\"\";return{prefix:d,name:k,parentMap:f,unnormalized:!!b,url:m,originalName:j,isDefine:l,id:(d?d+\"!\"+k:k)+b}}function n(a){var f=\na.id,b=l[f];b||(b=l[f]=new h.Module(a));return b}function q(a,f,b){var e=a.id,m=l[e];if(F.call(o,e)&&(!m||m.defineEmitComplete))f===\"defined\"&&b(o[e]);else n(a).on(f,b)}function z(a,f){var b=a.requireModules,e=!1;if(f)f(a);else if(t(b,function(f){if(f=l[f])f.error=a,f.events.error&&(e=!0,f.emit(\"error\",a))}),!e)g.onError(a)}function s(){P.length&&(fa.apply(C,[C.length-1,0].concat(P)),P=[])}function u(a,f,b){var e=a.map.id;a.error?a.emit(\"error\",a.error):(f[e]=!0,t(a.depMaps,function(e,c){var d=e.id,\ng=l[d];g&&!a.depMatched[c]&&!b[d]&&(f[d]?(a.defineDep(c,o[d]),a.check()):u(g,f,b))}),b[e]=!0)}function w(){var a,f,b,e,m=(b=k.waitSeconds*1E3)&&h.startTime+b<(new Date).getTime(),c=[],g=[],i=!1,j=!0;if(!S){S=!0;A(l,function(b){a=b.map;f=a.id;if(b.enabled&&(a.isDefine||g.push(b),!b.error))if(!b.inited&&m)p(f)?i=e=!0:(c.push(f),d(f));else if(!b.inited&&b.fetched&&a.isDefine&&(i=!0,!a.prefix))return j=!1});if(m&&c.length)return b=G(\"timeout\",\"Load timeout for modules: \"+c,null,c),b.contextName=h.contextName,\nz(b);j&&t(g,function(a){u(a,{},{})});if((!m||e)&&i)if((v||aa)&&!T)T=setTimeout(function(){T=0;w()},50);S=!1}}function y(a){n(j(a[0],null,!0)).init(a[1],a[2])}function B(a){var a=a.currentTarget||a.srcElement,b=h.onScriptLoad;a.detachEvent&&!R?a.detachEvent(\"onreadystatechange\",b):a.removeEventListener(\"load\",b,!1);b=h.onScriptError;a.detachEvent&&!R||a.removeEventListener(\"error\",b,!1);return{node:a,id:a&&a.getAttribute(\"data-requiremodule\")}}function I(){var a;for(s();C.length;)if(a=C.shift(),a[0]===\nnull)return z(G(\"mismatch\",\"Mismatched anonymous define() module: \"+a[a.length-1]));else y(a)}var S,U,h,L,T,k={waitSeconds:7,baseUrl:\"./\",paths:{},pkgs:{},shim:{},map:{},config:{}},l={},V={},C=[],o={},Q={},M=1,N=1;L={require:function(a){return a.require?a.require:a.require=h.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?a.exports:a.exports=o[a.map.id]={}},module:function(a){return a.module?a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return k.config&&\nk.config[a.map.id]||{}},exports:o[a.map.id]}}};U=function(a){this.events=V[a.id]||{};this.map=a;this.shim=k.shim[a.id];this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};U.prototype={init:function(a,b,c,e){e=e||{};if(!this.inited){this.factory=b;if(c)this.on(\"error\",c);else this.events.error&&(c=r(this,function(a){this.emit(\"error\",a)}));this.depMaps=a&&a.slice(0);this.errback=c;this.inited=!0;this.ignore=e.ignore;e.enabled||this.enabled?this.enable():this.check()}},\ndefineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;h.startTime=(new Date).getTime();var a=this.map;if(this.shim)h.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],r(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=this.map.url;Q[a]||(Q[a]=!0,h.load(this.map.id,a))},check:function(){if(this.enabled&&\n!this.enabling){var a,b,c=this.map.id;b=this.depExports;var e=this.exports,m=this.factory;if(this.inited)if(this.error)this.emit(\"error\",this.error);else{if(!this.defining){this.defining=!0;if(this.depCount<1&&!this.defined){if(D(m)){if(this.events.error)try{e=h.execCb(c,m,b,e)}catch(d){a=d}else e=h.execCb(c,m,b,e);if(this.map.isDefine)if((b=this.module)&&b.exports!==void 0&&b.exports!==this.exports)e=b.exports;else if(e===void 0&&this.usingExports)e=this.exports;if(a)return a.requireMap=this.map,\na.requireModules=[this.map.id],a.requireType=\"define\",z(this.error=a)}else e=m;this.exports=e;if(this.map.isDefine&&!this.ignore&&(o[c]=e,g.onResourceLoad))g.onResourceLoad(h,this.map,this.depMaps);delete l[c];this.defined=!0}this.defining=!1;if(this.defined&&!this.defineEmitted)this.defineEmitted=!0,this.emit(\"defined\",this.exports),this.defineEmitComplete=!0}}else this.fetch()}},callPlugin:function(){var a=this.map,b=a.id,d=j(a.prefix);this.depMaps.push(d);q(d,\"defined\",r(this,function(e){var m,\nd;d=this.map.name;var x=this.map.parentMap?this.map.parentMap.name:null,i=h.makeRequire(a.parentMap,{enableBuildCallback:!0,skipMap:!0});if(this.map.unnormalized){if(e.normalize&&(d=e.normalize(d,function(a){return c(a,x,!0)})||\"\"),e=j(a.prefix+\"!\"+d,this.map.parentMap),q(e,\"defined\",r(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),d=l[e.id]){this.depMaps.push(e);if(this.events.error)d.on(\"error\",r(this,function(a){this.emit(\"error\",a)}));d.enable()}}else m=r(this,\nfunction(a){this.init([],function(){return a},null,{enabled:!0})}),m.error=r(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];A(l,function(a){a.map.id.indexOf(b+\"_unnormalized\")===0&&delete l[a.map.id]});z(a)}),m.fromText=r(this,function(b,e){var f=a.name,c=j(f),d=J;e&&(b=e);d&&(J=!1);n(c);try{g.exec(b)}catch(x){throw Error(\"fromText eval for \"+f+\" failed: \"+x);}d&&(J=!0);this.depMaps.push(c);h.completeLoad(f);i([f],m)}),e.load(a.name,i,m,k)}));h.enable(d,this);this.pluginMaps[d.id]=\nd},enable:function(){this.enabling=this.enabled=!0;t(this.depMaps,r(this,function(a,b){var c,e;if(typeof a===\"string\"){a=j(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=L[a.id]){this.depExports[b]=c(this);return}this.depCount+=1;q(a,\"defined\",r(this,function(a){this.defineDep(b,a);this.check()}));this.errback&&q(a,\"error\",this.errback)}c=a.id;e=l[c];!L[c]&&e&&!e.enabled&&h.enable(a,this)}));A(this.pluginMaps,r(this,function(a){var b=l[a.id];b&&!b.enabled&&\nh.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){t(this.events[a],function(a){a(b)});a===\"error\"&&delete this.events[a]}};h={config:k,contextName:b,registry:l,defined:o,urlFetched:Q,defQueue:C,Module:U,makeModuleMap:j,nextTick:g.nextTick,configure:function(a){a.baseUrl&&a.baseUrl.charAt(a.baseUrl.length-1)!==\"/\"&&(a.baseUrl+=\"/\");var b=k.pkgs,c=k.shim,e={paths:!0,config:!0,map:!0};A(a,function(a,b){e[b]?\nb===\"map\"?O(k[b],a,!0,!0):O(k[b],a,!0):k[b]=a});if(a.shim)A(a.shim,function(a,b){E(a)&&(a={deps:a});if(a.exports&&!a.exportsFn)a.exportsFn=h.makeShimExports(a);c[b]=a}),k.shim=c;if(a.packages)t(a.packages,function(a){a=typeof a===\"string\"?{name:a}:a;b[a.name]={name:a.name,location:a.location||a.name,main:(a.main||\"main\").replace(ea,\"\").replace($,\"\")}}),k.pkgs=b;A(l,function(a,b){if(!a.inited&&!a.map.unnormalized)a.map=j(b)});if(a.deps||a.callback)h.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;\na.init&&(b=a.init.apply(W,arguments));return b||X(a.exports)}},makeRequire:function(a,f){function d(e,c,i){var k,p;if(f.enableBuildCallback&&c&&D(c))c.__requireJsBuild=!0;if(typeof e===\"string\"){if(D(c))return z(G(\"requireargs\",\"Invalid require call\"),i);if(a&&L[e])return L[e](l[a.id]);if(g.get)return g.get(h,e,a);k=j(e,a,!1,!0);k=k.id;return!F.call(o,k)?z(G(\"notloaded\",'Module name \"'+k+'\" has not been loaded yet for context: '+b+(a?\"\":\". Use require([])\"))):o[k]}I();h.nextTick(function(){I();p=\nn(j(null,a));p.skipMap=f.skipMap;p.init(e,c,i,{enabled:!0});w()});return d}f=f||{};O(d,{isBrowser:v,toUrl:function(b){var d=b.lastIndexOf(\".\"),f=null;d!==-1&&(f=b.substring(d,b.length),b=b.substring(0,d));return h.nameToUrl(c(b,a&&a.id,!0),f)},defined:function(b){b=j(b,a,!1,!0).id;return F.call(o,b)},specified:function(b){b=j(b,a,!1,!0).id;return F.call(o,b)||F.call(l,b)}});if(!a)d.undef=function(b){s();var c=j(b,a,!0),d=l[b];delete o[b];delete Q[c.url];delete V[b];if(d){if(d.events.defined)V[b]=\nd.events;delete l[b]}};return d},enable:function(a){l[a.id]&&n(a).enable()},completeLoad:function(a){var b,c,d=k.shim[a]||{},g=d.exports;for(s();C.length;){c=C.shift();if(c[0]===null){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);y(c)}c=l[a];if(!b&&!o[a]&&c&&!c.inited)if(k.enforceDefine&&(!g||!X(g)))if(p(a))return;else return z(G(\"nodefine\",\"No define call for \"+a,null,[a]));else y([a,d.deps||[],d.exportsFn]);w()},nameToUrl:function(a,b){var c,d,i,h,j,l;if(g.jsExtRegExp.test(a))h=a+(b||\"\");else{c=\nk.paths;d=k.pkgs;h=a.split(\"/\");for(j=h.length;j>0;j-=1)if(l=h.slice(0,j).join(\"/\"),i=d[l],l=c[l]){E(l)&&(l=l[0]);h.splice(0,j,l);break}else if(i){c=a===i.name?i.location+\"/\"+i.main:i.location;h.splice(0,j,c);break}h=h.join(\"/\");h+=b||(/\\?/.test(h)?\"\":\".js\");h=(h.charAt(0)===\"/\"||h.match(/^[\\w\\+\\.\\-]+:/)?\"\":k.baseUrl)+h}return k.urlArgs?h+((h.indexOf(\"?\")===-1?\"?\":\"&\")+k.urlArgs):h},load:function(a,b){g.load(h,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if(a.type===\n\"load\"||ga.test((a.currentTarget||a.srcElement).readyState))H=null,a=B(a),h.completeLoad(a.id)},onScriptError:function(a){var b=B(a);if(!p(b.id))return z(G(\"scripterror\",\"Script error\",a,[b.id]))}};h.require=h.makeRequire();return h}};g({});t([\"toUrl\",\"undef\",\"defined\",\"specified\"],function(b){g[b]=function(){var c=w._;return c.require[b].apply(c,arguments)}});if(v&&(u=s.head=document.getElementsByTagName(\"head\")[0],y=document.getElementsByTagName(\"base\")[0]))u=s.head=y.parentNode;g.onError=function(b){throw b;\n};g.load=function(b,c,d){var g=b&&b.config||{},i;if(v)return i=g.xhtml?document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"html:script\"):document.createElement(\"script\"),i.type=g.scriptType||\"text/javascript\",i.charset=\"utf-8\",i.async=!0,i.setAttribute(\"data-requirecontext\",b.contextName),i.setAttribute(\"data-requiremodule\",c),i.attachEvent&&!(i.attachEvent.toString&&i.attachEvent.toString().indexOf(\"[native code\")<0)&&!R?(J=!0,i.attachEvent(\"onreadystatechange\",b.onScriptLoad)):(i.addEventListener(\"load\",\nb.onScriptLoad,!1),i.addEventListener(\"error\",b.onScriptError,!1)),i.src=d,I=i,y?u.insertBefore(i,y):u.appendChild(i),I=null,i;else aa&&(importScripts(d),b.completeLoad(c))};v&&N(document.getElementsByTagName(\"script\"),function(b){if(!u)u=b.parentNode;if(q=b.getAttribute(\"data-main\")){if(!n.baseUrl)B=q.split(\"/\"),Y=B.pop(),Z=B.length?B.join(\"/\")+\"/\":\"./\",n.baseUrl=Z,q=Y;q=q.replace($,\"\");n.deps=n.deps?n.deps.concat(q):[q];return!0}});define=function(b,c,d){var g,i;typeof b!==\"string\"&&(d=c,c=b,b=\nnull);E(c)||(d=c,c=[]);!c.length&&D(d)&&d.length&&(d.toString().replace(ca,\"\").replace(da,function(b,d){c.push(d)}),c=(d.length===1?[\"require\"]:[\"require\",\"exports\",\"module\"]).concat(c));if(J&&(g=I||ba()))b||(b=g.getAttribute(\"data-requiremodule\")),i=w[g.getAttribute(\"data-requirecontext\")];(i?i.defQueue:P).push([b,c,d])};define.amd={jQuery:!0};g.exec=function(b){return eval(b)};g(n)}})(this);\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/rx.lite.js":"// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved. See License.txt in the project root for license information.\n\n;(function (undefined) {\n\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  var root = (objectTypes[typeof window] && window) || this,\n    freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,\n    freeModule = objectTypes[typeof module] && module && !module.nodeType && module,\n    moduleExports = freeModule && freeModule.exports === freeExports && freeExports,\n    freeGlobal = objectTypes[typeof global] && global;\n\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  var Rx = {\n      internals: {},\n      config: {\n        Promise: root.Promise,\n      },\n      helpers: { }\n  };\n\n  // Defaults\n  var noop = Rx.helpers.noop = function () { },\n    notDefined = Rx.helpers.notDefined = function (x) { return typeof x === 'undefined'; },\n    isScheduler = Rx.helpers.isScheduler = function (x) { return x instanceof Rx.Scheduler; },\n    identity = Rx.helpers.identity = function (x) { return x; },\n    pluck = Rx.helpers.pluck = function (property) { return function (x) { return x[property]; }; },\n    just = Rx.helpers.just = function (value) { return function () { return value; }; },\n    defaultNow = Rx.helpers.defaultNow = Date.now,\n    defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },\n    defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x > y ? 1 : (x < y ? -1 : 0); },\n    defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.toString(); },\n    defaultError = Rx.helpers.defaultError = function (err) { throw err; },\n    isPromise = Rx.helpers.isPromise = function (p) { return !!p && typeof p.then === 'function'; },\n    asArray = Rx.helpers.asArray = function () { return Array.prototype.slice.call(arguments); },\n    not = Rx.helpers.not = function (a) { return !a; },\n    isFunction = Rx.helpers.isFunction = (function () {\n\n      var isFn = function (value) {\n        return typeof value == 'function' || false;\n      }\n\n      // fallback for older versions of Chrome and Safari\n      if (isFn(/x/)) {\n        isFn = function(value) {\n          return typeof value == 'function' && toString.call(value) == '[object Function]';\n        };\n      }\n\n      return isFn;\n    }());\n\n  // Errors\n  var sequenceContainsNoElements = 'Sequence contains no elements.';\n  var argumentOutOfRange = 'Argument out of range';\n  var objectDisposed = 'Object has been disposed';\n  function checkDisposed() { if (this.isDisposed) { throw new Error(objectDisposed); } }\n\n  Rx.config.longStackSupport = false;\n  var hasStacks = false;\n  try {\n    throw new Error();\n  } catch (e) {\n    hasStacks = !!e.stack;\n  }\n\n  // All code after this point will be filtered from stack traces reported by RxJS\n  var rStartingLine = captureLine(), rFileName;\n\n  var STACK_JUMP_SEPARATOR = \"From previous event:\";\n\n  function makeStackTraceLong(error, observable) {\n      // If possible, transform the error stack trace by removing Node and RxJS\n      // cruft, then concatenating with the stack trace of `observable`.\n      if (hasStacks &&\n          observable.stack &&\n          typeof error === \"object\" &&\n          error !== null &&\n          error.stack &&\n          error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n      ) {\n        var stacks = [];\n        for (var o = observable; !!o; o = o.source) {\n          if (o.stack) {\n            stacks.unshift(o.stack);\n          }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n  }\n\n  function filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\"),\n        desiredLines = [];\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var line = lines[i];\n\n      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n        desiredLines.push(line);\n      }\n    }\n    return desiredLines.join(\"\\n\");\n  }\n\n  function isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n    if (!fileNameAndLineNumber) {\n      return false;\n    }\n    var fileName = fileNameAndLineNumber[0], lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === rFileName &&\n      lineNumber >= rStartingLine &&\n      lineNumber <= rEndingLine;\n  }\n\n  function isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n      stackLine.indexOf(\"(node.js:\") !== -1;\n  }\n\n  function captureLine() {\n    if (!hasStacks) { return; }\n\n    try {\n      throw new Error();\n    } catch (e) {\n      var lines = e.stack.split(\"\\n\");\n      var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n      if (!fileNameAndLineNumber) { return; }\n\n      rFileName = fileNameAndLineNumber[0];\n      return fileNameAndLineNumber[1];\n    }\n  }\n\n  function getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) { return [attempt1[1], Number(attempt1[2])]; }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) { return [attempt2[1], Number(attempt2[2])]; }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) { return [attempt3[1], Number(attempt3[2])]; }\n  }\n\n  // Shim in iterator support\n  var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) ||\n    '_es6shim_iterator_';\n  // Bug for mozilla version\n  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n    $iterator$ = '@@iterator';\n  }\n\n  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };\n\n  var isIterable = Rx.helpers.isIterable = function (o) {\n    return o[$iterator$] !== undefined;\n  }\n\n  var isArrayLike = Rx.helpers.isArrayLike = function (o) {\n    return o && o.length !== undefined;\n  }\n\n  Rx.helpers.iterator = $iterator$;\n\n  var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {\n    if (typeof thisArg === 'undefined') { return func; }\n    switch(argCount) {\n      case 0:\n        return function() {\n          return func.call(thisArg)\n        };\n      case 1:\n        return function(arg) {\n          return func.call(thisArg, arg);\n        }\n      case 2:\n        return function(value, index) {\n          return func.call(thisArg, value, index);\n        };\n      case 3:\n        return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n    }\n\n    return function() {\n      return func.apply(thisArg, arguments);\n    };\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var dontEnums = ['toString',\n    'toLocaleString',\n    'valueOf',\n    'hasOwnProperty',\n    'isPrototypeOf',\n    'propertyIsEnumerable',\n    'constructor'],\n  dontEnumsLength = dontEnums.length;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n    arrayClass = '[object Array]',\n    boolClass = '[object Boolean]',\n    dateClass = '[object Date]',\n    errorClass = '[object Error]',\n    funcClass = '[object Function]',\n    numberClass = '[object Number]',\n    objectClass = '[object Object]',\n    regexpClass = '[object RegExp]',\n    stringClass = '[object String]';\n\n  var toString = Object.prototype.toString,\n    hasOwnProperty = Object.prototype.hasOwnProperty,\n    supportsArgsClass = toString.call(arguments) == argsClass, // For less <IE9 && FF<4\n    supportNodeClass,\n    errorProto = Error.prototype,\n    objectProto = Object.prototype,\n    stringProto = String.prototype,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n  try {\n    supportNodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));\n  } catch (e) {\n    supportNodeClass = true;\n  }\n\n  var nonEnumProps = {};\n  nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\n  nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };\n  nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };\n  nonEnumProps[objectClass] = { 'constructor': true };\n\n  var support = {};\n  (function () {\n    var ctor = function() { this.x = 1; },\n      props = [];\n\n    ctor.prototype = { 'valueOf': 1, 'y': 1 };\n    for (var key in new ctor) { props.push(key); }\n    for (key in arguments) { }\n\n    // Detect if `name` or `message` properties of `Error.prototype` are enumerable by default.\n    support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');\n\n    // Detect if `prototype` properties are enumerable by default.\n    support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');\n\n    // Detect if `arguments` object indexes are non-enumerable\n    support.nonEnumArgs = key != 0;\n\n    // Detect if properties shadowing those on `Object.prototype` are non-enumerable.\n    support.nonEnumShadows = !/valueOf/.test(props);\n  }(1));\n\n  var isObject = Rx.internals.isObject = function(value) {\n    var type = typeof value;\n    return value && (type == 'function' || type == 'object') || false;\n  };\n\n  function keysIn(object) {\n    var result = [];\n    if (!isObject(object)) {\n      return result;\n    }\n    if (support.nonEnumArgs && object.length && isArguments(object)) {\n      object = slice.call(object);\n    }\n    var skipProto = support.enumPrototypes && typeof object == 'function',\n        skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);\n\n    for (var key in object) {\n      if (!(skipProto && key == 'prototype') &&\n          !(skipErrorProps && (key == 'message' || key == 'name'))) {\n        result.push(key);\n      }\n    }\n\n    if (support.nonEnumShadows && object !== objectProto) {\n      var ctor = object.constructor,\n          index = -1,\n          length = dontEnumsLength;\n\n      if (object === (ctor && ctor.prototype)) {\n        var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),\n            nonEnum = nonEnumProps[className];\n      }\n      while (++index < length) {\n        key = dontEnums[index];\n        if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {\n          result.push(key);\n        }\n      }\n    }\n    return result;\n  }\n\n  function internalFor(object, callback, keysFunc) {\n    var index = -1,\n      props = keysFunc(object),\n      length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n      if (callback(object[key], key, object) === false) {\n        break;\n      }\n    }\n    return object;\n  }\n\n  function internalForIn(object, callback) {\n    return internalFor(object, callback, keysIn);\n  }\n\n  function isNode(value) {\n    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`\n    // methods that are `typeof` \"string\" and still can coerce nodes to strings\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\n  }\n\n  var isArguments = function(value) {\n    return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;\n  }\n\n  // fallback for browsers that can't detect `arguments` objects by [[Class]]\n  if (!supportsArgsClass) {\n    isArguments = function(value) {\n      return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;\n    };\n  }\n\n  var isEqual = Rx.internals.isEqual = function (x, y) {\n    return deepEquals(x, y, [], []);\n  };\n\n  /** @private\n   * Used for deep comparison\n   **/\n  function deepEquals(a, b, stackA, stackB) {\n    // exit early for identical values\n    if (a === b) {\n      // treat `+0` vs. `-0` as not equal\n      return a !== 0 || (1 / a == 1 / b);\n    }\n\n    var type = typeof a,\n        otherType = typeof b;\n\n    // exit early for unlike primitive values\n    if (a === a && (a == null || b == null ||\n        (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {\n      return false;\n    }\n\n    // compare [[Class]] names\n    var className = toString.call(a),\n        otherClass = toString.call(b);\n\n    if (className == argsClass) {\n      className = objectClass;\n    }\n    if (otherClass == argsClass) {\n      otherClass = objectClass;\n    }\n    if (className != otherClass) {\n      return false;\n    }\n    switch (className) {\n      case boolClass:\n      case dateClass:\n        // coerce dates and booleans to numbers, dates to milliseconds and booleans\n        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n        return +a == +b;\n\n      case numberClass:\n        // treat `NaN` vs. `NaN` as equal\n        return (a != +a) ?\n          b != +b :\n          // but treat `-0` vs. `+0` as not equal\n          (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n      case regexpClass:\n      case stringClass:\n        // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n        // treat string primitives and their corresponding object instances as equal\n        return a == String(b);\n    }\n    var isArr = className == arrayClass;\n    if (!isArr) {\n\n      // exit for functions and DOM nodes\n      if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {\n        return false;\n      }\n      // in older versions of Opera, `arguments` objects have `Array` constructors\n      var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,\n          ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;\n\n      // non `Object` object instances with different constructors are not equal\n      if (ctorA != ctorB &&\n            !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) &&\n            !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n            ('constructor' in a && 'constructor' in b)\n          ) {\n        return false;\n      }\n    }\n    // assume cyclic structures are equal\n    // the algorithm for detecting cyclic structures is adapted from ES 5.1\n    // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n    var initedStack = !stackA;\n    stackA || (stackA = []);\n    stackB || (stackB = []);\n\n    var length = stackA.length;\n    while (length--) {\n      if (stackA[length] == a) {\n        return stackB[length] == b;\n      }\n    }\n    var size = 0;\n    var result = true;\n\n    // add `a` and `b` to the stack of traversed objects\n    stackA.push(a);\n    stackB.push(b);\n\n    // recursively compare objects and arrays (susceptible to call stack limits)\n    if (isArr) {\n      // compare lengths to determine if a deep comparison is necessary\n      length = a.length;\n      size = b.length;\n      result = size == length;\n\n      if (result) {\n        // deep compare the contents, ignoring non-numeric properties\n        while (size--) {\n          var index = length,\n              value = b[size];\n\n          if (!(result = deepEquals(a[size], value, stackA, stackB))) {\n            break;\n          }\n        }\n      }\n    }\n    else {\n      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n      // which, in this case, is more costly\n      internalForIn(b, function(value, key, b) {\n        if (hasOwnProperty.call(b, key)) {\n          // count the number of properties.\n          size++;\n          // deep compare each property value.\n          return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));\n        }\n      });\n\n      if (result) {\n        // ensure both objects have the same number of properties\n        internalForIn(a, function(value, key, a) {\n          if (hasOwnProperty.call(a, key)) {\n            // `size` will be `-1` if `a` has more properties than `b`\n            return (result = --size > -1);\n          }\n        });\n      }\n    }\n    stackA.pop();\n    stackB.pop();\n\n    return result;\n  }\n\n  var slice = Array.prototype.slice;\n  function argsOrArray(args, idx) {\n    return args.length === 1 && Array.isArray(args[idx]) ?\n      args[idx] :\n      slice.call(args);\n  }\n  var hasProp = {}.hasOwnProperty;\n\n  var inherits = this.inherits = Rx.internals.inherits = function (child, parent) {\n    function __() { this.constructor = child; }\n    __.prototype = parent.prototype;\n    child.prototype = new __();\n  };\n\n  var addProperties = Rx.internals.addProperties = function (obj) {\n    var sources = slice.call(arguments, 1);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      var source = sources[i];\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  };\n\n  // Rx Utils\n  var addRef = Rx.internals.addRef = function (xs, r) {\n    return new AnonymousObservable(function (observer) {\n      return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));\n    });\n  };\n\n  function arrayInitialize(count, factory) {\n    var a = new Array(count);\n    for (var i = 0; i < count; i++) {\n      a[i] = factory();\n    }\n    return a;\n  }\n\n  // Collections\n  function IndexedItem(id, value) {\n    this.id = id;\n    this.value = value;\n  }\n\n  IndexedItem.prototype.compareTo = function (other) {\n    var c = this.value.compareTo(other.value);\n    c === 0 && (c = this.id - other.id);\n    return c;\n  };\n\n  // Priority Queue for Scheduling\n  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {\n    this.items = new Array(capacity);\n    this.length = 0;\n  };\n\n  var priorityProto = PriorityQueue.prototype;\n  priorityProto.isHigherPriority = function (left, right) {\n    return this.items[left].compareTo(this.items[right]) < 0;\n  };\n\n  priorityProto.percolate = function (index) {\n    if (index >= this.length || index < 0) { return; }\n    var parent = index - 1 >> 1;\n    if (parent < 0 || parent === index) { return; }\n    if (this.isHigherPriority(index, parent)) {\n      var temp = this.items[index];\n      this.items[index] = this.items[parent];\n      this.items[parent] = temp;\n      this.percolate(parent);\n    }\n  };\n\n  priorityProto.heapify = function (index) {\n    +index || (index = 0);\n    if (index >= this.length || index < 0) { return; }\n    var left = 2 * index + 1,\n        right = 2 * index + 2,\n        first = index;\n    if (left < this.length && this.isHigherPriority(left, first)) {\n      first = left;\n    }\n    if (right < this.length && this.isHigherPriority(right, first)) {\n      first = right;\n    }\n    if (first !== index) {\n      var temp = this.items[index];\n      this.items[index] = this.items[first];\n      this.items[first] = temp;\n      this.heapify(first);\n    }\n  };\n\n  priorityProto.peek = function () { return this.items[0].value; };\n\n  priorityProto.removeAt = function (index) {\n    this.items[index] = this.items[--this.length];\n    delete this.items[this.length];\n    this.heapify();\n  };\n\n  priorityProto.dequeue = function () {\n    var result = this.peek();\n    this.removeAt(0);\n    return result;\n  };\n\n  priorityProto.enqueue = function (item) {\n    var index = this.length++;\n    this.items[index] = new IndexedItem(PriorityQueue.count++, item);\n    this.percolate(index);\n  };\n\n  priorityProto.remove = function (item) {\n    for (var i = 0; i < this.length; i++) {\n      if (this.items[i].value === item) {\n        this.removeAt(i);\n        return true;\n      }\n    }\n    return false;\n  };\n  PriorityQueue.count = 0;\n\n  /**\n   * Represents a group of disposable resources that are disposed together.\n   * @constructor\n   */\n  var CompositeDisposable = Rx.CompositeDisposable = function () {\n    this.disposables = argsOrArray(arguments, 0);\n    this.isDisposed = false;\n    this.length = this.disposables.length;\n  };\n\n  var CompositeDisposablePrototype = CompositeDisposable.prototype;\n\n  /**\n   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.\n   * @param {Mixed} item Disposable to add.\n   */\n  CompositeDisposablePrototype.add = function (item) {\n    if (this.isDisposed) {\n      item.dispose();\n    } else {\n      this.disposables.push(item);\n      this.length++;\n    }\n  };\n\n  /**\n   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.\n   * @param {Mixed} item Disposable to remove.\n   * @returns {Boolean} true if found; false otherwise.\n   */\n  CompositeDisposablePrototype.remove = function (item) {\n    var shouldDispose = false;\n    if (!this.isDisposed) {\n      var idx = this.disposables.indexOf(item);\n      if (idx !== -1) {\n        shouldDispose = true;\n        this.disposables.splice(idx, 1);\n        this.length--;\n        item.dispose();\n      }\n    }\n    return shouldDispose;\n  };\n\n  /**\n   *  Disposes all disposables in the group and removes them from the group.\n   */\n  CompositeDisposablePrototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      var currentDisposables = this.disposables.slice(0);\n      this.disposables = [];\n      this.length = 0;\n\n      for (var i = 0, len = currentDisposables.length; i < len; i++) {\n        currentDisposables[i].dispose();\n      }\n    }\n  };\n\n  /**\n   * Converts the existing CompositeDisposable to an array of disposables\n   * @returns {Array} An array of disposable objects.\n   */\n  CompositeDisposablePrototype.toArray = function () {\n    return this.disposables.slice(0);\n  };\n\n  /**\n   * Provides a set of static methods for creating Disposables.\n   *\n   * @constructor\n   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n   */\n  var Disposable = Rx.Disposable = function (action) {\n    this.isDisposed = false;\n    this.action = action || noop;\n  };\n\n  /** Performs the task of cleaning up resources. */\n  Disposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.action();\n      this.isDisposed = true;\n    }\n  };\n\n  /**\n   * Creates a disposable object that invokes the specified action when disposed.\n   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n   * @return {Disposable} The disposable object that runs the given action upon disposal.\n   */\n  var disposableCreate = Disposable.create = function (action) { return new Disposable(action); };\n\n  /**\n   * Gets the disposable that does nothing when disposed.\n   */\n  var disposableEmpty = Disposable.empty = { dispose: noop };\n\n  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = (function () {\n    function BooleanDisposable () {\n      this.isDisposed = false;\n      this.current = null;\n    }\n\n    var booleanDisposablePrototype = BooleanDisposable.prototype;\n\n    /**\n     * Gets the underlying disposable.\n     * @return The underlying disposable.\n     */\n    booleanDisposablePrototype.getDisposable = function () {\n      return this.current;\n    };\n\n    /**\n     * Sets the underlying disposable.\n     * @param {Disposable} value The new underlying disposable.\n     */\n    booleanDisposablePrototype.setDisposable = function (value) {\n      var shouldDispose = this.isDisposed, old;\n      if (!shouldDispose) {\n        old = this.current;\n        this.current = value;\n      }\n      old && old.dispose();\n      shouldDispose && value && value.dispose();\n    };\n\n    /**\n     * Disposes the underlying disposable as well as all future replacements.\n     */\n    booleanDisposablePrototype.dispose = function () {\n      var old;\n      if (!this.isDisposed) {\n        this.isDisposed = true;\n        old = this.current;\n        this.current = null;\n      }\n      old && old.dispose();\n    };\n\n    return BooleanDisposable;\n  }());\n  var SerialDisposable = Rx.SerialDisposable = SingleAssignmentDisposable;\n\n    /**\n     * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.\n     */\n    var RefCountDisposable = Rx.RefCountDisposable = (function () {\n\n        function InnerDisposable(disposable) {\n            this.disposable = disposable;\n            this.disposable.count++;\n            this.isInnerDisposed = false;\n        }\n\n        InnerDisposable.prototype.dispose = function () {\n            if (!this.disposable.isDisposed) {\n                if (!this.isInnerDisposed) {\n                    this.isInnerDisposed = true;\n                    this.disposable.count--;\n                    if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {\n                        this.disposable.isDisposed = true;\n                        this.disposable.underlyingDisposable.dispose();\n                    }\n                }\n            }\n        };\n\n        /**\n         * Initializes a new instance of the RefCountDisposable with the specified disposable.\n         * @constructor\n         * @param {Disposable} disposable Underlying disposable.\n          */\n        function RefCountDisposable(disposable) {\n            this.underlyingDisposable = disposable;\n            this.isDisposed = false;\n            this.isPrimaryDisposed = false;\n            this.count = 0;\n        }\n\n        /**\n         * Disposes the underlying disposable only when all dependent disposables have been disposed\n         */\n        RefCountDisposable.prototype.dispose = function () {\n            if (!this.isDisposed) {\n                if (!this.isPrimaryDisposed) {\n                    this.isPrimaryDisposed = true;\n                    if (this.count === 0) {\n                        this.isDisposed = true;\n                        this.underlyingDisposable.dispose();\n                    }\n                }\n            }\n        };\n\n        /**\n         * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.\n         * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.\n         */\n        RefCountDisposable.prototype.getDisposable = function () {\n            return this.isDisposed ? disposableEmpty : new InnerDisposable(this);\n        };\n\n        return RefCountDisposable;\n    })();\n\n  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {\n    this.scheduler = scheduler;\n    this.state = state;\n    this.action = action;\n    this.dueTime = dueTime;\n    this.comparer = comparer || defaultSubComparer;\n    this.disposable = new SingleAssignmentDisposable();\n  }\n\n  ScheduledItem.prototype.invoke = function () {\n    this.disposable.setDisposable(this.invokeCore());\n  };\n\n  ScheduledItem.prototype.compareTo = function (other) {\n    return this.comparer(this.dueTime, other.dueTime);\n  };\n\n  ScheduledItem.prototype.isCancelled = function () {\n    return this.disposable.isDisposed;\n  };\n\n  ScheduledItem.prototype.invokeCore = function () {\n    return this.action(this.scheduler, this.state);\n  };\n\n  /** Provides a set of static properties to access commonly used schedulers. */\n  var Scheduler = Rx.Scheduler = (function () {\n\n    function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {\n      this.now = now;\n      this._schedule = schedule;\n      this._scheduleRelative = scheduleRelative;\n      this._scheduleAbsolute = scheduleAbsolute;\n    }\n\n    function invokeAction(scheduler, action) {\n      action();\n      return disposableEmpty;\n    }\n\n    var schedulerProto = Scheduler.prototype;\n\n    /**\n     * Schedules an action to be executed.\n     * @param {Function} action Action to execute.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.schedule = function (action) {\n      return this._schedule(action, invokeAction);\n    };\n\n    /**\n     * Schedules an action to be executed.\n     * @param state State passed to the action to be executed.\n     * @param {Function} action Action to be executed.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleWithState = function (state, action) {\n      return this._schedule(state, action);\n    };\n\n    /**\n     * Schedules an action to be executed after the specified relative due time.\n     * @param {Function} action Action to execute.\n     * @param {Number} dueTime Relative time after which to execute the action.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleWithRelative = function (dueTime, action) {\n      return this._scheduleRelative(action, dueTime, invokeAction);\n    };\n\n    /**\n     * Schedules an action to be executed after dueTime.\n     * @param state State passed to the action to be executed.\n     * @param {Function} action Action to be executed.\n     * @param {Number} dueTime Relative time after which to execute the action.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleWithRelativeAndState = function (state, dueTime, action) {\n      return this._scheduleRelative(state, dueTime, action);\n    };\n\n    /**\n     * Schedules an action to be executed at the specified absolute due time.\n     * @param {Function} action Action to execute.\n     * @param {Number} dueTime Absolute time at which to execute the action.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n      */\n    schedulerProto.scheduleWithAbsolute = function (dueTime, action) {\n      return this._scheduleAbsolute(action, dueTime, invokeAction);\n    };\n\n    /**\n     * Schedules an action to be executed at dueTime.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to be executed.\n     * @param {Number}dueTime Absolute time at which to execute the action.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleWithAbsoluteAndState = function (state, dueTime, action) {\n      return this._scheduleAbsolute(state, dueTime, action);\n    };\n\n    /** Gets the current time according to the local machine's system clock. */\n    Scheduler.now = defaultNow;\n\n    /**\n     * Normalizes the specified TimeSpan value to a positive value.\n     * @param {Number} timeSpan The time span value to normalize.\n     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0\n     */\n    Scheduler.normalize = function (timeSpan) {\n      timeSpan < 0 && (timeSpan = 0);\n      return timeSpan;\n    };\n\n    return Scheduler;\n  }());\n\n  var normalizeTime = Scheduler.normalize;\n\n  (function (schedulerProto) {\n    function invokeRecImmediate(scheduler, pair) {\n      var state = pair.first, action = pair.second, group = new CompositeDisposable(),\n      recursiveAction = function (state1) {\n        action(state1, function (state2) {\n          var isAdded = false, isDone = false,\n          d = scheduler.scheduleWithState(state2, function (scheduler1, state3) {\n            if (isAdded) {\n              group.remove(d);\n            } else {\n              isDone = true;\n            }\n            recursiveAction(state3);\n            return disposableEmpty;\n          });\n          if (!isDone) {\n            group.add(d);\n            isAdded = true;\n          }\n        });\n      };\n      recursiveAction(state);\n      return group;\n    }\n\n    function invokeRecDate(scheduler, pair, method) {\n      var state = pair.first, action = pair.second, group = new CompositeDisposable(),\n      recursiveAction = function (state1) {\n        action(state1, function (state2, dueTime1) {\n          var isAdded = false, isDone = false,\n          d = scheduler[method].call(scheduler, state2, dueTime1, function (scheduler1, state3) {\n            if (isAdded) {\n              group.remove(d);\n            } else {\n              isDone = true;\n            }\n            recursiveAction(state3);\n            return disposableEmpty;\n          });\n          if (!isDone) {\n            group.add(d);\n            isAdded = true;\n          }\n        });\n      };\n      recursiveAction(state);\n      return group;\n    }\n\n    function scheduleInnerRecursive(action, self) {\n      action(function(dt) { self(action, dt); });\n    }\n\n    /**\n     * Schedules an action to be executed recursively.\n     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursive = function (action) {\n      return this.scheduleRecursiveWithState(action, function (_action, self) {\n        _action(function () { self(_action); }); });\n    };\n\n    /**\n     * Schedules an action to be executed recursively.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursiveWithState = function (state, action) {\n      return this.scheduleWithState({ first: state, second: action }, invokeRecImmediate);\n    };\n\n    /**\n     * Schedules an action to be executed recursively after a specified relative due time.\n     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified relative time.\n     * @param {Number}dueTime Relative time after which to execute the action for the first time.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursiveWithRelative = function (dueTime, action) {\n      return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);\n    };\n\n    /**\n     * Schedules an action to be executed recursively after a specified relative due time.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.\n     * @param {Number}dueTime Relative time after which to execute the action for the first time.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursiveWithRelativeAndState = function (state, dueTime, action) {\n      return this._scheduleRelative({ first: state, second: action }, dueTime, function (s, p) {\n        return invokeRecDate(s, p, 'scheduleWithRelativeAndState');\n      });\n    };\n\n    /**\n     * Schedules an action to be executed recursively at a specified absolute due time.\n     * @param {Function} action Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified absolute time.\n     * @param {Number}dueTime Absolute time at which to execute the action for the first time.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursiveWithAbsolute = function (dueTime, action) {\n      return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);\n    };\n\n    /**\n     * Schedules an action to be executed recursively at a specified absolute due time.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.\n     * @param {Number}dueTime Absolute time at which to execute the action for the first time.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursiveWithAbsoluteAndState = function (state, dueTime, action) {\n      return this._scheduleAbsolute({ first: state, second: action }, dueTime, function (s, p) {\n        return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');\n      });\n    };\n  }(Scheduler.prototype));\n\n  (function (schedulerProto) {\n\n    /**\n     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.\n     * @param {Number} period Period for running the work periodically.\n     * @param {Function} action Action to be executed.\n     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n     */\n    Scheduler.prototype.schedulePeriodic = function (period, action) {\n      return this.schedulePeriodicWithState(null, period, action);\n    };\n\n    /**\n     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.\n     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n     * @param {Number} period Period for running the work periodically.\n     * @param {Function} action Action to be executed, potentially updating the state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n     */\n    Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {\n      if (typeof root.setInterval === 'undefined') { throw new Error('Periodic scheduling not supported.'); }\n      var s = state;\n\n      var id = root.setInterval(function () {\n        s = action(s);\n      }, period);\n\n      return disposableCreate(function () {\n        root.clearInterval(id);\n      });\n    };\n\n  }(Scheduler.prototype));\n\n  /** Gets a scheduler that schedules work immediately on the current thread. */\n  var immediateScheduler = Scheduler.immediate = (function () {\n\n    function scheduleNow(state, action) { return action(this, state); }\n\n    function scheduleRelative(state, dueTime, action) {\n      var dt = this.now() + normalizeTime(dueTime);\n      while (dt - this.now() > 0) { }\n      return action(this, state);\n    }\n\n    function scheduleAbsolute(state, dueTime, action) {\n      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);\n    }\n\n    return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);\n  }());\n\n  /**\n   * Gets a scheduler that schedules work as soon as possible on the current thread.\n   */\n  var currentThreadScheduler = Scheduler.currentThread = (function () {\n    var queue;\n\n    function runTrampoline (q) {\n      var item;\n      while (q.length > 0) {\n        item = q.dequeue();\n        if (!item.isCancelled()) {\n          // Note, do not schedule blocking work!\n          while (item.dueTime - Scheduler.now() > 0) {\n          }\n          if (!item.isCancelled()) {\n            item.invoke();\n          }\n        }\n      }\n    }\n\n    function scheduleNow(state, action) {\n      return this.scheduleWithRelativeAndState(state, 0, action);\n    }\n\n    function scheduleRelative(state, dueTime, action) {\n      var dt = this.now() + Scheduler.normalize(dueTime),\n          si = new ScheduledItem(this, state, action, dt);\n\n      if (!queue) {\n        queue = new PriorityQueue(4);\n        queue.enqueue(si);\n        try {\n          runTrampoline(queue);\n        } catch (e) {\n          throw e;\n        } finally {\n          queue = null;\n        }\n      } else {\n        queue.enqueue(si);\n      }\n      return si.disposable;\n    }\n\n    function scheduleAbsolute(state, dueTime, action) {\n      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);\n    }\n\n    var currentScheduler = new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);\n\n    currentScheduler.scheduleRequired = function () { return !queue; };\n    currentScheduler.ensureTrampoline = function (action) {\n      if (!queue) { this.schedule(action); } else { action(); }\n    };\n\n    return currentScheduler;\n  }());\n\n  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function () {\n    function tick(command, recurse) {\n      recurse(0, this._period);\n      try {\n        this._state = this._action(this._state);\n      } catch (e) {\n        this._cancel.dispose();\n        throw e;\n      }\n    }\n\n    function SchedulePeriodicRecursive(scheduler, state, period, action) {\n      this._scheduler = scheduler;\n      this._state = state;\n      this._period = period;\n      this._action = action;\n    }\n\n    SchedulePeriodicRecursive.prototype.start = function () {\n      var d = new SingleAssignmentDisposable();\n      this._cancel = d;\n      d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));\n\n      return d;\n    };\n\n    return SchedulePeriodicRecursive;\n  }());\n\n  var scheduleMethod, clearMethod = noop;\n  var localTimer = (function () {\n    var localSetTimeout, localClearTimeout = noop;\n    if ('WScript' in this) {\n      localSetTimeout = function (fn, time) {\n        WScript.Sleep(time);\n        fn();\n      };\n    } else if (!!root.setTimeout) {\n      localSetTimeout = root.setTimeout;\n      localClearTimeout = root.clearTimeout;\n    } else {\n      throw new Error('No concurrency detected!');\n    }\n\n    return {\n      setTimeout: localSetTimeout,\n      clearTimeout: localClearTimeout\n    };\n  }());\n  var localSetTimeout = localTimer.setTimeout,\n    localClearTimeout = localTimer.clearTimeout;\n\n  (function () {\n\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' &&\n      !reNative.test(setImmediate) && setImmediate,\n      clearImmediate = typeof (clearImmediate = freeGlobal && moduleExports && freeGlobal.clearImmediate) == 'function' &&\n      !reNative.test(clearImmediate) && clearImmediate;\n\n    function postMessageSupported () {\n      // Ensure not in a worker\n      if (!root.postMessage || root.importScripts) { return false; }\n      var isAsync = false,\n          oldHandler = root.onmessage;\n      // Test for async\n      root.onmessage = function () { isAsync = true; };\n      root.postMessage('', '*');\n      root.onmessage = oldHandler;\n\n      return isAsync;\n    }\n\n    // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout\n    if (typeof setImmediate === 'function') {\n      scheduleMethod = setImmediate;\n      clearMethod = clearImmediate;\n    } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n      scheduleMethod = process.nextTick;\n    } else if (postMessageSupported()) {\n      var MSG_PREFIX = 'ms.rx.schedule' + Math.random(),\n        tasks = {},\n        taskId = 0;\n\n      var onGlobalPostMessage = function (event) {\n        // Only if we're a match to avoid any other global events\n        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {\n          var handleId = event.data.substring(MSG_PREFIX.length),\n            action = tasks[handleId];\n          action();\n          delete tasks[handleId];\n        }\n      }\n\n      if (root.addEventListener) {\n        root.addEventListener('message', onGlobalPostMessage, false);\n      } else {\n        root.attachEvent('onmessage', onGlobalPostMessage, false);\n      }\n\n      scheduleMethod = function (action) {\n        var currentId = taskId++;\n        tasks[currentId] = action;\n        root.postMessage(MSG_PREFIX + currentId, '*');\n      };\n    } else if (!!root.MessageChannel) {\n      var channel = new root.MessageChannel(),\n        channelTasks = {},\n        channelTaskId = 0;\n\n      channel.port1.onmessage = function (event) {\n        var id = event.data,\n          action = channelTasks[id];\n        action();\n        delete channelTasks[id];\n      };\n\n      scheduleMethod = function (action) {\n        var id = channelTaskId++;\n        channelTasks[id] = action;\n        channel.port2.postMessage(id);\n      };\n    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {\n\n      scheduleMethod = function (action) {\n        var scriptElement = root.document.createElement('script');\n        scriptElement.onreadystatechange = function () {\n          action();\n          scriptElement.onreadystatechange = null;\n          scriptElement.parentNode.removeChild(scriptElement);\n          scriptElement = null;\n        };\n        root.document.documentElement.appendChild(scriptElement);\n      };\n\n    } else {\n      scheduleMethod = function (action) { return localSetTimeout(action, 0); };\n      clearMethod = localClearTimeout;\n    }\n  }());\n\n  /**\n   * Gets a scheduler that schedules work via a timed callback based upon platform.\n   */\n  var timeoutScheduler = Scheduler.timeout = (function () {\n\n    function scheduleNow(state, action) {\n      var scheduler = this,\n        disposable = new SingleAssignmentDisposable();\n      var id = scheduleMethod(function () {\n        if (!disposable.isDisposed) {\n          disposable.setDisposable(action(scheduler, state));\n        }\n      });\n      return new CompositeDisposable(disposable, disposableCreate(function () {\n        clearMethod(id);\n      }));\n    }\n\n    function scheduleRelative(state, dueTime, action) {\n      var scheduler = this,\n        dt = Scheduler.normalize(dueTime);\n      if (dt === 0) {\n        return scheduler.scheduleWithState(state, action);\n      }\n      var disposable = new SingleAssignmentDisposable();\n      var id = localSetTimeout(function () {\n        if (!disposable.isDisposed) {\n          disposable.setDisposable(action(scheduler, state));\n        }\n      }, dt);\n      return new CompositeDisposable(disposable, disposableCreate(function () {\n        localClearTimeout(id);\n      }));\n    }\n\n    function scheduleAbsolute(state, dueTime, action) {\n      return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);\n    }\n\n    return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);\n  })();\n\n  /**\n   *  Represents a notification to an observer.\n   */\n  var Notification = Rx.Notification = (function () {\n    function Notification(kind, hasValue) {\n      this.hasValue = hasValue == null ? false : hasValue;\n      this.kind = kind;\n    }\n\n    /**\n     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.\n     *\n     * @memberOf Notification\n     * @param {Any} observerOrOnNext Delegate to invoke for an OnNext notification or Observer to invoke the notification on..\n     * @param {Function} onError Delegate to invoke for an OnError notification.\n     * @param {Function} onCompleted Delegate to invoke for an OnCompleted notification.\n     * @returns {Any} Result produced by the observation.\n     */\n    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {\n      return observerOrOnNext && typeof observerOrOnNext === 'object' ?\n        this._acceptObservable(observerOrOnNext) :\n        this._accept(observerOrOnNext, onError, onCompleted);\n    };\n\n    /**\n     * Returns an observable sequence with a single notification.\n     *\n     * @memberOf Notifications\n     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.\n     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.\n     */\n    Notification.prototype.toObservable = function (scheduler) {\n      var notification = this;\n      isScheduler(scheduler) || (scheduler = immediateScheduler);\n      return new AnonymousObservable(function (observer) {\n        return scheduler.schedule(function () {\n          notification._acceptObservable(observer);\n          notification.kind === 'N' && observer.onCompleted();\n        });\n      });\n    };\n\n    return Notification;\n  })();\n\n  /**\n   * Creates an object that represents an OnNext notification to an observer.\n   * @param {Any} value The value contained in the notification.\n   * @returns {Notification} The OnNext notification containing the value.\n   */\n  var notificationCreateOnNext = Notification.createOnNext = (function () {\n\n      function _accept (onNext) { return onNext(this.value); }\n      function _acceptObservable(observer) { return observer.onNext(this.value); }\n      function toString () { return 'OnNext(' + this.value + ')'; }\n\n      return function (value) {\n        var notification = new Notification('N', true);\n        notification.value = value;\n        notification._accept = _accept;\n        notification._acceptObservable = _acceptObservable;\n        notification.toString = toString;\n        return notification;\n      };\n  }());\n\n  /**\n   * Creates an object that represents an OnError notification to an observer.\n   * @param {Any} error The exception contained in the notification.\n   * @returns {Notification} The OnError notification containing the exception.\n   */\n  var notificationCreateOnError = Notification.createOnError = (function () {\n\n    function _accept (onNext, onError) { return onError(this.exception); }\n    function _acceptObservable(observer) { return observer.onError(this.exception); }\n    function toString () { return 'OnError(' + this.exception + ')'; }\n\n    return function (e) {\n      var notification = new Notification('E');\n      notification.exception = e;\n      notification._accept = _accept;\n      notification._acceptObservable = _acceptObservable;\n      notification.toString = toString;\n      return notification;\n    };\n  }());\n\n  /**\n   * Creates an object that represents an OnCompleted notification to an observer.\n   * @returns {Notification} The OnCompleted notification.\n   */\n  var notificationCreateOnCompleted = Notification.createOnCompleted = (function () {\n\n    function _accept (onNext, onError, onCompleted) { return onCompleted(); }\n    function _acceptObservable(observer) { return observer.onCompleted(); }\n    function toString () { return 'OnCompleted()'; }\n\n    return function () {\n      var notification = new Notification('C');\n      notification._accept = _accept;\n      notification._acceptObservable = _acceptObservable;\n      notification.toString = toString;\n      return notification;\n    };\n  }());\n\n  var Enumerator = Rx.internals.Enumerator = function (next) {\n    this._next = next;\n  };\n\n  Enumerator.prototype.next = function () {\n    return this._next();\n  };\n\n  Enumerator.prototype[$iterator$] = function () { return this; }\n\n  var Enumerable = Rx.internals.Enumerable = function (iterator) {\n    this._iterator = iterator;\n  };\n\n  Enumerable.prototype[$iterator$] = function () {\n    return this._iterator();\n  };\n\n  Enumerable.prototype.concat = function () {\n    var sources = this;\n    return new AnonymousObservable(function (observer) {\n      var e;\n      try {\n        e = sources[$iterator$]();\n      } catch (err) {\n        observer.onError(err);\n        return;\n      }\n\n      var isDisposed,\n        subscription = new SerialDisposable();\n      var cancelable = immediateScheduler.scheduleRecursive(function (self) {\n        var currentItem;\n        if (isDisposed) { return; }\n\n        try {\n          currentItem = e.next();\n        } catch (ex) {\n          observer.onError(ex);\n          return;\n        }\n\n        if (currentItem.done) {\n          observer.onCompleted();\n          return;\n        }\n\n        // Check if promise\n        var currentValue = currentItem.value;\n        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n        var d = new SingleAssignmentDisposable();\n        subscription.setDisposable(d);\n        d.setDisposable(currentValue.subscribe(\n          observer.onNext.bind(observer),\n          observer.onError.bind(observer),\n          function () { self(); })\n        );\n      });\n\n      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {\n        isDisposed = true;\n      }));\n    });\n  };\n\n  Enumerable.prototype.catchError = function () {\n    var sources = this;\n    return new AnonymousObservable(function (observer) {\n      var e;\n      try {\n        e = sources[$iterator$]();\n      } catch (err) {\n        observer.onError(err);\n        return;\n      }\n\n      var isDisposed,\n        lastException,\n        subscription = new SerialDisposable();\n      var cancelable = immediateScheduler.scheduleRecursive(function (self) {\n        if (isDisposed) { return; }\n\n        var currentItem;\n        try {\n          currentItem = e.next();\n        } catch (ex) {\n          observer.onError(ex);\n          return;\n        }\n\n        if (currentItem.done) {\n          if (lastException) {\n            observer.onError(lastException);\n          } else {\n            observer.onCompleted();\n          }\n          return;\n        }\n\n        // Check if promise\n        var currentValue = currentItem.value;\n        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n        var d = new SingleAssignmentDisposable();\n        subscription.setDisposable(d);\n        d.setDisposable(currentValue.subscribe(\n          observer.onNext.bind(observer),\n          function (exn) {\n            lastException = exn;\n            self();\n          },\n          observer.onCompleted.bind(observer)));\n      });\n      return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {\n        isDisposed = true;\n      }));\n    });\n  };\n\n\n  Enumerable.prototype.catchErrorWhen = function (notificationHandler) {\n    var sources = this;\n    return new AnonymousObservable(function (observer) {\n      var e;\n\n      var exceptions = new Subject();\n\n      var handled = notificationHandler(exceptions);\n\n      var notifier = new Subject();\n\n      var notificationDisposable = handled.subscribe(notifier);\n\n      try {\n        e = sources[$iterator$]();\n      } catch (err) {\n        observer.onError(err);\n        return;\n      }\n\n      var isDisposed,\n        lastException,\n        subscription = new SerialDisposable();\n      var cancelable = immediateScheduler.scheduleRecursive(function (self) {\n        if (isDisposed) { return; }\n\n        var currentItem;\n        try {\n          currentItem = e.next();\n        } catch (ex) {\n          observer.onError(ex);\n          return;\n        }\n\n        if (currentItem.done) {\n          if (lastException) {\n            observer.onError(lastException);\n          } else {\n            observer.onCompleted();\n          }\n          return;\n        }\n\n        // Check if promise\n        var currentValue = currentItem.value;\n        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n        var outer = new SingleAssignmentDisposable();\n        var inner = new SingleAssignmentDisposable();\n        subscription.setDisposable(new CompositeDisposable(inner, outer));\n        outer.setDisposable(currentValue.subscribe(\n          observer.onNext.bind(observer),\n          function (exn) {\n            inner.setDisposable(notifier.subscribe(function(){\n              self();\n            }, function(ex) {\n              observer.onError(ex);\n            }, function() {\n              observer.onCompleted();\n            }));\n\n            exceptions.onNext(exn);\n          },\n          observer.onCompleted.bind(observer)));\n      });\n\n      return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function () {\n        isDisposed = true;\n      }));\n    });\n  };\n\n  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {\n    if (repeatCount == null) { repeatCount = -1; }\n    return new Enumerable(function () {\n      var left = repeatCount;\n      return new Enumerator(function () {\n        if (left === 0) { return doneEnumerator; }\n        if (left > 0) { left--; }\n        return { done: false, value: value };\n      });\n    });\n  };\n\n  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {\n    selector || (selector = identity);\n    return new Enumerable(function () {\n      var index = -1;\n      return new Enumerator(\n        function () {\n          return ++index < source.length ?\n            { done: false, value: selector.call(thisArg, source[index], index, source) } :\n            doneEnumerator;\n        });\n    });\n  };\n\n  /**\n   * Supports push-style iteration over an observable sequence.\n   */\n  var Observer = Rx.Observer = function () { };\n\n  /**\n   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.\n   * @param {Function} [onNext] Observer's OnNext action implementation.\n   * @param {Function} [onError] Observer's OnError action implementation.\n   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.\n   * @returns {Observer} The observer object implemented using the given actions.\n   */\n  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {\n    onNext || (onNext = noop);\n    onError || (onError = defaultError);\n    onCompleted || (onCompleted = noop);\n    return new AnonymousObserver(onNext, onError, onCompleted);\n  };\n\n  /**\n   * Abstract base class for implementations of the Observer class.\n   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.\n   */\n  var AbstractObserver = Rx.internals.AbstractObserver = (function (__super__) {\n    inherits(AbstractObserver, __super__);\n\n    /**\n     * Creates a new observer in a non-stopped state.\n     */\n    function AbstractObserver() {\n      this.isStopped = false;\n      __super__.call(this);\n    }\n\n    /**\n     * Notifies the observer of a new element in the sequence.\n     * @param {Any} value Next element in the sequence.\n     */\n    AbstractObserver.prototype.onNext = function (value) {\n      if (!this.isStopped) { this.next(value); }\n    };\n\n    /**\n     * Notifies the observer that an exception has occurred.\n     * @param {Any} error The error that has occurred.\n     */\n    AbstractObserver.prototype.onError = function (error) {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.error(error);\n      }\n    };\n\n    /**\n     * Notifies the observer of the end of the sequence.\n     */\n    AbstractObserver.prototype.onCompleted = function () {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.completed();\n      }\n    };\n\n    /**\n     * Disposes the observer, causing it to transition to the stopped state.\n     */\n    AbstractObserver.prototype.dispose = function () {\n      this.isStopped = true;\n    };\n\n    AbstractObserver.prototype.fail = function (e) {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.error(e);\n        return true;\n      }\n\n      return false;\n    };\n\n    return AbstractObserver;\n  }(Observer));\n\n  /**\n   * Class to create an Observer instance from delegate-based implementations of the on* methods.\n   */\n  var AnonymousObserver = Rx.AnonymousObserver = (function (__super__) {\n    inherits(AnonymousObserver, __super__);\n\n    /**\n     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.\n     * @param {Any} onNext Observer's OnNext action implementation.\n     * @param {Any} onError Observer's OnError action implementation.\n     * @param {Any} onCompleted Observer's OnCompleted action implementation.\n     */\n    function AnonymousObserver(onNext, onError, onCompleted) {\n      __super__.call(this);\n      this._onNext = onNext;\n      this._onError = onError;\n      this._onCompleted = onCompleted;\n    }\n\n    /**\n     * Calls the onNext action.\n     * @param {Any} value Next element in the sequence.\n     */\n    AnonymousObserver.prototype.next = function (value) {\n      this._onNext(value);\n    };\n\n    /**\n     * Calls the onError action.\n     * @param {Any} error The error that has occurred.\n     */\n    AnonymousObserver.prototype.error = function (error) {\n      this._onError(error);\n    };\n\n    /**\n     *  Calls the onCompleted action.\n     */\n    AnonymousObserver.prototype.completed = function () {\n      this._onCompleted();\n    };\n\n    return AnonymousObserver;\n  }(AbstractObserver));\n\n  var observableProto;\n\n  /**\n   * Represents a push-style collection.\n   */\n  var Observable = Rx.Observable = (function () {\n\n    function Observable(subscribe) {\n      if (Rx.config.longStackSupport && hasStacks) {\n        try {\n          throw new Error();\n        } catch (e) {\n          this.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n\n        var self = this;\n        this._subscribe = function (observer) {\n          var oldOnError = observer.onError.bind(observer);\n\n          observer.onError = function (err) {\n            makeStackTraceLong(err, self);\n            oldOnError(err);\n          };\n\n          return subscribe.call(self, observer);\n        };\n      } else {\n        this._subscribe = subscribe;\n      }\n    }\n\n    observableProto = Observable.prototype;\n\n    /**\n     *  Subscribes an observer to the observable sequence.\n     *  @param {Mixed} [observerOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribe = observableProto.forEach = function (observerOrOnNext, onError, onCompleted) {\n      return this._subscribe(typeof observerOrOnNext === 'object' ?\n        observerOrOnNext :\n        observerCreate(observerOrOnNext, onError, onCompleted));\n    };\n\n    /**\n     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n     * @param {Function} onNext The function to invoke on each element in the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribeOnNext = function (onNext, thisArg) {\n      return this._subscribe(observerCreate(arguments.length === 2 ? function(x) { onNext.call(thisArg, x); } : onNext));\n    };\n\n    /**\n     * Subscribes to an exceptional condition in the sequence with an optional \"this\" argument.\n     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribeOnError = function (onError, thisArg) {\n      return this._subscribe(observerCreate(null, arguments.length === 2 ? function(e) { onError.call(thisArg, e); } : onError));\n    };\n\n    /**\n     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {\n      return this._subscribe(observerCreate(null, null, arguments.length === 2 ? function() { onCompleted.call(thisArg); } : onCompleted));\n    };\n\n    return Observable;\n  })();\n\n  var ScheduledObserver = Rx.internals.ScheduledObserver = (function (__super__) {\n    inherits(ScheduledObserver, __super__);\n\n    function ScheduledObserver(scheduler, observer) {\n      __super__.call(this);\n      this.scheduler = scheduler;\n      this.observer = observer;\n      this.isAcquired = false;\n      this.hasFaulted = false;\n      this.queue = [];\n      this.disposable = new SerialDisposable();\n    }\n\n    ScheduledObserver.prototype.next = function (value) {\n      var self = this;\n      this.queue.push(function () { self.observer.onNext(value); });\n    };\n\n    ScheduledObserver.prototype.error = function (e) {\n      var self = this;\n      this.queue.push(function () { self.observer.onError(e); });\n    };\n\n    ScheduledObserver.prototype.completed = function () {\n      var self = this;\n      this.queue.push(function () { self.observer.onCompleted(); });\n    };\n\n    ScheduledObserver.prototype.ensureActive = function () {\n      var isOwner = false, parent = this;\n      if (!this.hasFaulted && this.queue.length > 0) {\n        isOwner = !this.isAcquired;\n        this.isAcquired = true;\n      }\n      if (isOwner) {\n        this.disposable.setDisposable(this.scheduler.scheduleRecursive(function (self) {\n          var work;\n          if (parent.queue.length > 0) {\n            work = parent.queue.shift();\n          } else {\n            parent.isAcquired = false;\n            return;\n          }\n          try {\n            work();\n          } catch (ex) {\n            parent.queue = [];\n            parent.hasFaulted = true;\n            throw ex;\n          }\n          self();\n        }));\n      }\n    };\n\n    ScheduledObserver.prototype.dispose = function () {\n      __super__.prototype.dispose.call(this);\n      this.disposable.dispose();\n    };\n\n    return ScheduledObserver;\n  }(AbstractObserver));\n\n  /**\n   * Creates an array from an observable sequence.\n   * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.\n   */\n  observableProto.toArray = function () {\n    var source = this;\n    return new AnonymousObservable(function(observer) {\n      var arr = [];\n      return source.subscribe(\n        function (x) { arr.push(x); },\n        function (e) { observer.onError(e); },\n        function () {\n          observer.onNext(arr);\n          observer.onCompleted();\n        });\n    }, source);\n  };\n\n  /**\n   *  Creates an observable sequence from a specified subscribe method implementation.\n   * @example\n   *  var res = Rx.Observable.create(function (observer) { return function () { } );\n   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );\n   *  var res = Rx.Observable.create(function (observer) { } );\n   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.\n   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.\n   */\n  Observable.create = Observable.createWithDisposable = function (subscribe, parent) {\n    return new AnonymousObservable(subscribe, parent);\n  };\n\n  /**\n   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.\n   *\n   * @example\n   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });\n   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.\n   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.\n   */\n  var observableDefer = Observable.defer = function (observableFactory) {\n    return new AnonymousObservable(function (observer) {\n      var result;\n      try {\n        result = observableFactory();\n      } catch (e) {\n        return observableThrow(e).subscribe(observer);\n      }\n      isPromise(result) && (result = observableFromPromise(result));\n      return result.subscribe(observer);\n    });\n  };\n\n  /**\n   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.\n   *\n   * @example\n   *  var res = Rx.Observable.empty();\n   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);\n   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.\n   * @returns {Observable} An observable sequence with no elements.\n   */\n  var observableEmpty = Observable.empty = function (scheduler) {\n    isScheduler(scheduler) || (scheduler = immediateScheduler);\n    return new AnonymousObservable(function (observer) {\n      return scheduler.schedule(function () {\n        observer.onCompleted();\n      });\n    });\n  };\n\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n\n  function StringIterable(str) {\n    this._s = s;\n  }\n\n  StringIterable.prototype[$iterator$] = function () {\n    return new StringIterator(this._s);\n  };\n\n  function StringIterator(str) {\n    this._s = s;\n    this._l = s.length;\n    this._i = 0;\n  }\n\n  StringIterator.prototype[$iterator$] = function () {\n    return this;\n  };\n\n  StringIterator.prototype.next = function () {\n    if (this._i < this._l) {\n      var val = this._s.charAt(this._i++);\n      return { done: false, value: val };\n    } else {\n      return doneEnumerator;\n    }\n  };\n\n  function ArrayIterable(a) {\n    this._a = a;\n  }\n\n  ArrayIterable.prototype[$iterator$] = function () {\n    return new ArrayIterator(this._a);\n  };\n\n  function ArrayIterator(a) {\n    this._a = a;\n    this._l = toLength(a);\n    this._i = 0;\n  }\n\n  ArrayIterator.prototype[$iterator$] = function () {\n    return this;\n  };\n\n  ArrayIterator.prototype.next = function () {\n    if (this._i < this._l) {\n      var val = this._a[this._i++];\n      return { done: false, value: val };\n    } else {\n      return doneEnumerator;\n    }\n  };\n\n  function numberIsFinite(value) {\n    return typeof value === 'number' && root.isFinite(value);\n  }\n\n  function isNan(n) {\n    return n !== n;\n  }\n\n  function getIterable(o) {\n    var i = o[$iterator$], it;\n    if (!i && typeof o === 'string') {\n      it = new StringIterable(o);\n      return it[$iterator$]();\n    }\n    if (!i && o.length !== undefined) {\n      it = new ArrayIterable(o);\n      return it[$iterator$]();\n    }\n    if (!i) { throw new TypeError('Object is not iterable'); }\n    return o[$iterator$]();\n  }\n\n  function sign(value) {\n    var number = +value;\n    if (number === 0) { return number; }\n    if (isNaN(number)) { return number; }\n    return number < 0 ? -1 : 1;\n  }\n\n  function toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) { return 0; }\n    if (len === 0 || !numberIsFinite(len)) { return len; }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) { return 0; }\n    if (len > maxSafeInteger) { return maxSafeInteger; }\n    return len;\n  }\n\n  /**\n   * This method creates a new Observable sequence from an array-like or iterable object.\n   * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.\n   * @param {Function} [mapFn] Map function to call on every element of the array.\n   * @param {Any} [thisArg] The context to use calling the mapFn if provided.\n   * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.\n   */\n  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {\n    if (iterable == null) {\n      throw new Error('iterable cannot be null.')\n    }\n    if (mapFn && !isFunction(mapFn)) {\n      throw new Error('mapFn when provided must be a function');\n    }\n    if (mapFn) {\n      var mapper = bindCallback(mapFn, thisArg, 2);\n    }\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    var list = Object(iterable), it = getIterable(list);\n    return new AnonymousObservable(function (observer) {\n      var i = 0;\n      return scheduler.scheduleRecursive(function (self) {\n        var next;\n        try {\n          next = it.next();\n        } catch (e) {\n          observer.onError(e);\n          return;\n        }\n        if (next.done) {\n          observer.onCompleted();\n          return;\n        }\n\n        var result = next.value;\n\n        if (mapper) {\n          try {\n            result = mapper(result, i);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n        }\n\n        observer.onNext(result);\n        i++;\n        self();\n      });\n    });\n  };\n\n  /**\n   *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.\n   * @deprecated use Observable.from or Observable.of\n   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n   * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.\n   */\n  var observableFromArray = Observable.fromArray = function (array, scheduler) {\n    //deprecate('fromArray', 'from');\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new AnonymousObservable(function (observer) {\n      var count = 0, len = array.length;\n      return scheduler.scheduleRecursive(function (self) {\n        if (count < len) {\n          observer.onNext(array[count++]);\n          self();\n        } else {\n          observer.onCompleted();\n        }\n      });\n    });\n  };\n\n  /**\n   *  Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).\n   * @returns {Observable} An observable sequence whose observers will never get called.\n   */\n  var observableNever = Observable.never = function () {\n    return new AnonymousObservable(function () {\n      return disposableEmpty;\n    });\n  };\n\n  function observableOf (scheduler, array) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new AnonymousObservable(function (observer) {\n      var count = 0, len = array.length;\n      return scheduler.scheduleRecursive(function (self) {\n        if (count < len) {\n          observer.onNext(array[count++]);\n          self();\n        } else {\n          observer.onCompleted();\n        }\n      });\n    });\n  }\n\n  /**\n   *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n   * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n   */\n  Observable.of = function () {\n    return observableOf(null, arguments);\n  };\n\n  /**\n   *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n   * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.\n   * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n   */\n  Observable.ofWithScheduler = function (scheduler) {\n    return observableOf(scheduler, slice.call(arguments, 1));\n  };\n\n  /**\n   * Convert an object into an observable sequence of [key, value] pairs.\n   * @param {Object} obj The object to inspect.\n   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n   * @returns {Observable} An observable sequence of [key, value] pairs from the object.\n   */\n  Observable.pairs = function (obj, scheduler) {\n    scheduler || (scheduler = Rx.Scheduler.currentThread);\n    return new AnonymousObservable(function (observer) {\n      var idx = 0, keys = Object.keys(obj), len = keys.length;\n      return scheduler.scheduleRecursive(function (self) {\n        if (idx < len) {\n          var key = keys[idx++];\n          observer.onNext([key, obj[key]]);\n          self();\n        } else {\n          observer.onCompleted();\n        }\n      });\n    });\n  };\n\n  /**\n   *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.\n   *\n   * @example\n   *  var res = Rx.Observable.range(0, 10);\n   *  var res = Rx.Observable.range(0, 10, Rx.Scheduler.timeout);\n   * @param {Number} start The value of the first integer in the sequence.\n   * @param {Number} count The number of sequential integers to generate.\n   * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.\n   * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.\n   */\n  Observable.range = function (start, count, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new AnonymousObservable(function (observer) {\n      return scheduler.scheduleRecursiveWithState(0, function (i, self) {\n        if (i < count) {\n          observer.onNext(start + i);\n          self(i + 1);\n        } else {\n          observer.onCompleted();\n        }\n      });\n    });\n  };\n\n  /**\n   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.\n   *\n   * @example\n   *  var res = Rx.Observable.repeat(42);\n   *  var res = Rx.Observable.repeat(42, 4);\n   *  3 - res = Rx.Observable.repeat(42, 4, Rx.Scheduler.timeout);\n   *  4 - res = Rx.Observable.repeat(42, null, Rx.Scheduler.timeout);\n   * @param {Mixed} value Element to repeat.\n   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.\n   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.\n   */\n  Observable.repeat = function (value, repeatCount, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return observableReturn(value, scheduler).repeat(repeatCount == null ? -1 : repeatCount);\n  };\n\n  /**\n   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.\n   *  There is an alias called 'just', and 'returnValue' for browsers <IE9.\n   * @param {Mixed} value Single element in the resulting observable sequence.\n   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} An observable sequence containing the single specified element.\n   */\n  var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {\n    isScheduler(scheduler) || (scheduler = immediateScheduler);\n    return new AnonymousObservable(function (observer) {\n      return scheduler.schedule(function () {\n        observer.onNext(value);\n        observer.onCompleted();\n      });\n    });\n  };\n\n  /** @deprecated use return or just */\n  Observable.returnValue = function () {\n    //deprecate('returnValue', 'return or just');\n    return observableReturn.apply(null, arguments);\n  };\n\n  /**\n   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.\n   *  There is an alias to this method called 'throwError' for browsers <IE9.\n   * @param {Mixed} error An object used for the sequence's termination.\n   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.\n   */\n  var observableThrow = Observable['throw'] = Observable.throwError = function (error, scheduler) {\n    isScheduler(scheduler) || (scheduler = immediateScheduler);\n    return new AnonymousObservable(function (observer) {\n      return scheduler.schedule(function () {\n        observer.onError(error);\n      });\n    });\n  };\n\n  /** @deprecated use #some instead */\n  Observable.throwException = function () {\n    //deprecate('throwException', 'throwError');\n    return Observable.throwError.apply(null, arguments);\n  };\n\n  function observableCatchHandler(source, handler) {\n    return new AnonymousObservable(function (observer) {\n      var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();\n      subscription.setDisposable(d1);\n      d1.setDisposable(source.subscribe(observer.onNext.bind(observer), function (exception) {\n        var d, result;\n        try {\n          result = handler(exception);\n        } catch (ex) {\n          observer.onError(ex);\n          return;\n        }\n        isPromise(result) && (result = observableFromPromise(result));\n\n        d = new SingleAssignmentDisposable();\n        subscription.setDisposable(d);\n        d.setDisposable(result.subscribe(observer));\n      }, observer.onCompleted.bind(observer)));\n\n      return subscription;\n    }, source);\n  }\n\n  /**\n   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n   * @example\n   * 1 - xs.catchException(ys)\n   * 2 - xs.catchException(function (ex) { return ys(ex); })\n   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.\n   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.\n   */\n  observableProto['catch'] = observableProto.catchError = function (handlerOrSecond) {\n    return typeof handlerOrSecond === 'function' ?\n      observableCatchHandler(this, handlerOrSecond) :\n      observableCatch([this, handlerOrSecond]);\n  };\n\n  /**\n   * @deprecated use #catch or #catchError instead.\n   */\n  observableProto.catchException = function (handlerOrSecond) {\n    //deprecate('catchException', 'catch or catchError');\n    return this.catchError(handlerOrSecond);\n  };\n\n  /**\n   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.\n   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.\n   */\n  var observableCatch = Observable.catchError = Observable['catch'] = function () {\n    return enumerableOf(argsOrArray(arguments, 0)).catchError();\n  };\n\n  /**\n   * @deprecated use #catch or #catchError instead.\n   */\n  Observable.catchException = function () {\n    //deprecate('catchException', 'catch or catchError');\n    return observableCatch.apply(null, arguments);\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n   * This can be in the form of an argument list of observables or an array.\n   *\n   * @example\n   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  observableProto.combineLatest = function () {\n    var args = slice.call(arguments);\n    if (Array.isArray(args[0])) {\n      args[0].unshift(this);\n    } else {\n      args.unshift(this);\n    }\n    return combineLatest.apply(this, args);\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n   *\n   * @example\n   * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n   * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  var combineLatest = Observable.combineLatest = function () {\n    var args = slice.call(arguments), resultSelector = args.pop();\n\n    if (Array.isArray(args[0])) {\n      args = args[0];\n    }\n\n    return new AnonymousObservable(function (observer) {\n      var falseFactory = function () { return false; },\n        n = args.length,\n        hasValue = arrayInitialize(n, falseFactory),\n        hasValueAll = false,\n        isDone = arrayInitialize(n, falseFactory),\n        values = new Array(n);\n\n      function next(i) {\n        var res;\n        hasValue[i] = true;\n        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {\n          try {\n            res = resultSelector.apply(null, values);\n          } catch (ex) {\n            observer.onError(ex);\n            return;\n          }\n          observer.onNext(res);\n        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {\n          observer.onCompleted();\n        }\n      }\n\n      function done (i) {\n        isDone[i] = true;\n        if (isDone.every(identity)) {\n          observer.onCompleted();\n        }\n      }\n\n      var subscriptions = new Array(n);\n      for (var idx = 0; idx < n; idx++) {\n        (function (i) {\n          var source = args[i], sad = new SingleAssignmentDisposable();\n          isPromise(source) && (source = observableFromPromise(source));\n          sad.setDisposable(source.subscribe(function (x) {\n              values[i] = x;\n              next(i);\n            },\n            function(e) { observer.onError(e); },\n            function () { done(i); }\n          ));\n          subscriptions[i] = sad;\n        }(idx));\n      }\n\n      return new CompositeDisposable(subscriptions);\n    }, this);\n  };\n\n  /**\n   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.\n   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n   */\n  observableProto.concat = function () {\n    var items = slice.call(arguments, 0);\n    items.unshift(this);\n    return observableConcat.apply(this, items);\n  };\n\n  /**\n   * Concatenates all the observable sequences.\n   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.\n   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n   */\n  var observableConcat = Observable.concat = function () {\n    return enumerableOf(argsOrArray(arguments, 0)).concat();\n  };\n\n  /**\n   * Concatenates an observable sequence of observable sequences.\n   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.\n   */\n  observableProto.concatAll = function () {\n    return this.merge(1);\n  };\n\n  /** @deprecated Use `concatAll` instead. */\n  observableProto.concatObservable = function () {\n    //deprecate('concatObservable', 'concatAll');\n    return this.merge(1);\n  };\n\n  /**\n   * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.\n   * Or merges two observable sequences into a single observable sequence.\n   *\n   * @example\n   * 1 - merged = sources.merge(1);\n   * 2 - merged = source.merge(otherSource);\n   * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.\n   * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n   */\n  observableProto.merge = function (maxConcurrentOrOther) {\n    if (typeof maxConcurrentOrOther !== 'number') { return observableMerge(this, maxConcurrentOrOther); }\n    var sources = this;\n    return new AnonymousObservable(function (o) {\n      var activeCount = 0, group = new CompositeDisposable(), isStopped = false, q = [];\n\n      function subscribe(xs) {\n        var subscription = new SingleAssignmentDisposable();\n        group.add(subscription);\n\n        // Check for promises support\n        isPromise(xs) && (xs = observableFromPromise(xs));\n\n        subscription.setDisposable(xs.subscribe(function (x) { o.onNext(x); }, function (e) { o.onError(e); }, function () {\n          group.remove(subscription);\n          if (q.length > 0) {\n            subscribe(q.shift());\n          } else {\n            activeCount--;\n            isStopped && activeCount === 0 && o.onCompleted();\n          }\n        }));\n      }\n      group.add(sources.subscribe(function (innerSource) {\n        if (activeCount < maxConcurrentOrOther) {\n          activeCount++;\n          subscribe(innerSource);\n        } else {\n          q.push(innerSource);\n        }\n      }, function (e) { o.onError(e); }, function () {\n        isStopped = true;\n        activeCount === 0 && o.onCompleted();\n      }));\n      return group;\n    }, sources);\n  };\n\n  /**\n   * Merges all the observable sequences into a single observable sequence.\n   * The scheduler is optional and if not specified, the immediate scheduler is used.\n   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.\n   */\n  var observableMerge = Observable.merge = function () {\n    var scheduler, sources;\n    if (!arguments[0]) {\n      scheduler = immediateScheduler;\n      sources = slice.call(arguments, 1);\n    } else if (isScheduler(arguments[0])) {\n      scheduler = arguments[0];\n      sources = slice.call(arguments, 1);\n    } else {\n      scheduler = immediateScheduler;\n      sources = slice.call(arguments, 0);\n    }\n    if (Array.isArray(sources[0])) {\n      sources = sources[0];\n    }\n    return observableOf(scheduler, sources).mergeAll();\n  };\n\n  /**\n   * Merges an observable sequence of observable sequences into an observable sequence.\n   * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n   */\n  observableProto.mergeAll = function () {\n    var sources = this;\n    return new AnonymousObservable(function (o) {\n      var group = new CompositeDisposable(),\n        isStopped = false,\n        m = new SingleAssignmentDisposable();\n\n      group.add(m);\n      m.setDisposable(sources.subscribe(function (innerSource) {\n        var innerSubscription = new SingleAssignmentDisposable();\n        group.add(innerSubscription);\n\n        // Check for promises support\n        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n\n        innerSubscription.setDisposable(innerSource.subscribe(function (x) { o.onNext(x); }, function (e) { o.onError(e); }, function () {\n          group.remove(innerSubscription);\n          isStopped && group.length === 1 && o.onCompleted();\n        }));\n      }, function (e) { o.onError(e); }, function () {\n        isStopped = true;\n        group.length === 1 && o.onCompleted();\n      }));\n      return group;\n    }, sources);\n  };\n\n  /**\n   * @deprecated use #mergeAll instead.\n   */\n  observableProto.mergeObservable = function () {\n    //deprecate('mergeObservable', 'mergeAll');\n    return this.mergeAll.apply(this, arguments);\n  };\n\n  /**\n   * Returns the values from the source observable sequence only after the other observable sequence produces a value.\n   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.\n   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.\n   */\n  observableProto.skipUntil = function (other) {\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var isOpen = false;\n      var disposables = new CompositeDisposable(source.subscribe(function (left) {\n        isOpen && o.onNext(left);\n      }, function (e) { o.onError(e); }, function () {\n        isOpen && o.onCompleted();\n      }));\n\n      isPromise(other) && (other = observableFromPromise(other));\n\n      var rightSubscription = new SingleAssignmentDisposable();\n      disposables.add(rightSubscription);\n      rightSubscription.setDisposable(other.subscribe(function () {\n        isOpen = true;\n        rightSubscription.dispose();\n      }, function (e) { o.onError(e); }, function () {\n        rightSubscription.dispose();\n      }));\n\n      return disposables;\n    }, source);\n  };\n\n  /**\n   * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.\n   * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.\n   */\n  observableProto['switch'] = observableProto.switchLatest = function () {\n    var sources = this;\n    return new AnonymousObservable(function (observer) {\n      var hasLatest = false,\n        innerSubscription = new SerialDisposable(),\n        isStopped = false,\n        latest = 0,\n        subscription = sources.subscribe(\n          function (innerSource) {\n            var d = new SingleAssignmentDisposable(), id = ++latest;\n            hasLatest = true;\n            innerSubscription.setDisposable(d);\n\n            // Check if Promise or Observable\n            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n\n            d.setDisposable(innerSource.subscribe(\n              function (x) { latest === id && observer.onNext(x); },\n              function (e) { latest === id && observer.onError(e); },\n              function () {\n                if (latest === id) {\n                  hasLatest = false;\n                  isStopped && observer.onCompleted();\n                }\n              }));\n          },\n          observer.onError.bind(observer),\n          function () {\n            isStopped = true;\n            !hasLatest && observer.onCompleted();\n          });\n      return new CompositeDisposable(subscription, innerSubscription);\n    }, sources);\n  };\n\n  /**\n   * Returns the values from the source observable sequence until the other observable sequence produces a value.\n   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.\n   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.\n   */\n  observableProto.takeUntil = function (other) {\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      isPromise(other) && (other = observableFromPromise(other));\n      return new CompositeDisposable(\n        source.subscribe(o),\n        other.subscribe(function () { o.onCompleted(); }, function (e) { o.onError(e); }, noop)\n      );\n    }, source);\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.\n   *\n   * @example\n   * 1 - obs = obs1.withLatestFrom(obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n   * 2 - obs = obs1.withLatestFrom([obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  observableProto.withLatestFrom = function () {\n    var source = this;\n    var args = slice.call(arguments);\n    var resultSelector = args.pop();\n\n    if (typeof source === 'undefined') {\n      throw new Error('Source observable not found for withLatestFrom().');\n    }\n    if (typeof resultSelector !== 'function') {\n      throw new Error('withLatestFrom() expects a resultSelector function.');\n    }\n    if (Array.isArray(args[0])) {\n      args = args[0];\n    }\n\n    return new AnonymousObservable(function (observer) {\n      var falseFactory = function () { return false; },\n        n = args.length,\n        hasValue = arrayInitialize(n, falseFactory),\n        hasValueAll = false,\n        values = new Array(n);\n\n      var subscriptions = new Array(n + 1);\n      for (var idx = 0; idx < n; idx++) {\n        (function (i) {\n          var other = args[i], sad = new SingleAssignmentDisposable();\n          isPromise(other) && (other = observableFromPromise(other));\n          sad.setDisposable(other.subscribe(function (x) {\n            values[i] = x;\n            hasValue[i] = true;\n            hasValueAll = hasValue.every(identity);\n          }, observer.onError.bind(observer), function () {}));\n          subscriptions[i] = sad;\n        }(idx));\n      }\n\n      var sad = new SingleAssignmentDisposable();\n      sad.setDisposable(source.subscribe(function (x) {\n        var res;\n        var allValues = [x].concat(values);\n        if (!hasValueAll) return;\n        try {\n          res = resultSelector.apply(null, allValues);\n        } catch (ex) {\n          observer.onError(ex);\n          return;\n        }\n        observer.onNext(res);\n      }, observer.onError.bind(observer), function () {\n        observer.onCompleted();\n      }));\n      subscriptions[n] = sad;\n\n      return new CompositeDisposable(subscriptions);\n    }, this);\n  };\n\n  function zipArray(second, resultSelector) {\n    var first = this;\n    return new AnonymousObservable(function (observer) {\n      var index = 0, len = second.length;\n      return first.subscribe(function (left) {\n        if (index < len) {\n          var right = second[index++], result;\n          try {\n            result = resultSelector(left, right);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          observer.onNext(result);\n        } else {\n          observer.onCompleted();\n        }\n      }, function (e) { observer.onError(e); }, function () { observer.onCompleted(); });\n    }, first);\n  }\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the sources.\n   *\n   * @example\n   * 1 - res = obs1.zip(obs2, fn);\n   * 1 - res = x1.zip([1,2,3], fn);\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  observableProto.zip = function () {\n    if (Array.isArray(arguments[0])) {\n      return zipArray.apply(this, arguments);\n    }\n    var parent = this, sources = slice.call(arguments), resultSelector = sources.pop();\n    sources.unshift(parent);\n    return new AnonymousObservable(function (observer) {\n      var n = sources.length,\n        queues = arrayInitialize(n, function () { return []; }),\n        isDone = arrayInitialize(n, function () { return false; });\n\n      function next(i) {\n        var res, queuedValues;\n        if (queues.every(function (x) { return x.length > 0; })) {\n          try {\n            queuedValues = queues.map(function (x) { return x.shift(); });\n            res = resultSelector.apply(parent, queuedValues);\n          } catch (ex) {\n            observer.onError(ex);\n            return;\n          }\n          observer.onNext(res);\n        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {\n          observer.onCompleted();\n        }\n      };\n\n      function done(i) {\n        isDone[i] = true;\n        if (isDone.every(function (x) { return x; })) {\n          observer.onCompleted();\n        }\n      }\n\n      var subscriptions = new Array(n);\n      for (var idx = 0; idx < n; idx++) {\n        (function (i) {\n          var source = sources[i], sad = new SingleAssignmentDisposable();\n          isPromise(source) && (source = observableFromPromise(source));\n          sad.setDisposable(source.subscribe(function (x) {\n            queues[i].push(x);\n            next(i);\n          }, function (e) { observer.onError(e); }, function () {\n            done(i);\n          }));\n          subscriptions[i] = sad;\n        })(idx);\n      }\n\n      return new CompositeDisposable(subscriptions);\n    }, parent);\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.\n   * @param arguments Observable sources.\n   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  Observable.zip = function () {\n    var args = slice.call(arguments, 0), first = args.shift();\n    return first.zip.apply(first, args);\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by emitting a list with the elements of the observable sequences at corresponding indexes.\n   * @param arguments Observable sources.\n   * @returns {Observable} An observable sequence containing lists of elements at corresponding indexes.\n   */\n  Observable.zipArray = function () {\n    var sources = argsOrArray(arguments, 0);\n    return new AnonymousObservable(function (observer) {\n      var n = sources.length,\n        queues = arrayInitialize(n, function () { return []; }),\n        isDone = arrayInitialize(n, function () { return false; });\n\n      function next(i) {\n        if (queues.every(function (x) { return x.length > 0; })) {\n          var res = queues.map(function (x) { return x.shift(); });\n          observer.onNext(res);\n        } else if (isDone.filter(function (x, j) { return j !== i; }).every(identity)) {\n          observer.onCompleted();\n          return;\n        }\n      };\n\n      function done(i) {\n        isDone[i] = true;\n        if (isDone.every(identity)) {\n          observer.onCompleted();\n          return;\n        }\n      }\n\n      var subscriptions = new Array(n);\n      for (var idx = 0; idx < n; idx++) {\n        (function (i) {\n          subscriptions[i] = new SingleAssignmentDisposable();\n          subscriptions[i].setDisposable(sources[i].subscribe(function (x) {\n            queues[i].push(x);\n            next(i);\n          }, function (e) { observer.onError(e); }, function () {\n            done(i);\n          }));\n        })(idx);\n      }\n\n      return new CompositeDisposable(subscriptions);\n    });\n  };\n\n  /**\n   *  Hides the identity of an observable sequence.\n   * @returns {Observable} An observable sequence that hides the identity of the source sequence.\n   */\n  observableProto.asObservable = function () {\n    var source = this;\n    return new AnonymousObservable(function (o) { return source.subscribe(o); }, this);\n  };\n\n  /**\n   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.\n   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.\n   */\n  observableProto.dematerialize = function () {\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      return source.subscribe(function (x) { return x.accept(o); }, function(e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, this);\n  };\n\n  /**\n   *  Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.\n   *\n   *  var obs = observable.distinctUntilChanged();\n   *  var obs = observable.distinctUntilChanged(function (x) { return x.id; });\n   *  var obs = observable.distinctUntilChanged(function (x) { return x.id; }, function (x, y) { return x === y; });\n   *\n   * @param {Function} [keySelector] A function to compute the comparison key for each element. If not provided, it projects the value.\n   * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.\n   * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.\n   */\n  observableProto.distinctUntilChanged = function (keySelector, comparer) {\n    var source = this;\n    keySelector || (keySelector = identity);\n    comparer || (comparer = defaultComparer);\n    return new AnonymousObservable(function (o) {\n      var hasCurrentKey = false, currentKey;\n      return source.subscribe(function (value) {\n          var comparerEquals = false, key;\n          try {\n            key = keySelector(value);\n          } catch (e) {\n            o.onError(e);\n            return;\n          }\n          if (hasCurrentKey) {\n            try {\n              comparerEquals = comparer(currentKey, key);\n            } catch (e) {\n              o.onError(e);\n              return;\n            }\n          }\n          if (!hasCurrentKey || !comparerEquals) {\n            hasCurrentKey = true;\n            currentKey = key;\n            o.onNext(value);\n          }\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, this);\n  };\n\n  /**\n   *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.\n   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n   * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an observer.\n   * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n   * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n   * @returns {Observable} The source sequence with the side-effecting behavior applied.\n   */\n  observableProto['do'] = observableProto.tap = function (observerOrOnNext, onError, onCompleted) {\n    var source = this, onNextFunc;\n    if (typeof observerOrOnNext === 'function') {\n      onNextFunc = observerOrOnNext;\n    } else {\n      onNextFunc = function (x) { observerOrOnNext.onNext(x); };\n      onError = function (e) { observerOrOnNext.onError(e); };\n      onCompleted = function () { observerOrOnNext.onCompleted(); }\n    }\n    return new AnonymousObservable(function (observer) {\n      return source.subscribe(function (x) {\n        try {\n          onNextFunc(x);\n        } catch (e) {\n          observer.onError(e);\n        }\n        observer.onNext(x);\n      }, function (err) {\n        if (onError) {\n          try {\n            onError(err);\n          } catch (e) {\n            observer.onError(e);\n          }\n        }\n        observer.onError(err);\n      }, function () {\n        if (onCompleted) {\n          try {\n            onCompleted();\n          } catch (e) {\n            observer.onError(e);\n          }\n        }\n        observer.onCompleted();\n      });\n    }, this);\n  };\n\n  /** @deprecated use #do or #tap instead. */\n  observableProto.doAction = function () {\n    //deprecate('doAction', 'do or tap');\n    return this.tap.apply(this, arguments);\n  };\n\n  /**\n   *  Invokes an action for each element in the observable sequence.\n   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n   * @param {Function} onNext Action to invoke for each element in the observable sequence.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} The source sequence with the side-effecting behavior applied.\n   */\n  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {\n    return this.tap(typeof thisArg !== 'undefined' ? function (x) { onNext.call(thisArg, x); } : onNext);\n  };\n\n  /**\n   *  Invokes an action upon exceptional termination of the observable sequence.\n   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n   * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} The source sequence with the side-effecting behavior applied.\n   */\n  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {\n    return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) { onError.call(thisArg, e); } : onError);\n  };\n\n  /**\n   *  Invokes an action upon graceful termination of the observable sequence.\n   *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n   * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} The source sequence with the side-effecting behavior applied.\n   */\n  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {\n    return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () { onCompleted.call(thisArg); } : onCompleted);\n  };\n\n  /**\n   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.\n   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.\n   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.\n   */\n  observableProto['finally'] = observableProto.ensure = function (action) {\n    var source = this;\n    return new AnonymousObservable(function (observer) {\n      var subscription;\n      try {\n        subscription = source.subscribe(observer);\n      } catch (e) {\n        action();\n        throw e;\n      }\n      return disposableCreate(function () {\n        try {\n          subscription.dispose();\n        } catch (e) {\n          throw e;\n        } finally {\n          action();\n        }\n      });\n    }, this);\n  };\n\n  /**\n   * @deprecated use #finally or #ensure instead.\n   */\n  observableProto.finallyAction = function (action) {\n    //deprecate('finallyAction', 'finally or ensure');\n    return this.ensure(action);\n  };\n\n  /**\n   *  Ignores all elements in an observable sequence leaving only the termination messages.\n   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.\n   */\n  observableProto.ignoreElements = function () {\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      return source.subscribe(noop, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   *  Materializes the implicit notifications of an observable sequence as explicit notification values.\n   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.\n   */\n  observableProto.materialize = function () {\n    var source = this;\n    return new AnonymousObservable(function (observer) {\n      return source.subscribe(function (value) {\n        observer.onNext(notificationCreateOnNext(value));\n      }, function (e) {\n        observer.onNext(notificationCreateOnError(e));\n        observer.onCompleted();\n      }, function () {\n        observer.onNext(notificationCreateOnCompleted());\n        observer.onCompleted();\n      });\n    }, source);\n  };\n\n  /**\n   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.\n   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.\n   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.\n   */\n  observableProto.repeat = function (repeatCount) {\n    return enumerableRepeat(this, repeatCount).concat();\n  };\n\n  /**\n   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.\n   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);\n   *\n   * @example\n   *  var res = retried = retry.repeat();\n   *  var res = retried = retry.repeat(2);\n   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.\n   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n   */\n  observableProto.retry = function (retryCount) {\n    return enumerableRepeat(this, retryCount).catchError();\n  };\n\n  /**\n   *  Repeats the source observable sequence upon error each time the notifier emits or until it successfully terminates. \n   *  if the notifier completes, the observable sequence completes.\n   *\n   * @example\n   *  var timer = Observable.timer(500);\n   *  var source = observable.retryWhen(timer);\n   * @param {Observable} [notifier] An observable that triggers the retries or completes the observable with onNext or onCompleted respectively.\n   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n   */\n  observableProto.retryWhen = function (notifier) {\n    return enumerableRepeat(this).catchErrorWhen(notifier);\n  };\n  /**\n   *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.\n   *  For aggregation behavior with no intermediate results, see Observable.aggregate.\n   * @example\n   *  var res = source.scan(function (acc, x) { return acc + x; });\n   *  var res = source.scan(0, function (acc, x) { return acc + x; });\n   * @param {Mixed} [seed] The initial accumulator value.\n   * @param {Function} accumulator An accumulator function to be invoked on each element.\n   * @returns {Observable} An observable sequence containing the accumulated values.\n   */\n  observableProto.scan = function () {\n    var hasSeed = false, seed, accumulator, source = this;\n    if (arguments.length === 2) {\n      hasSeed = true;\n      seed = arguments[0];\n      accumulator = arguments[1];\n    } else {\n      accumulator = arguments[0];\n    }\n    return new AnonymousObservable(function (o) {\n      var hasAccumulation, accumulation, hasValue;\n      return source.subscribe (\n        function (x) {\n          !hasValue && (hasValue = true);\n          try {\n            if (hasAccumulation) {\n              accumulation = accumulator(accumulation, x);\n            } else {\n              accumulation = hasSeed ? accumulator(seed, x) : x;\n              hasAccumulation = true;\n            }\n          } catch (e) {\n            o.onError(e);\n            return;\n          }\n\n          o.onNext(accumulation);\n        },\n        function (e) { o.onError(e); },\n        function () {\n          !hasValue && hasSeed && o.onNext(seed);\n          o.onCompleted();\n        }\n      );\n    }, source);\n  };\n\n  /**\n   *  Bypasses a specified number of elements at the end of an observable sequence.\n   * @description\n   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are\n   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.\n   * @param count Number of elements to bypass at the end of the source sequence.\n   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.\n   */\n  observableProto.skipLast = function (count) {\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var q = [];\n      return source.subscribe(function (x) {\n        q.push(x);\n        q.length > count && o.onNext(q.shift());\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.\n   *  @example\n   *  var res = source.startWith(1, 2, 3);\n   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);\n   * @param {Arguments} args The specified values to prepend to the observable sequence\n   * @returns {Observable} The source sequence prepended with the specified values.\n   */\n  observableProto.startWith = function () {\n    var values, scheduler, start = 0;\n    if (!!arguments.length && isScheduler(arguments[0])) {\n      scheduler = arguments[0];\n      start = 1;\n    } else {\n      scheduler = immediateScheduler;\n    }\n    values = slice.call(arguments, start);\n    return enumerableOf([observableFromArray(values, scheduler), this]).concat();\n  };\n\n  /**\n   *  Returns a specified number of contiguous elements from the end of an observable sequence.\n   * @description\n   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of\n   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.\n   * @param {Number} count Number of elements to take from the end of the source sequence.\n   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.\n   */\n  observableProto.takeLast = function (count) {\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var q = [];\n      return source.subscribe(function (x) {\n        q.push(x);\n        q.length > count && q.shift();\n      }, function (e) { o.onError(e); }, function () {\n        while (q.length > 0) { o.onNext(q.shift()); }\n        o.onCompleted();\n      });\n    }, source);\n  };\n\n  function concatMap(source, selector, thisArg) {\n    var selectorFunc = bindCallback(selector, thisArg, 3);\n    return source.map(function (x, i) {\n      var result = selectorFunc(x, i, source);\n      isPromise(result) && (result = observableFromPromise(result));\n      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));\n      return result;\n    }).concatAll();\n  }\n\n  /**\n   *  One of the Following:\n   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n   *\n   * @example\n   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });\n   *  Or:\n   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.\n   *\n   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });\n   *  Or:\n   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.\n   *\n   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));\n   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the\n   * source sequence onto which could be either an observable or Promise.\n   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.\n   */\n  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {\n    if (isFunction(selector) && isFunction(resultSelector)) {\n      return this.concatMap(function (x, i) {\n        var selectorResult = selector(x, i);\n        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));\n        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));\n\n        return selectorResult.map(function (y, i2) {\n          return resultSelector(x, y, i, i2);\n        });\n      });\n    }\n    return isFunction(selector) ?\n      concatMap(this, selector, thisArg) :\n      concatMap(this, function () { return selector; });\n  };\n\n  /**\n   * Projects each element of an observable sequence into a new form by incorporating the element's index.\n   * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.\n   */\n  observableProto.select = observableProto.map = function (selector, thisArg) {\n    var selectorFn = isFunction(selector) ? bindCallback(selector, thisArg, 3) : function () { return selector; },\n        source = this;\n    return new AnonymousObservable(function (o) {\n      var count = 0;\n      return source.subscribe(function (value) {\n        try {\n          var result = selectorFn(value, count++, source);\n        } catch (e) {\n          o.onError(e);\n          return;\n        }\n        o.onNext(result);\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   * Retrieves the value of a specified property from all elements in the Observable sequence.\n   * @param {String} prop The property to pluck.\n   * @returns {Observable} Returns a new Observable sequence of property values.\n   */\n  observableProto.pluck = function (prop) {\n    return this.map(function (x) { return x[prop]; });\n  };\n\n  function flatMap(source, selector, thisArg) {\n    var selectorFunc = bindCallback(selector, thisArg, 3);\n    return source.map(function (x, i) {\n      var result = selectorFunc(x, i, source);\n      isPromise(result) && (result = observableFromPromise(result));\n      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));\n      return result;\n    }).mergeAll();\n  }\n\n  /**\n   *  One of the Following:\n   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n   *\n   * @example\n   *  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); });\n   *  Or:\n   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.\n   *\n   *  var res = source.selectMany(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });\n   *  Or:\n   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.\n   *\n   *  var res = source.selectMany(Rx.Observable.fromArray([1,2,3]));\n   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the source sequence onto which could be either an observable or Promise.\n   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.\n   */\n  observableProto.selectMany = observableProto.flatMap = function (selector, resultSelector, thisArg) {\n    if (isFunction(selector) && isFunction(resultSelector)) {\n      return this.flatMap(function (x, i) {\n        var selectorResult = selector(x, i);\n        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));\n        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));\n\n        return selectorResult.map(function (y, i2) {\n          return resultSelector(x, y, i, i2);\n        });\n      }, thisArg);\n    }\n    return isFunction(selector) ?\n      flatMap(this, selector, thisArg) :\n      flatMap(this, function () { return selector; });\n  };\n\n  /**\n   *  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then\n   *  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.\n   * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences\n   *  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.\n   */\n  observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function (selector, thisArg) {\n    return this.select(selector, thisArg).switchLatest();\n  };\n\n  /**\n   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.\n   * @param {Number} count The number of elements to skip before returning the remaining elements.\n   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.\n   */\n  observableProto.skip = function (count) {\n    if (count < 0) { throw new Error(argumentOutOfRange); }\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var remaining = count;\n      return source.subscribe(function (x) {\n        if (remaining <= 0) {\n          o.onNext(x);\n        } else {\n          remaining--;\n        }\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\n   *  The element's index is used in the logic of the predicate function.\n   *\n   *  var res = source.skipWhile(function (value) { return value < 10; });\n   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });\n   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.\n   */\n  observableProto.skipWhile = function (predicate, thisArg) {\n    var source = this,\n        callback = bindCallback(predicate, thisArg, 3);\n    return new AnonymousObservable(function (o) {\n      var i = 0, running = false;\n      return source.subscribe(function (x) {\n        if (!running) {\n          try {\n            running = !callback(x, i++, source);\n          } catch (e) {\n            o.onError(e);\n            return;\n          }\n        }\n        running && o.onNext(x);\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).\n   *\n   *  var res = source.take(5);\n   *  var res = source.take(0, Rx.Scheduler.timeout);\n   * @param {Number} count The number of elements to return.\n   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name=\"count count</paramref> is set to 0.\n   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.\n   */\n  observableProto.take = function (count, scheduler) {\n    if (count < 0) { throw new RangeError(argumentOutOfRange); }\n    if (count === 0) { return observableEmpty(scheduler); }\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var remaining = count;\n      return source.subscribe(function (x) {\n        if (remaining-- > 0) {\n          o.onNext(x);\n          remaining === 0 && o.onCompleted();\n        }\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   *  Returns elements from an observable sequence as long as a specified condition is true.\n   *  The element's index is used in the logic of the predicate function.\n   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.\n   */\n  observableProto.takeWhile = function (predicate, thisArg) {\n    var source = this,\n        callback = bindCallback(predicate, thisArg, 3);\n    return new AnonymousObservable(function (o) {\n      var i = 0, running = true;\n      return source.subscribe(function (x) {\n        if (running) {\n          try {\n            running = callback(x, i++, source);\n          } catch (e) {\n            o.onError(e);\n            return;\n          }\n          if (running) {\n            o.onNext(x);\n          } else {\n            o.onCompleted();\n          }\n        }\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.\n   *\n   * @example\n   *  var res = source.where(function (value) { return value < 10; });\n   *  var res = source.where(function (value, index) { return value < 10 || index < 10; });\n   * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.\n   */\n  observableProto.where = observableProto.filter = function (predicate, thisArg) {\n    var source = this;\n    predicate = bindCallback(predicate, thisArg, 3);\n    return new AnonymousObservable(function (o) {\n      var count = 0;\n      return source.subscribe(function (value) {\n        try {\n          var shouldRun = predicate(value, count++, source);\n        } catch (e) {\n          o.onError(e);\n          return;\n        }\n        shouldRun && o.onNext(value);\n      }, function (e) { o.onError(e); }, function () { o.onCompleted(); });\n    }, source);\n  };\n\n  /**\n   * Converts a callback function to an observable sequence.\n   *\n   * @param {Function} function Function with a callback as the last parameter to convert to an Observable sequence.\n   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n   * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.\n   * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.\n   */\n  Observable.fromCallback = function (func, context, selector) {\n    return function () {\n      var args = slice.call(arguments, 0);\n\n      return new AnonymousObservable(function (observer) {\n        function handler() {\n          var results = arguments;\n\n          if (selector) {\n            try {\n              results = selector(results);\n            } catch (err) {\n              observer.onError(err);\n              return;\n            }\n\n            observer.onNext(results);\n          } else {\n            if (results.length <= 1) {\n              observer.onNext.apply(observer, results);\n            } else {\n              observer.onNext(results);\n            }\n          }\n\n          observer.onCompleted();\n        }\n\n        args.push(handler);\n        func.apply(context, args);\n      }).publishLast().refCount();\n    };\n  };\n\n  /**\n   * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.\n   * @param {Function} func The function to call\n   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n   * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.\n   * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.\n   */\n  Observable.fromNodeCallback = function (func, context, selector) {\n    return function () {\n      var args = slice.call(arguments, 0);\n\n      return new AnonymousObservable(function (observer) {\n        function handler(err) {\n          if (err) {\n            observer.onError(err);\n            return;\n          }\n\n          var results = slice.call(arguments, 1);\n\n          if (selector) {\n            try {\n              results = selector(results);\n            } catch (e) {\n              observer.onError(e);\n              return;\n            }\n            observer.onNext(results);\n          } else {\n            if (results.length <= 1) {\n              observer.onNext.apply(observer, results);\n            } else {\n              observer.onNext(results);\n            }\n          }\n\n          observer.onCompleted();\n        }\n\n        args.push(handler);\n        func.apply(context, args);\n      }).publishLast().refCount();\n    };\n  };\n\n  function createListener (element, name, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(name, handler, false);\n      return disposableCreate(function () {\n        element.removeEventListener(name, handler, false);\n      });\n    }\n    throw new Error('No listener found');\n  }\n\n  function createEventListener (el, eventName, handler) {\n    var disposables = new CompositeDisposable();\n\n    // Asume NodeList\n    if (Object.prototype.toString.call(el) === '[object NodeList]') {\n      for (var i = 0, len = el.length; i < len; i++) {\n        disposables.add(createEventListener(el.item(i), eventName, handler));\n      }\n    } else if (el) {\n      disposables.add(createListener(el, eventName, handler));\n    }\n\n    return disposables;\n  }\n\n  /**\n   * Configuration option to determine whether to use native events only\n   */\n  Rx.config.useNativeEvents = false;\n\n  /**\n   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.\n   *\n   * @example\n   *   var source = Rx.Observable.fromEvent(element, 'mouseup');\n   *\n   * @param {Object} element The DOMElement or NodeList to attach a listener.\n   * @param {String} eventName The event name to attach the observable sequence.\n   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n   * @returns {Observable} An observable sequence of events from the specified element and the specified event.\n   */\n  Observable.fromEvent = function (element, eventName, selector) {\n    // Node.js specific\n    if (element.addListener) {\n      return fromEventPattern(\n        function (h) { element.addListener(eventName, h); },\n        function (h) { element.removeListener(eventName, h); },\n        selector);\n    }\n\n    // Use only if non-native events are allowed\n    if (!Rx.config.useNativeEvents) {\n      // Handles jq, Angular.js, Zepto, Marionette\n      if (typeof element.on === 'function' && typeof element.off === 'function') {\n        return fromEventPattern(\n          function (h) { element.on(eventName, h); },\n          function (h) { element.off(eventName, h); },\n          selector);\n      }\n      if (!!root.Ember && typeof root.Ember.addListener === 'function') {\n        return fromEventPattern(\n          function (h) { Ember.addListener(element, eventName, h); },\n          function (h) { Ember.removeListener(element, eventName, h); },\n          selector);\n      }\n    }\n    return new AnonymousObservable(function (observer) {\n      return createEventListener(\n        element,\n        eventName,\n        function handler (e) {\n          var results = e;\n\n          if (selector) {\n            try {\n              results = selector(arguments);\n            } catch (err) {\n              observer.onError(err);\n              return\n            }\n          }\n\n          observer.onNext(results);\n        });\n    }).publish().refCount();\n  };\n\n  /**\n   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.\n   * @param {Function} addHandler The function to add a handler to the emitter.\n   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.\n   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n   * @returns {Observable} An observable sequence which wraps an event from an event emitter\n   */\n  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {\n    return new AnonymousObservable(function (observer) {\n      function innerHandler (e) {\n        var result = e;\n        if (selector) {\n          try {\n            result = selector(arguments);\n          } catch (err) {\n            observer.onError(err);\n            return;\n          }\n        }\n        observer.onNext(result);\n      }\n\n      var returnValue = addHandler(innerHandler);\n      return disposableCreate(function () {\n        if (removeHandler) {\n          removeHandler(innerHandler, returnValue);\n        }\n      });\n    }).publish().refCount();\n  };\n\n  /**\n   * Converts a Promise to an Observable sequence\n   * @param {Promise} An ES6 Compliant promise.\n   * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.\n   */\n  var observableFromPromise = Observable.fromPromise = function (promise) {\n    return observableDefer(function () {\n      var subject = new Rx.AsyncSubject();\n\n      promise.then(\n        function (value) {\n          subject.onNext(value);\n          subject.onCompleted();\n        },\n        subject.onError.bind(subject));\n\n      return subject;\n    });\n  };\n\n  /*\n   * Converts an existing observable sequence to an ES6 Compatible Promise\n   * @example\n   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);\n   *\n   * // With config\n   * Rx.config.Promise = RSVP.Promise;\n   * var promise = Rx.Observable.return(42).toPromise();\n   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.\n   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.\n   */\n  observableProto.toPromise = function (promiseCtor) {\n    promiseCtor || (promiseCtor = Rx.config.Promise);\n    if (!promiseCtor) { throw new TypeError('Promise type not provided nor in Rx.config.Promise'); }\n    var source = this;\n    return new promiseCtor(function (resolve, reject) {\n      // No cancellation can be done\n      var value, hasValue = false;\n      source.subscribe(function (v) {\n        value = v;\n        hasValue = true;\n      }, reject, function () {\n        hasValue && resolve(value);\n      });\n    });\n  };\n\n  /**\n   * Invokes the asynchronous function, surfacing the result through an observable sequence.\n   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.\n   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n   */\n  Observable.startAsync = function (functionAsync) {\n    var promise;\n    try {\n      promise = functionAsync();\n    } catch (e) {\n      return observableThrow(e);\n    }\n    return observableFromPromise(promise);\n  }\n\n  /**\n   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each\n   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's\n   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n   *\n   * @example\n   * 1 - res = source.multicast(observable);\n   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });\n   *\n   * @param {Function|Subject} subjectOrSubjectSelector\n   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.\n   * Or:\n   * Subject to push source elements into.\n   *\n   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name=\"subjectOrSubjectSelector\" is a factory function.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.multicast = function (subjectOrSubjectSelector, selector) {\n    var source = this;\n    return typeof subjectOrSubjectSelector === 'function' ?\n      new AnonymousObservable(function (observer) {\n        var connectable = source.multicast(subjectOrSubjectSelector());\n        return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());\n      }, source) :\n      new ConnectableObservable(source, subjectOrSubjectSelector);\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.\n   * This operator is a specialization of Multicast using a regular Subject.\n   *\n   * @example\n   * var resres = source.publish();\n   * var res = source.publish(function (x) { return x; });\n   *\n   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.publish = function (selector) {\n    return selector && isFunction(selector) ?\n      this.multicast(function () { return new Subject(); }, selector) :\n      this.multicast(new Subject());\n  };\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence.\n   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */\n  observableProto.share = function () {\n    return this.publish().refCount();\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.\n   * This operator is a specialization of Multicast using a AsyncSubject.\n   *\n   * @example\n   * var res = source.publishLast();\n   * var res = source.publishLast(function (x) { return x; });\n   *\n   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.publishLast = function (selector) {\n    return selector && isFunction(selector) ?\n      this.multicast(function () { return new AsyncSubject(); }, selector) :\n      this.multicast(new AsyncSubject());\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.\n   * This operator is a specialization of Multicast using a BehaviorSubject.\n   *\n   * @example\n   * var res = source.publishValue(42);\n   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);\n   *\n   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.\n   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.publishValue = function (initialValueOrSelector, initialValue) {\n    return arguments.length === 2 ?\n      this.multicast(function () {\n        return new BehaviorSubject(initialValue);\n      }, initialValueOrSelector) :\n      this.multicast(new BehaviorSubject(initialValueOrSelector));\n  };\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.\n   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */\n  observableProto.shareValue = function (initialValue) {\n    return this.publishValue(initialValue).refCount();\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n   * This operator is a specialization of Multicast using a ReplaySubject.\n   *\n   * @example\n   * var res = source.replay(null, 3);\n   * var res = source.replay(null, 3, 500);\n   * var res = source.replay(null, 3, 500, scheduler);\n   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);\n   *\n   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.\n   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n   * @param window [Optional] Maximum time length of the replay buffer.\n   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.replay = function (selector, bufferSize, window, scheduler) {\n    return selector && isFunction(selector) ?\n      this.multicast(function () { return new ReplaySubject(bufferSize, window, scheduler); }, selector) :\n      this.multicast(new ReplaySubject(bufferSize, window, scheduler));\n  };\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   *\n   * @example\n   * var res = source.shareReplay(3);\n   * var res = source.shareReplay(3, 500);\n   * var res = source.shareReplay(3, 500, scheduler);\n   *\n\n   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n   * @param window [Optional] Maximum time length of the replay buffer.\n   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */\n  observableProto.shareReplay = function (bufferSize, window, scheduler) {\n    return this.replay(null, bufferSize, window, scheduler).refCount();\n  };\n\n  var ConnectableObservable = Rx.ConnectableObservable = (function (__super__) {\n    inherits(ConnectableObservable, __super__);\n\n    function ConnectableObservable(source, subject) {\n      var hasSubscription = false,\n        subscription,\n        sourceObservable = source.asObservable();\n\n      this.connect = function () {\n        if (!hasSubscription) {\n          hasSubscription = true;\n          subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function () {\n            hasSubscription = false;\n          }));\n        }\n        return subscription;\n      };\n\n      __super__.call(this, function (o) { return subject.subscribe(o); });\n    }\n\n    ConnectableObservable.prototype.refCount = function () {\n      var connectableSubscription, count = 0, source = this;\n      return new AnonymousObservable(function (observer) {\n          var shouldConnect = ++count === 1,\n            subscription = source.subscribe(observer);\n          shouldConnect && (connectableSubscription = source.connect());\n          return function () {\n            subscription.dispose();\n            --count === 0 && connectableSubscription.dispose();\n          };\n      });\n    };\n\n    return ConnectableObservable;\n  }(Observable));\n\n  function observableTimerDate(dueTime, scheduler) {\n    return new AnonymousObservable(function (observer) {\n      return scheduler.scheduleWithAbsolute(dueTime, function () {\n        observer.onNext(0);\n        observer.onCompleted();\n      });\n    });\n  }\n\n  function observableTimerDateAndPeriod(dueTime, period, scheduler) {\n    return new AnonymousObservable(function (observer) {\n      var count = 0, d = dueTime, p = normalizeTime(period);\n      return scheduler.scheduleRecursiveWithAbsolute(d, function (self) {\n        if (p > 0) {\n          var now = scheduler.now();\n          d = d + p;\n          d <= now && (d = now + p);\n        }\n        observer.onNext(count++);\n        self(d);\n      });\n    });\n  }\n\n  function observableTimerTimeSpan(dueTime, scheduler) {\n    return new AnonymousObservable(function (observer) {\n      return scheduler.scheduleWithRelative(normalizeTime(dueTime), function () {\n        observer.onNext(0);\n        observer.onCompleted();\n      });\n    });\n  }\n\n  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {\n    return dueTime === period ?\n      new AnonymousObservable(function (observer) {\n        return scheduler.schedulePeriodicWithState(0, period, function (count) {\n          observer.onNext(count);\n          return count + 1;\n        });\n      }) :\n      observableDefer(function () {\n        return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);\n      });\n  }\n\n  /**\n   *  Returns an observable sequence that produces a value after each period.\n   *\n   * @example\n   *  1 - res = Rx.Observable.interval(1000);\n   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);\n   *\n   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.\n   * @returns {Observable} An observable sequence that produces a value after each period.\n   */\n  var observableinterval = Observable.interval = function (period, scheduler) {\n    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);\n  };\n\n  /**\n   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.\n   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.\n   */\n  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {\n    var period;\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n    if (periodOrScheduler !== undefined && typeof periodOrScheduler === 'number') {\n      period = periodOrScheduler;\n    } else if (isScheduler(periodOrScheduler)) {\n      scheduler = periodOrScheduler;\n    }\n    if (dueTime instanceof Date && period === undefined) {\n      return observableTimerDate(dueTime.getTime(), scheduler);\n    }\n    if (dueTime instanceof Date && period !== undefined) {\n      period = periodOrScheduler;\n      return observableTimerDateAndPeriod(dueTime.getTime(), period, scheduler);\n    }\n    return period === undefined ?\n      observableTimerTimeSpan(dueTime, scheduler) :\n      observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);\n  };\n\n  function observableDelayTimeSpan(source, dueTime, scheduler) {\n    return new AnonymousObservable(function (observer) {\n      var active = false,\n        cancelable = new SerialDisposable(),\n        exception = null,\n        q = [],\n        running = false,\n        subscription;\n      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {\n        var d, shouldRun;\n        if (notification.value.kind === 'E') {\n          q = [];\n          q.push(notification);\n          exception = notification.value.exception;\n          shouldRun = !running;\n        } else {\n          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });\n          shouldRun = !active;\n          active = true;\n        }\n        if (shouldRun) {\n          if (exception !== null) {\n            observer.onError(exception);\n          } else {\n            d = new SingleAssignmentDisposable();\n            cancelable.setDisposable(d);\n            d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function (self) {\n              var e, recurseDueTime, result, shouldRecurse;\n              if (exception !== null) {\n                return;\n              }\n              running = true;\n              do {\n                result = null;\n                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {\n                  result = q.shift().value;\n                }\n                if (result !== null) {\n                  result.accept(observer);\n                }\n              } while (result !== null);\n              shouldRecurse = false;\n              recurseDueTime = 0;\n              if (q.length > 0) {\n                shouldRecurse = true;\n                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());\n              } else {\n                active = false;\n              }\n              e = exception;\n              running = false;\n              if (e !== null) {\n                observer.onError(e);\n              } else if (shouldRecurse) {\n                self(recurseDueTime);\n              }\n            }));\n          }\n        }\n      });\n      return new CompositeDisposable(subscription, cancelable);\n    }, source);\n  }\n\n  function observableDelayDate(source, dueTime, scheduler) {\n    return observableDefer(function () {\n      return observableDelayTimeSpan(source, dueTime - scheduler.now(), scheduler);\n    });\n  }\n\n  /**\n   *  Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.\n   *\n   * @example\n   *  1 - res = Rx.Observable.delay(new Date());\n   *  2 - res = Rx.Observable.delay(new Date(), Rx.Scheduler.timeout);\n   *\n   *  3 - res = Rx.Observable.delay(5000);\n   *  4 - res = Rx.Observable.delay(5000, 1000, Rx.Scheduler.timeout);\n   * @memberOf Observable#\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.\n   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Time-shifted sequence.\n   */\n  observableProto.delay = function (dueTime, scheduler) {\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n    return dueTime instanceof Date ?\n      observableDelayDate(this, dueTime.getTime(), scheduler) :\n      observableDelayTimeSpan(this, dueTime, scheduler);\n  };\n\n  /**\n   *  Ignores values from an observable sequence which are followed by another value before dueTime.\n   * @param {Number} dueTime Duration of the debounce period for each value (specified as an integer denoting milliseconds).\n   * @param {Scheduler} [scheduler]  Scheduler to run the debounce timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} The debounced sequence.\n   */\n  observableProto.debounce = observableProto.throttleWithTimeout = function (dueTime, scheduler) {\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n    var source = this;\n    return new AnonymousObservable(function (observer) {\n      var cancelable = new SerialDisposable(), hasvalue = false, value, id = 0;\n      var subscription = source.subscribe(\n        function (x) {\n          hasvalue = true;\n          value = x;\n          id++;\n          var currentId = id,\n            d = new SingleAssignmentDisposable();\n          cancelable.setDisposable(d);\n          d.setDisposable(scheduler.scheduleWithRelative(dueTime, function () {\n            hasvalue && id === currentId && observer.onNext(value);\n            hasvalue = false;\n          }));\n        },\n        function (e) {\n          cancelable.dispose();\n          observer.onError(e);\n          hasvalue = false;\n          id++;\n        },\n        function () {\n          cancelable.dispose();\n          hasvalue && observer.onNext(value);\n          observer.onCompleted();\n          hasvalue = false;\n          id++;\n        });\n      return new CompositeDisposable(subscription, cancelable);\n    }, this);\n  };\n\n  /**\n   * @deprecated use #debounce or #throttleWithTimeout instead.\n   */\n  observableProto.throttle = function(dueTime, scheduler) {\n    //deprecate('throttle', 'debounce or throttleWithTimeout');\n    return this.debounce(dueTime, scheduler);\n  };\n\n  /**\n   *  Records the timestamp for each value in an observable sequence.\n   *\n   * @example\n   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }\n   *  2 - res = source.timestamp(Rx.Scheduler.timeout);\n   *\n   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence with timestamp information on values.\n   */\n  observableProto.timestamp = function (scheduler) {\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n    return this.map(function (x) {\n      return { value: x, timestamp: scheduler.now() };\n    });\n  };\n\n  function sampleObservable(source, sampler) {\n    return new AnonymousObservable(function (observer) {\n      var atEnd, value, hasValue;\n\n      function sampleSubscribe() {\n        if (hasValue) {\n          hasValue = false;\n          observer.onNext(value);\n        }\n        atEnd && observer.onCompleted();\n      }\n\n      return new CompositeDisposable(\n        source.subscribe(function (newValue) {\n          hasValue = true;\n          value = newValue;\n        }, observer.onError.bind(observer), function () {\n          atEnd = true;\n        }),\n        sampler.subscribe(sampleSubscribe, observer.onError.bind(observer), sampleSubscribe)\n      );\n    }, source);\n  }\n\n  /**\n   *  Samples the observable sequence at each interval.\n   *\n   * @example\n   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence\n   *  2 - res = source.sample(5000); // 5 seconds\n   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds\n   *\n   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.\n   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Sampled observable sequence.\n   */\n  observableProto.sample = observableProto.throttleLatest = function (intervalOrSampler, scheduler) {\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n    return typeof intervalOrSampler === 'number' ?\n      sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) :\n      sampleObservable(this, intervalOrSampler);\n  };\n\n  /**\n   *  Returns the source observable sequence or the other observable sequence if dueTime elapses.\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) when a timeout occurs.\n   * @param {Observable} [other]  Sequence to return in case of a timeout. If not specified, a timeout error throwing sequence will be used.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timeout timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} The source sequence switching to the other sequence in case of a timeout.\n   */\n  observableProto.timeout = function (dueTime, other, scheduler) {\n    (other == null || typeof other === 'string') && (other = observableThrow(new Error(other || 'Timeout')));\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n\n    var source = this, schedulerMethod = dueTime instanceof Date ?\n      'scheduleWithAbsolute' :\n      'scheduleWithRelative';\n\n    return new AnonymousObservable(function (observer) {\n      var id = 0,\n        original = new SingleAssignmentDisposable(),\n        subscription = new SerialDisposable(),\n        switched = false,\n        timer = new SerialDisposable();\n\n      subscription.setDisposable(original);\n\n      function createTimer() {\n        var myId = id;\n        timer.setDisposable(scheduler[schedulerMethod](dueTime, function () {\n          if (id === myId) {\n            isPromise(other) && (other = observableFromPromise(other));\n            subscription.setDisposable(other.subscribe(observer));\n          }\n        }));\n      }\n\n      createTimer();\n\n      original.setDisposable(source.subscribe(function (x) {\n        if (!switched) {\n          id++;\n          observer.onNext(x);\n          createTimer();\n        }\n      }, function (e) {\n        if (!switched) {\n          id++;\n          observer.onError(e);\n        }\n      }, function () {\n        if (!switched) {\n          id++;\n          observer.onCompleted();\n        }\n      }));\n      return new CompositeDisposable(subscription, timer);\n    }, source);\n  };\n\n  /**\n   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.\n   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item\n   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.\n   * @returns {Observable} An Observable that performs the throttle operation.\n   */\n  observableProto.throttleFirst = function (windowDuration, scheduler) {\n    isScheduler(scheduler) || (scheduler = timeoutScheduler);\n    var duration = +windowDuration || 0;\n    if (duration <= 0) { throw new RangeError('windowDuration cannot be less or equal zero.'); }\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var lastOnNext = 0;\n      return source.subscribe(\n        function (x) {\n          var now = scheduler.now();\n          if (lastOnNext === 0 || now - lastOnNext >= duration) {\n            lastOnNext = now;\n            o.onNext(x);\n          }\n        },function (e) { o.onError(e); }, function () { o.onCompleted(); }\n      );\n    }, source);\n  };\n\n  var PausableObservable = (function (__super__) {\n\n    inherits(PausableObservable, __super__);\n\n    function subscribe(observer) {\n      var conn = this.source.publish(),\n        subscription = conn.subscribe(observer),\n        connection = disposableEmpty;\n\n      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) {\n        if (b) {\n          connection = conn.connect();\n        } else {\n          connection.dispose();\n          connection = disposableEmpty;\n        }\n      });\n\n      return new CompositeDisposable(subscription, connection, pausable);\n    }\n\n    function PausableObservable(source, pauser) {\n      this.source = source;\n      this.controller = new Subject();\n\n      if (pauser && pauser.subscribe) {\n        this.pauser = this.controller.merge(pauser);\n      } else {\n        this.pauser = this.controller;\n      }\n\n      __super__.call(this, subscribe, source);\n    }\n\n    PausableObservable.prototype.pause = function () {\n      this.controller.onNext(false);\n    };\n\n    PausableObservable.prototype.resume = function () {\n      this.controller.onNext(true);\n    };\n\n    return PausableObservable;\n\n  }(Observable));\n\n  /**\n   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.\n   * @example\n   * var pauser = new Rx.Subject();\n   * var source = Rx.Observable.interval(100).pausable(pauser);\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */\n  observableProto.pausable = function (pauser) {\n    return new PausableObservable(this, pauser);\n  };\n\n  function combineLatestSource(source, subject, resultSelector) {\n    return new AnonymousObservable(function (o) {\n      var hasValue = [false, false],\n        hasValueAll = false,\n        isDone = false,\n        values = new Array(2),\n        err;\n\n      function next(x, i) {\n        values[i] = x\n        var res;\n        hasValue[i] = true;\n        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {\n          if (err) {\n            o.onError(err);\n            return;\n          }\n\n          try {\n            res = resultSelector.apply(null, values);\n          } catch (ex) {\n            o.onError(ex);\n            return;\n          }\n          o.onNext(res);\n        }\n        if (isDone && values[1]) {\n          o.onCompleted();\n        }\n      }\n\n      return new CompositeDisposable(\n        source.subscribe(\n          function (x) {\n            next(x, 0);\n          },\n          function (e) {\n            if (values[1]) {\n              o.onError(e);\n            } else {\n              err = e;\n            }\n          },\n          function () {\n            isDone = true;\n            values[1] && o.onCompleted();\n          }),\n        subject.subscribe(\n          function (x) {\n            next(x, 1);\n          },\n          function (e) { o.onError(e); },\n          function () {\n            isDone = true;\n            next(true, 1);\n          })\n        );\n    }, source);\n  }\n\n  var PausableBufferedObservable = (function (__super__) {\n\n    inherits(PausableBufferedObservable, __super__);\n\n    function subscribe(o) {\n      var q = [], previousShouldFire;\n\n      var subscription =\n        combineLatestSource(\n          this.source,\n          this.pauser.distinctUntilChanged().startWith(false),\n          function (data, shouldFire) {\n            return { data: data, shouldFire: shouldFire };\n          })\n          .subscribe(\n            function (results) {\n              if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {\n                previousShouldFire = results.shouldFire;\n                // change in shouldFire\n                if (results.shouldFire) {\n                  while (q.length > 0) {\n                    o.onNext(q.shift());\n                  }\n                }\n              } else {\n                previousShouldFire = results.shouldFire;\n                // new data\n                if (results.shouldFire) {\n                  o.onNext(results.data);\n                } else {\n                  q.push(results.data);\n                }\n              }\n            },\n            function (err) {\n              // Empty buffer before sending error\n              while (q.length > 0) {\n                o.onNext(q.shift());\n              }\n              o.onError(err);\n            },\n            function () {\n              // Empty buffer before sending completion\n              while (q.length > 0) {\n                o.onNext(q.shift());\n              }\n              o.onCompleted();\n            }\n          );\n      return subscription;\n    }\n\n    function PausableBufferedObservable(source, pauser) {\n      this.source = source;\n      this.controller = new Subject();\n\n      if (pauser && pauser.subscribe) {\n        this.pauser = this.controller.merge(pauser);\n      } else {\n        this.pauser = this.controller;\n      }\n\n      __super__.call(this, subscribe, source);\n    }\n\n    PausableBufferedObservable.prototype.pause = function () {\n      this.controller.onNext(false);\n    };\n\n    PausableBufferedObservable.prototype.resume = function () {\n      this.controller.onNext(true);\n    };\n\n    return PausableBufferedObservable;\n\n  }(Observable));\n\n  /**\n   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,\n   * and yields the values that were buffered while paused.\n   * @example\n   * var pauser = new Rx.Subject();\n   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */\n  observableProto.pausableBuffered = function (subject) {\n    return new PausableBufferedObservable(this, subject);\n  };\n\n  var ControlledObservable = (function (__super__) {\n\n    inherits(ControlledObservable, __super__);\n\n    function subscribe (observer) {\n      return this.source.subscribe(observer);\n    }\n\n    function ControlledObservable (source, enableQueue) {\n      __super__.call(this, subscribe, source);\n      this.subject = new ControlledSubject(enableQueue);\n      this.source = source.multicast(this.subject).refCount();\n    }\n\n    ControlledObservable.prototype.request = function (numberOfItems) {\n      if (numberOfItems == null) { numberOfItems = -1; }\n      return this.subject.request(numberOfItems);\n    };\n\n    return ControlledObservable;\n\n  }(Observable));\n\n  var ControlledSubject = (function (__super__) {\n\n    function subscribe (observer) {\n      return this.subject.subscribe(observer);\n    }\n\n    inherits(ControlledSubject, __super__);\n\n    function ControlledSubject(enableQueue) {\n      enableQueue == null && (enableQueue = true);\n\n      __super__.call(this, subscribe);\n      this.subject = new Subject();\n      this.enableQueue = enableQueue;\n      this.queue = enableQueue ? [] : null;\n      this.requestedCount = 0;\n      this.requestedDisposable = disposableEmpty;\n      this.error = null;\n      this.hasFailed = false;\n      this.hasCompleted = false;\n      this.controlledDisposable = disposableEmpty;\n    }\n\n    addProperties(ControlledSubject.prototype, Observer, {\n      onCompleted: function () {\n        this.hasCompleted = true;\n        (!this.enableQueue || this.queue.length === 0) && this.subject.onCompleted();\n      },\n      onError: function (error) {\n        this.hasFailed = true;\n        this.error = error;\n        (!this.enableQueue || this.queue.length === 0) && this.subject.onError(error);\n      },\n      onNext: function (value) {\n        var hasRequested = false;\n\n        if (this.requestedCount === 0) {\n          this.enableQueue && this.queue.push(value);\n        } else {\n          (this.requestedCount !== -1 && this.requestedCount-- === 0) && this.disposeCurrentRequest();\n          hasRequested = true;\n        }\n        hasRequested && this.subject.onNext(value);\n      },\n      _processRequest: function (numberOfItems) {\n        if (this.enableQueue) {\n          while (this.queue.length >= numberOfItems && numberOfItems > 0) {\n            this.subject.onNext(this.queue.shift());\n            numberOfItems--;\n          }\n\n          return this.queue.length !== 0 ?\n            { numberOfItems: numberOfItems, returnValue: true } :\n            { numberOfItems: numberOfItems, returnValue: false };\n        }\n\n        if (this.hasFailed) {\n          this.subject.onError(this.error);\n          this.controlledDisposable.dispose();\n          this.controlledDisposable = disposableEmpty;\n        } else if (this.hasCompleted) {\n          this.subject.onCompleted();\n          this.controlledDisposable.dispose();\n          this.controlledDisposable = disposableEmpty;\n        }\n\n        return { numberOfItems: numberOfItems, returnValue: false };\n      },\n      request: function (number) {\n        this.disposeCurrentRequest();\n        var self = this, r = this._processRequest(number);\n\n        var number = r.numberOfItems;\n        if (!r.returnValue) {\n          this.requestedCount = number;\n          this.requestedDisposable = disposableCreate(function () {\n            self.requestedCount = 0;\n          });\n\n          return this.requestedDisposable\n        } else {\n          return disposableEmpty;\n        }\n      },\n      disposeCurrentRequest: function () {\n        this.requestedDisposable.dispose();\n        this.requestedDisposable = disposableEmpty;\n      }\n    });\n\n    return ControlledSubject;\n  }(Observable));\n\n  /**\n   * Attaches a controller to the observable sequence with the ability to queue.\n   * @example\n   * var source = Rx.Observable.interval(100).controlled();\n   * source.request(3); // Reads 3 values\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */\n  observableProto.controlled = function (enableQueue) {\n    if (enableQueue == null) {  enableQueue = true; }\n    return new ControlledObservable(this, enableQueue);\n  };\n\n  /**\n   * Executes a transducer to transform the observable sequence\n   * @param {Transducer} transducer A transducer to execute\n   * @returns {Observable} An Observable sequence containing the results from the transducer.\n   */\n  observableProto.transduce = function(transducer) {\n    var source = this;\n\n    function transformForObserver(observer) {\n      return {\n        init: function() {\n          return observer;\n        },\n        step: function(obs, input) {\n          return obs.onNext(input);\n        },\n        result: function(obs) {\n          return obs.onCompleted();\n        }\n      };\n    }\n\n    return new AnonymousObservable(function(observer) {\n      var xform = transducer(transformForObserver(observer));\n      return source.subscribe(\n        function(v) {\n          try {\n            xform.step(observer, v);\n          } catch (e) {\n            observer.onError(e);\n          }\n        },\n        observer.onError.bind(observer),\n        function() { xform.result(observer); }\n      );\n    }, source);\n  };\n\n  var AnonymousObservable = Rx.AnonymousObservable = (function (__super__) {\n    inherits(AnonymousObservable, __super__);\n\n    // Fix subscriber to check for undefined or function returned to decorate as Disposable\n    function fixSubscriber(subscriber) {\n      if (subscriber && typeof subscriber.dispose === 'function') { return subscriber; }\n\n      return typeof subscriber === 'function' ?\n        disposableCreate(subscriber) :\n        disposableEmpty;\n    }\n\n    function AnonymousObservable(subscribe, parent) {\n      this.source = parent;\n      if (!(this instanceof AnonymousObservable)) {\n        return new AnonymousObservable(subscribe);\n      }\n\n      function s(observer) {\n        var setDisposable = function () {\n          try {\n            autoDetachObserver.setDisposable(fixSubscriber(subscribe(autoDetachObserver)));\n          } catch (e) {\n            if (!autoDetachObserver.fail(e)) {\n              throw e;\n            }\n          }\n        };\n\n        var autoDetachObserver = new AutoDetachObserver(observer);\n        if (currentThreadScheduler.scheduleRequired()) {\n          currentThreadScheduler.schedule(setDisposable);\n        } else {\n          setDisposable();\n        }\n\n        return autoDetachObserver;\n      }\n\n      __super__.call(this, s);\n    }\n\n    return AnonymousObservable;\n\n  }(Observable));\n\n  var AutoDetachObserver = (function (__super__) {\n    inherits(AutoDetachObserver, __super__);\n\n    function AutoDetachObserver(observer) {\n      __super__.call(this);\n      this.observer = observer;\n      this.m = new SingleAssignmentDisposable();\n    }\n\n    var AutoDetachObserverPrototype = AutoDetachObserver.prototype;\n\n    AutoDetachObserverPrototype.next = function (value) {\n      var noError = false;\n      try {\n        this.observer.onNext(value);\n        noError = true;\n      } catch (e) {\n        throw e;\n      } finally {\n        !noError && this.dispose();\n      }\n    };\n\n    AutoDetachObserverPrototype.error = function (err) {\n      try {\n        this.observer.onError(err);\n      } catch (e) {\n        throw e;\n      } finally {\n        this.dispose();\n      }\n    };\n\n    AutoDetachObserverPrototype.completed = function () {\n      try {\n        this.observer.onCompleted();\n      } catch (e) {\n        throw e;\n      } finally {\n        this.dispose();\n      }\n    };\n\n    AutoDetachObserverPrototype.setDisposable = function (value) { this.m.setDisposable(value); };\n    AutoDetachObserverPrototype.getDisposable = function () { return this.m.getDisposable(); };\n\n    AutoDetachObserverPrototype.dispose = function () {\n      __super__.prototype.dispose.call(this);\n      this.m.dispose();\n    };\n\n    return AutoDetachObserver;\n  }(AbstractObserver));\n\n  var InnerSubscription = function (subject, observer) {\n    this.subject = subject;\n    this.observer = observer;\n  };\n\n  InnerSubscription.prototype.dispose = function () {\n    if (!this.subject.isDisposed && this.observer !== null) {\n      var idx = this.subject.observers.indexOf(this.observer);\n      this.subject.observers.splice(idx, 1);\n      this.observer = null;\n    }\n  };\n\n  /**\n   *  Represents an object that is both an observable sequence as well as an observer.\n   *  Each notification is broadcasted to all subscribed observers.\n   */\n  var Subject = Rx.Subject = (function (__super__) {\n    function subscribe(observer) {\n      checkDisposed.call(this);\n      if (!this.isStopped) {\n        this.observers.push(observer);\n        return new InnerSubscription(this, observer);\n      }\n      if (this.hasError) {\n        observer.onError(this.error);\n        return disposableEmpty;\n      }\n      observer.onCompleted();\n      return disposableEmpty;\n    }\n\n    inherits(Subject, __super__);\n\n    /**\n     * Creates a subject.\n     */\n    function Subject() {\n      __super__.call(this, subscribe);\n      this.isDisposed = false,\n      this.isStopped = false,\n      this.observers = [];\n      this.hasError = false;\n    }\n\n    addProperties(Subject.prototype, Observer.prototype, {\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () { return this.observers.length > 0; },\n      /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */\n      onCompleted: function () {\n        checkDisposed.call(this);\n        if (!this.isStopped) {\n          var os = this.observers.slice(0);\n          this.isStopped = true;\n          for (var i = 0, len = os.length; i < len; i++) {\n            os[i].onCompleted();\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed.call(this);\n        if (!this.isStopped) {\n          var os = this.observers.slice(0);\n          this.isStopped = true;\n          this.error = error;\n          this.hasError = true;\n          for (var i = 0, len = os.length; i < len; i++) {\n            os[i].onError(error);\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */\n      onNext: function (value) {\n        checkDisposed.call(this);\n        if (!this.isStopped) {\n          var os = this.observers.slice(0);\n          for (var i = 0, len = os.length; i < len; i++) {\n            os[i].onNext(value);\n          }\n        }\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n      }\n    });\n\n    /**\n     * Creates a subject from the specified observer and observable.\n     * @param {Observer} observer The observer used to send messages to the subject.\n     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.\n     * @returns {Subject} Subject implemented using the given observer and observable.\n     */\n    Subject.create = function (observer, observable) {\n      return new AnonymousSubject(observer, observable);\n    };\n\n    return Subject;\n  }(Observable));\n\n  /**\n   *  Represents the result of an asynchronous operation.\n   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.\n   */\n  var AsyncSubject = Rx.AsyncSubject = (function (__super__) {\n\n    function subscribe(observer) {\n      checkDisposed.call(this);\n\n      if (!this.isStopped) {\n        this.observers.push(observer);\n        return new InnerSubscription(this, observer);\n      }\n\n      if (this.hasError) {\n        observer.onError(this.error);\n      } else if (this.hasValue) {\n        observer.onNext(this.value);\n        observer.onCompleted();\n      } else {\n        observer.onCompleted();\n      }\n\n      return disposableEmpty;\n    }\n\n    inherits(AsyncSubject, __super__);\n\n    /**\n     * Creates a subject that can only receive one value and that value is cached for all future observations.\n     * @constructor\n     */\n    function AsyncSubject() {\n      __super__.call(this, subscribe);\n\n      this.isDisposed = false;\n      this.isStopped = false;\n      this.hasValue = false;\n      this.observers = [];\n      this.hasError = false;\n    }\n\n    addProperties(AsyncSubject.prototype, Observer, {\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () {\n        checkDisposed.call(this);\n        return this.observers.length > 0;\n      },\n      /**\n       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).\n       */\n      onCompleted: function () {\n        var i, len;\n        checkDisposed.call(this);\n        if (!this.isStopped) {\n          this.isStopped = true;\n          var os = this.observers.slice(0), len = os.length;\n\n          if (this.hasValue) {\n            for (i = 0; i < len; i++) {\n              var o = os[i];\n              o.onNext(this.value);\n              o.onCompleted();\n            }\n          } else {\n            for (i = 0; i < len; i++) {\n              os[i].onCompleted();\n            }\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the error.\n       * @param {Mixed} error The Error to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed.call(this);\n        if (!this.isStopped) {\n          var os = this.observers.slice(0);\n          this.isStopped = true;\n          this.hasError = true;\n          this.error = error;\n\n          for (var i = 0, len = os.length; i < len; i++) {\n            os[i].onError(error);\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.\n       * @param {Mixed} value The value to store in the subject.\n       */\n      onNext: function (value) {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        this.value = value;\n        this.hasValue = true;\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n        this.exception = null;\n        this.value = null;\n      }\n    });\n\n    return AsyncSubject;\n  }(Observable));\n\n  var AnonymousSubject = Rx.AnonymousSubject = (function (__super__) {\n    inherits(AnonymousSubject, __super__);\n\n    function subscribe(observer) {\n      this.observable.subscribe(observer);\n    }\n\n    function AnonymousSubject(observer, observable) {\n      this.observer = observer;\n      this.observable = observable;\n      __super__.call(this, subscribe);\n    }\n\n    addProperties(AnonymousSubject.prototype, Observer.prototype, {\n      onCompleted: function () {\n        this.observer.onCompleted();\n      },\n      onError: function (error) {\n        this.observer.onError(error);\n      },\n      onNext: function (value) {\n        this.observer.onNext(value);\n      }\n    });\n\n    return AnonymousSubject;\n  }(Observable));\n\n  /**\n   *  Represents a value that changes over time.\n   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.\n   */\n  var BehaviorSubject = Rx.BehaviorSubject = (function (__super__) {\n    function subscribe(observer) {\n      checkDisposed.call(this);\n      if (!this.isStopped) {\n        this.observers.push(observer);\n        observer.onNext(this.value);\n        return new InnerSubscription(this, observer);\n      }\n      if (this.hasError) {\n        observer.onError(this.error);\n      } else {\n        observer.onCompleted();\n      }\n      return disposableEmpty;\n    }\n\n    inherits(BehaviorSubject, __super__);\n\n    /**\n     *  Initializes a new instance of the BehaviorSubject class which creates a subject that caches its last value and starts with the specified value.\n     *  @param {Mixed} value Initial value sent to observers when no other value has been received by the subject yet.\n     */\n    function BehaviorSubject(value) {\n      __super__.call(this, subscribe);\n      this.value = value,\n      this.observers = [],\n      this.isDisposed = false,\n      this.isStopped = false,\n      this.hasError = false;\n    }\n\n    addProperties(BehaviorSubject.prototype, Observer, {\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () { return this.observers.length > 0; },\n      /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */\n      onCompleted: function () {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {\n          os[i].onCompleted();\n        }\n\n        this.observers.length = 0;\n      },\n      /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        this.hasError = true;\n        this.error = error;\n\n        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {\n          os[i].onError(error);\n        }\n\n        this.observers.length = 0;\n      },\n      /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */\n      onNext: function (value) {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        this.value = value;\n        for (var i = 0, os = this.observers.slice(0), len = os.length; i < len; i++) {\n          os[i].onNext(value);\n        }\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n        this.value = null;\n        this.exception = null;\n      }\n    });\n\n    return BehaviorSubject;\n  }(Observable));\n\n  /**\n   * Represents an object that is both an observable sequence as well as an observer.\n   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.\n   */\n  var ReplaySubject = Rx.ReplaySubject = (function (__super__) {\n\n    function createRemovableDisposable(subject, observer) {\n      return disposableCreate(function () {\n        observer.dispose();\n        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);\n      });\n    }\n\n    function subscribe(observer) {\n      var so = new ScheduledObserver(this.scheduler, observer),\n        subscription = createRemovableDisposable(this, so);\n      checkDisposed.call(this);\n      this._trim(this.scheduler.now());\n      this.observers.push(so);\n\n      for (var i = 0, len = this.q.length; i < len; i++) {\n        so.onNext(this.q[i].value);\n      }\n\n      if (this.hasError) {\n        so.onError(this.error);\n      } else if (this.isStopped) {\n        so.onCompleted();\n      }\n\n      so.ensureActive();\n      return subscription;\n    }\n\n    inherits(ReplaySubject, __super__);\n\n    /**\n     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.\n     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.\n     *  @param {Number} [windowSize] Maximum time length of the replay buffer.\n     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.\n     */\n    function ReplaySubject(bufferSize, windowSize, scheduler) {\n      this.bufferSize = bufferSize == null ? Number.MAX_VALUE : bufferSize;\n      this.windowSize = windowSize == null ? Number.MAX_VALUE : windowSize;\n      this.scheduler = scheduler || currentThreadScheduler;\n      this.q = [];\n      this.observers = [];\n      this.isStopped = false;\n      this.isDisposed = false;\n      this.hasError = false;\n      this.error = null;\n      __super__.call(this, subscribe);\n    }\n\n    addProperties(ReplaySubject.prototype, Observer.prototype, {\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () {\n        return this.observers.length > 0;\n      },\n      _trim: function (now) {\n        while (this.q.length > this.bufferSize) {\n          this.q.shift();\n        }\n        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {\n          this.q.shift();\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */\n      onNext: function (value) {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        var now = this.scheduler.now();\n        this.q.push({ interval: now, value: value });\n        this._trim(now);\n\n        var o = this.observers.slice(0);\n        for (var i = 0, len = o.length; i < len; i++) {\n          var observer = o[i];\n          observer.onNext(value);\n          observer.ensureActive();\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        this.error = error;\n        this.hasError = true;\n        var now = this.scheduler.now();\n        this._trim(now);\n        var o = this.observers.slice(0);\n        for (var i = 0, len = o.length; i < len; i++) {\n          var observer = o[i];\n          observer.onError(error);\n          observer.ensureActive();\n        }\n        this.observers = [];\n      },\n      /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */\n      onCompleted: function () {\n        checkDisposed.call(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        var now = this.scheduler.now();\n        this._trim(now);\n        var o = this.observers.slice(0);\n        for (var i = 0, len = o.length; i < len; i++) {\n          var observer = o[i];\n          observer.onCompleted();\n          observer.ensureActive();\n        }\n        this.observers = [];\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n      }\n    });\n\n    return ReplaySubject;\n  }(Observable));\n\n  /**\n  * Used to pause and resume streams.\n  */\n  Rx.Pauser = (function (__super__) {\n    inherits(Pauser, __super__);\n\n    function Pauser() {\n      __super__.call(this);\n    }\n\n    /**\n     * Pauses the underlying sequence.\n     */\n    Pauser.prototype.pause = function () { this.onNext(false); };\n\n    /**\n    * Resumes the underlying sequence.\n    */\n    Pauser.prototype.resume = function () { this.onNext(true); };\n\n    return Pauser;\n  }(Subject));\n\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    root.Rx = Rx;\n\n    define(function() {\n      return Rx;\n    });\n  } else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = Rx).Rx = Rx;\n    } else {\n      freeExports.Rx = Rx;\n    }\n  } else {\n    // in a browser or Rhino\n    root.Rx = Rx;\n  }\n\n  // All code before this point will be filtered from stack traces.\n  var rEndingLine = captureLine();\n\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/source-map.js":"(function() {\n\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * Define a module along with a payload.\n * @param {string} moduleName Name for the payload\n * @param {ignored} deps Ignored. For compatibility with CommonJS AMD Spec\n * @param {function} payload Function with (require, exports, module) params\n */\nfunction define(moduleName, deps, payload) {\n  if (typeof moduleName != \"string\") {\n    throw new TypeError('Expected string, got: ' + moduleName);\n  }\n\n  if (arguments.length == 2) {\n    payload = deps;\n  }\n\n  if (moduleName in define.modules) {\n    throw new Error(\"Module already defined: \" + moduleName);\n  }\n  define.modules[moduleName] = payload;\n};\n\n/**\n * The global store of un-instantiated modules\n */\ndefine.modules = {};\n\n\n/**\n * We invoke require() in the context of a Domain so we can have multiple\n * sets of modules running separate from each other.\n * This contrasts with JSMs which are singletons, Domains allows us to\n * optionally load a CommonJS module twice with separate data each time.\n * Perhaps you want 2 command lines with a different set of commands in each,\n * for example.\n */\nfunction Domain() {\n  this.modules = {};\n  this._currentModule = null;\n}\n\n(function () {\n\n  /**\n   * Lookup module names and resolve them by calling the definition function if\n   * needed.\n   * There are 2 ways to call this, either with an array of dependencies and a\n   * callback to call when the dependencies are found (which can happen\n   * asynchronously in an in-page context) or with a single string an no callback\n   * where the dependency is resolved synchronously and returned.\n   * The API is designed to be compatible with the CommonJS AMD spec and\n   * RequireJS.\n   * @param {string[]|string} deps A name, or names for the payload\n   * @param {function|undefined} callback Function to call when the dependencies\n   * are resolved\n   * @return {undefined|object} The module required or undefined for\n   * array/callback method\n   */\n  Domain.prototype.require = function(deps, callback) {\n    if (Array.isArray(deps)) {\n      var params = deps.map(function(dep) {\n        return this.lookup(dep);\n      }, this);\n      if (callback) {\n        callback.apply(null, params);\n      }\n      return undefined;\n    }\n    else {\n      return this.lookup(deps);\n    }\n  };\n\n  function normalize(path) {\n    var bits = path.split('/');\n    var i = 1;\n    while (i < bits.length) {\n      if (bits[i] === '..') {\n        bits.splice(i-1, 1);\n      } else if (bits[i] === '.') {\n        bits.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n    return bits.join('/');\n  }\n\n  function join(a, b) {\n    a = a.trim();\n    b = b.trim();\n    if (/^\\//.test(b)) {\n      return b;\n    } else {\n      return a.replace(/\\/*$/, '/') + b;\n    }\n  }\n\n  function dirname(path) {\n    var bits = path.split('/');\n    bits.pop();\n    return bits.join('/');\n  }\n\n  /**\n   * Lookup module names and resolve them by calling the definition function if\n   * needed.\n   * @param {string} moduleName A name for the payload to lookup\n   * @return {object} The module specified by aModuleName or null if not found.\n   */\n  Domain.prototype.lookup = function(moduleName) {\n    if (/^\\./.test(moduleName)) {\n      moduleName = normalize(join(dirname(this._currentModule), moduleName));\n    }\n\n    if (moduleName in this.modules) {\n      var module = this.modules[moduleName];\n      return module;\n    }\n\n    if (!(moduleName in define.modules)) {\n      throw new Error(\"Module not defined: \" + moduleName);\n    }\n\n    var module = define.modules[moduleName];\n\n    if (typeof module == \"function\") {\n      var exports = {};\n      var previousModule = this._currentModule;\n      this._currentModule = moduleName;\n      module(this.require.bind(this), exports, { id: moduleName, uri: \"\" });\n      this._currentModule = previousModule;\n      module = exports;\n    }\n\n    // cache the resulting module object for next time\n    this.modules[moduleName] = module;\n\n    return module;\n  };\n\n}());\n\ndefine.Domain = Domain;\ndefine.globalDomain = new Domain();\nvar require = define.globalDomain.require.bind(define.globalDomain);\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/source-map-generator', ['require', 'exports', 'module' ,  'source-map/base64-vlq', 'source-map/util', 'source-map/array-set'], function(require, exports, module) {\n\n  var base64VLQ = require('./base64-vlq');\n  var util = require('./util');\n  var ArraySet = require('./array-set').ArraySet;\n\n  /**\n   * An instance of the SourceMapGenerator represents a source map which is\n   * being built incrementally. To create a new one, you must pass an object\n   * with the following properties:\n   *\n   *   - file: The filename of the generated source.\n   *   - sourceRoot: An optional root for all URLs in this source map.\n   */\n  function SourceMapGenerator(aArgs) {\n    this._file = util.getArg(aArgs, 'file');\n    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = [];\n    this._sourcesContents = null;\n  }\n\n  SourceMapGenerator.prototype._version = 3;\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  SourceMapGenerator.fromSourceMap =\n    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n      var sourceRoot = aSourceMapConsumer.sourceRoot;\n      var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n      });\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        var newMapping = {\n          generated: {\n            line: mapping.generatedLine,\n            column: mapping.generatedColumn\n          }\n        };\n\n        if (mapping.source) {\n          newMapping.source = mapping.source;\n          if (sourceRoot) {\n            newMapping.source = util.relative(sourceRoot, newMapping.source);\n          }\n\n          newMapping.original = {\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          };\n\n          if (mapping.name) {\n            newMapping.name = mapping.name;\n          }\n        }\n\n        generator.addMapping(newMapping);\n      });\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content) {\n          generator.setSourceContent(sourceFile, content);\n        }\n      });\n      return generator;\n    };\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  SourceMapGenerator.prototype.addMapping =\n    function SourceMapGenerator_addMapping(aArgs) {\n      var generated = util.getArg(aArgs, 'generated');\n      var original = util.getArg(aArgs, 'original', null);\n      var source = util.getArg(aArgs, 'source', null);\n      var name = util.getArg(aArgs, 'name', null);\n\n      this._validateMapping(generated, original, source, name);\n\n      if (source && !this._sources.has(source)) {\n        this._sources.add(source);\n      }\n\n      if (name && !this._names.has(name)) {\n        this._names.add(name);\n      }\n\n      this._mappings.push({\n        generated: generated,\n        original: original,\n        source: source,\n        name: name\n      });\n    };\n\n  /**\n   * Set the source content for a source file.\n   */\n  SourceMapGenerator.prototype.setSourceContent =\n    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n      var source = aSourceFile;\n      if (this._sourceRoot) {\n        source = util.relative(this._sourceRoot, source);\n      }\n\n      if (aSourceContent !== null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n          this._sourcesContents = {};\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n      } else {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n          this._sourcesContents = null;\n        }\n      }\n    };\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   */\n  SourceMapGenerator.prototype.applySourceMap =\n    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {\n      // If aSourceFile is omitted, we will use the file property of the SourceMap\n      if (!aSourceFile) {\n        aSourceFile = aSourceMapConsumer.file;\n      }\n      var sourceRoot = this._sourceRoot;\n      // Make \"aSourceFile\" relative if an absolute Url is passed.\n      if (sourceRoot) {\n        aSourceFile = util.relative(sourceRoot, aSourceFile);\n      }\n      // Applying the SourceMap can add and remove items from the sources and\n      // the names array.\n      var newSources = new ArraySet();\n      var newNames = new ArraySet();\n\n      // Find mappings for the \"aSourceFile\"\n      this._mappings.forEach(function (mapping) {\n        if (mapping.source === aSourceFile && mapping.original) {\n          // Check if it can be mapped by the source map, then update the mapping.\n          var original = aSourceMapConsumer.originalPositionFor({\n            line: mapping.original.line,\n            column: mapping.original.column\n          });\n          if (original.source !== null) {\n            // Copy mapping\n            if (sourceRoot) {\n              mapping.source = util.relative(sourceRoot, original.source);\n            } else {\n              mapping.source = original.source;\n            }\n            mapping.original.line = original.line;\n            mapping.original.column = original.column;\n            if (original.name !== null && mapping.name !== null) {\n              // Only use the identifier name if it's an identifier\n              // in both SourceMaps\n              mapping.name = original.name;\n            }\n          }\n        }\n\n        var source = mapping.source;\n        if (source && !newSources.has(source)) {\n          newSources.add(source);\n        }\n\n        var name = mapping.name;\n        if (name && !newNames.has(name)) {\n          newNames.add(name);\n        }\n\n      }, this);\n      this._sources = newSources;\n      this._names = newNames;\n\n      // Copy sourcesContents of applied map.\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content) {\n          if (sourceRoot) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          this.setSourceContent(sourceFile, content);\n        }\n      }, this);\n    };\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  SourceMapGenerator.prototype._validateMapping =\n    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                                aName) {\n      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n          && aGenerated.line > 0 && aGenerated.column >= 0\n          && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n      }\n      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n               && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n               && aGenerated.line > 0 && aGenerated.column >= 0\n               && aOriginal.line > 0 && aOriginal.column >= 0\n               && aSource) {\n        // Cases 2 and 3.\n        return;\n      }\n      else {\n        throw new Error('Invalid mapping.');\n      }\n    };\n\n  function cmpLocation(loc1, loc2) {\n    var cmp = (loc1 && loc1.line) - (loc2 && loc2.line);\n    return cmp ? cmp : (loc1 && loc1.column) - (loc2 && loc2.column);\n  }\n\n  function strcmp(str1, str2) {\n    str1 = str1 || '';\n    str2 = str2 || '';\n    return (str1 > str2) - (str1 < str2);\n  }\n\n  function cmpMapping(mappingA, mappingB) {\n    return cmpLocation(mappingA.generated, mappingB.generated) ||\n      cmpLocation(mappingA.original, mappingB.original) ||\n      strcmp(mappingA.source, mappingB.source) ||\n      strcmp(mappingA.name, mappingB.name);\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  SourceMapGenerator.prototype._serializeMappings =\n    function SourceMapGenerator_serializeMappings() {\n      var previousGeneratedColumn = 0;\n      var previousGeneratedLine = 1;\n      var previousOriginalColumn = 0;\n      var previousOriginalLine = 0;\n      var previousName = 0;\n      var previousSource = 0;\n      var result = '';\n      var mapping;\n\n      // The mappings must be guaranteed to be in sorted order before we start\n      // serializing them or else the generated line numbers (which are defined\n      // via the ';' separators) will be all messed up. Note: it might be more\n      // performant to maintain the sorting as we insert them, rather than as we\n      // serialize them, but the big O is the same either way.\n      this._mappings.sort(cmpMapping);\n\n      for (var i = 0, len = this._mappings.length; i < len; i++) {\n        mapping = this._mappings[i];\n\n        if (mapping.generated.line !== previousGeneratedLine) {\n          previousGeneratedColumn = 0;\n          while (mapping.generated.line !== previousGeneratedLine) {\n            result += ';';\n            previousGeneratedLine++;\n          }\n        }\n        else {\n          if (i > 0) {\n            if (!cmpMapping(mapping, this._mappings[i - 1])) {\n              continue;\n            }\n            result += ',';\n          }\n        }\n\n        result += base64VLQ.encode(mapping.generated.column\n                                   - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generated.column;\n\n        if (mapping.source && mapping.original) {\n          result += base64VLQ.encode(this._sources.indexOf(mapping.source)\n                                     - previousSource);\n          previousSource = this._sources.indexOf(mapping.source);\n\n          // lines are stored 0-based in SourceMap spec version 3\n          result += base64VLQ.encode(mapping.original.line - 1\n                                     - previousOriginalLine);\n          previousOriginalLine = mapping.original.line - 1;\n\n          result += base64VLQ.encode(mapping.original.column\n                                     - previousOriginalColumn);\n          previousOriginalColumn = mapping.original.column;\n\n          if (mapping.name) {\n            result += base64VLQ.encode(this._names.indexOf(mapping.name)\n                                       - previousName);\n            previousName = this._names.indexOf(mapping.name);\n          }\n        }\n      }\n\n      return result;\n    };\n\n  /**\n   * Externalize the source map.\n   */\n  SourceMapGenerator.prototype.toJSON =\n    function SourceMapGenerator_toJSON() {\n      var map = {\n        version: this._version,\n        file: this._file,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n      };\n      if (this._sourceRoot) {\n        map.sourceRoot = this._sourceRoot;\n      }\n      if (this._sourcesContents) {\n        map.sourcesContent = map.sources.map(function (source) {\n          if (map.sourceRoot) {\n            source = util.relative(map.sourceRoot, source);\n          }\n          return Object.prototype.hasOwnProperty.call(\n            this._sourcesContents, util.toSetString(source))\n            ? this._sourcesContents[util.toSetString(source)]\n            : null;\n        }, this);\n      }\n      return map;\n    };\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  SourceMapGenerator.prototype.toString =\n    function SourceMapGenerator_toString() {\n      return JSON.stringify(this);\n    };\n\n  exports.SourceMapGenerator = SourceMapGenerator;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\ndefine('source-map/base64-vlq', ['require', 'exports', 'module' ,  'source-map/base64'], function(require, exports, module) {\n\n  var base64 = require('./base64');\n\n  // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n  // length quantities we use in the source map spec, the first bit is the sign,\n  // the next four bits are the actual value, and the 6th bit is the\n  // continuation bit. The continuation bit tells us whether there are more\n  // digits in this value following this digit.\n  //\n  //   Continuation\n  //   |    Sign\n  //   |    |\n  //   V    V\n  //   101011\n\n  var VLQ_BASE_SHIFT = 5;\n\n  // binary: 100000\n  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n  // binary: 011111\n  var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n  // binary: 100000\n  var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n  /**\n   * Converts from a two-complement value to a value where the sign bit is\n   * is placed in the least significant bit.  For example, as decimals:\n   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n   */\n  function toVLQSigned(aValue) {\n    return aValue < 0\n      ? ((-aValue) << 1) + 1\n      : (aValue << 1) + 0;\n  }\n\n  /**\n   * Converts to a two-complement value from a value where the sign bit is\n   * is placed in the least significant bit.  For example, as decimals:\n   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n   */\n  function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative\n      ? -shifted\n      : shifted;\n  }\n\n  /**\n   * Returns the base 64 VLQ encoded value.\n   */\n  exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n\n    var vlq = toVLQSigned(aValue);\n\n    do {\n      digit = vlq & VLQ_BASE_MASK;\n      vlq >>>= VLQ_BASE_SHIFT;\n      if (vlq > 0) {\n        // There are still more digits in this value, so we must make sure the\n        // continuation bit is marked.\n        digit |= VLQ_CONTINUATION_BIT;\n      }\n      encoded += base64.encode(digit);\n    } while (vlq > 0);\n\n    return encoded;\n  };\n\n  /**\n   * Decodes the next base 64 VLQ value from the given string and returns the\n   * value and the rest of the string.\n   */\n  exports.decode = function base64VLQ_decode(aStr) {\n    var i = 0;\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n\n    do {\n      if (i >= strLen) {\n        throw new Error(\"Expected more digits in base 64 VLQ value.\");\n      }\n      digit = base64.decode(aStr.charAt(i++));\n      continuation = !!(digit & VLQ_CONTINUATION_BIT);\n      digit &= VLQ_BASE_MASK;\n      result = result + (digit << shift);\n      shift += VLQ_BASE_SHIFT;\n    } while (continuation);\n\n    return {\n      value: fromVLQSigned(result),\n      rest: aStr.slice(i)\n    };\n  };\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/base64', ['require', 'exports', 'module' , ], function(require, exports, module) {\n\n  var charToIntMap = {};\n  var intToCharMap = {};\n\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    .split('')\n    .forEach(function (ch, index) {\n      charToIntMap[ch] = index;\n      intToCharMap[index] = ch;\n    });\n\n  /**\n   * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n   */\n  exports.encode = function base64_encode(aNumber) {\n    if (aNumber in intToCharMap) {\n      return intToCharMap[aNumber];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n  };\n\n  /**\n   * Decode a single base 64 digit to an integer.\n   */\n  exports.decode = function base64_decode(aChar) {\n    if (aChar in charToIntMap) {\n      return charToIntMap[aChar];\n    }\n    throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\n  };\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/util', ['require', 'exports', 'module' , ], function(require, exports, module) {\n\n  /**\n   * This is a helper function for getting values from parameter/options\n   * objects.\n   *\n   * @param args The object we are extracting values from\n   * @param name The name of the property we are getting.\n   * @param defaultValue An optional value to return if the property is missing\n   * from the object. If this is not specified and the property is missing, an\n   * error will be thrown.\n   */\n  function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n      return aArgs[aName];\n    } else if (arguments.length === 3) {\n      return aDefaultValue;\n    } else {\n      throw new Error('\"' + aName + '\" is a required argument.');\n    }\n  }\n  exports.getArg = getArg;\n\n  var urlRegexp = /([\\w+\\-.]+):\\/\\/((\\w+:\\w+)@)?([\\w.]+)?(:(\\d+))?(\\S+)?/;\n\n  function urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n      return null;\n    }\n    return {\n      scheme: match[1],\n      auth: match[3],\n      host: match[4],\n      port: match[6],\n      path: match[7]\n    };\n  }\n  exports.urlParse = urlParse;\n\n  function urlGenerate(aParsedUrl) {\n    var url = aParsedUrl.scheme + \"://\";\n    if (aParsedUrl.auth) {\n      url += aParsedUrl.auth + \"@\"\n    }\n    if (aParsedUrl.host) {\n      url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n      url += \":\" + aParsedUrl.port\n    }\n    if (aParsedUrl.path) {\n      url += aParsedUrl.path;\n    }\n    return url;\n  }\n  exports.urlGenerate = urlGenerate;\n\n  function join(aRoot, aPath) {\n    var url;\n\n    if (aPath.match(urlRegexp)) {\n      return aPath;\n    }\n\n    if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {\n      url.path = aPath;\n      return urlGenerate(url);\n    }\n\n    return aRoot.replace(/\\/$/, '') + '/' + aPath;\n  }\n  exports.join = join;\n\n  /**\n   * Because behavior goes wacky when you set `__proto__` on objects, we\n   * have to prefix all the strings in our set with an arbitrary character.\n   *\n   * See https://github.com/mozilla/source-map/pull/31 and\n   * https://github.com/mozilla/source-map/issues/30\n   *\n   * @param String aStr\n   */\n  function toSetString(aStr) {\n    return '$' + aStr;\n  }\n  exports.toSetString = toSetString;\n\n  function fromSetString(aStr) {\n    return aStr.substr(1);\n  }\n  exports.fromSetString = fromSetString;\n\n  function relative(aRoot, aPath) {\n    aRoot = aRoot.replace(/\\/$/, '');\n\n    var url = urlParse(aRoot);\n    if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n      return aPath.slice(1);\n    }\n\n    return aPath.indexOf(aRoot + '/') === 0\n      ? aPath.substr(aRoot.length + 1)\n      : aPath;\n  }\n  exports.relative = relative;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/array-set', ['require', 'exports', 'module' ,  'source-map/util'], function(require, exports, module) {\n\n  var util = require('./util');\n\n  /**\n   * A data structure which is a combination of an array and a set. Adding a new\n   * member is O(1), testing for membership is O(1), and finding the index of an\n   * element is O(1). Removing elements from the set is not supported. Only\n   * strings are supported for membership.\n   */\n  function ArraySet() {\n    this._array = [];\n    this._set = {};\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for (var i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  };\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var isDuplicate = this.has(aStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set[util.toSetString(aStr)] = idx;\n    }\n  };\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.has = function ArraySet_has(aStr) {\n    return Object.prototype.hasOwnProperty.call(this._set,\n                                                util.toSetString(aStr));\n  };\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (this.has(aStr)) {\n      return this._set[util.toSetString(aStr)];\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  };\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error('No element indexed by ' + aIdx);\n  };\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n  };\n\n  exports.ArraySet = ArraySet;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/source-map-consumer', ['require', 'exports', 'module' ,  'source-map/util', 'source-map/binary-search', 'source-map/array-set', 'source-map/base64-vlq'], function(require, exports, module) {\n\n  var util = require('./util');\n  var binarySearch = require('./binary-search');\n  var ArraySet = require('./array-set').ArraySet;\n  var base64VLQ = require('./base64-vlq');\n\n  /**\n   * A SourceMapConsumer instance represents a parsed source map which we can\n   * query for information about the original file positions by giving it a file\n   * position in the generated source.\n   *\n   * The only parameter is the raw source map (either as a JSON string, or\n   * already parsed to an object). According to the spec, source maps have the\n   * following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - sources: An array of URLs to the original source files.\n   *   - names: An array of identifiers which can be referrenced by individual mappings.\n   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n   *   - sourcesContent: Optional. An array of contents of the original source files.\n   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n   *   - file: The generated file this source map is associated with.\n   *\n   * Here is an example source map, taken from the source map spec[0]:\n   *\n   *     {\n   *       version : 3,\n   *       file: \"out.js\",\n   *       sourceRoot : \"\",\n   *       sources: [\"foo.js\", \"bar.js\"],\n   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *       mappings: \"AA,AB;;ABCDE;\"\n   *     }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n   */\n  function SourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources');\n    var names = util.getArg(sourceMap, 'names');\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null);\n\n    if (version !== this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names, true);\n    this._sources = ArraySet.fromArray(sources, true);\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this.file = file;\n\n    // `this._generatedMappings` and `this._originalMappings` hold the parsed\n    // mapping coordinates from the source map's \"mappings\" attribute. Each\n    // object in the array is of the form\n    //\n    //     {\n    //       generatedLine: The line number in the generated code,\n    //       generatedColumn: The column number in the generated code,\n    //       source: The path to the original source file that generated this\n    //               chunk of code,\n    //       originalLine: The line number in the original source that\n    //                     corresponds to this chunk of generated code,\n    //       originalColumn: The column number in the original source that\n    //                       corresponds to this chunk of generated code,\n    //       name: The name of the original symbol which generated this chunk of\n    //             code.\n    //     }\n    //\n    // All properties except for `generatedLine` and `generatedColumn` can be\n    // `null`.\n    //\n    // `this._generatedMappings` is ordered by the generated positions.\n    //\n    // `this._originalMappings` is ordered by the original positions.\n    this._generatedMappings = [];\n    this._originalMappings = [];\n    this._parseMappings(mappings, sourceRoot);\n  }\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  SourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      return this._sources.toArray().map(function (s) {\n        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;\n      }, this);\n    }\n  });\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (an ordered list in this._generatedMappings).\n   */\n  SourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var mappingSeparator = /^[,;]/;\n      var str = aStr;\n      var mapping;\n      var temp;\n\n      while (str.length > 0) {\n        if (str.charAt(0) === ';') {\n          generatedLine++;\n          str = str.slice(1);\n          previousGeneratedColumn = 0;\n        }\n        else if (str.charAt(0) === ',') {\n          str = str.slice(1);\n        }\n        else {\n          mapping = {};\n          mapping.generatedLine = generatedLine;\n\n          // Generated column.\n          temp = base64VLQ.decode(str);\n          mapping.generatedColumn = previousGeneratedColumn + temp.value;\n          previousGeneratedColumn = mapping.generatedColumn;\n          str = temp.rest;\n\n          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {\n            // Original source.\n            temp = base64VLQ.decode(str);\n            mapping.source = this._sources.at(previousSource + temp.value);\n            previousSource += temp.value;\n            str = temp.rest;\n            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {\n              throw new Error('Found a source, but no line and column');\n            }\n\n            // Original line.\n            temp = base64VLQ.decode(str);\n            mapping.originalLine = previousOriginalLine + temp.value;\n            previousOriginalLine = mapping.originalLine;\n            // Lines are stored 0-based\n            mapping.originalLine += 1;\n            str = temp.rest;\n            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {\n              throw new Error('Found a source and line, but no column');\n            }\n\n            // Original column.\n            temp = base64VLQ.decode(str);\n            mapping.originalColumn = previousOriginalColumn + temp.value;\n            previousOriginalColumn = mapping.originalColumn;\n            str = temp.rest;\n\n            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {\n              // Original name.\n              temp = base64VLQ.decode(str);\n              mapping.name = this._names.at(previousName + temp.value);\n              previousName += temp.value;\n              str = temp.rest;\n            }\n          }\n\n          this._generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === 'number') {\n            this._originalMappings.push(mapping);\n          }\n        }\n      }\n\n      this._originalMappings.sort(this._compareOriginalPositions);\n    };\n\n  /**\n   * Comparator between two mappings where the original positions are compared.\n   */\n  SourceMapConsumer.prototype._compareOriginalPositions =\n    function SourceMapConsumer_compareOriginalPositions(mappingA, mappingB) {\n      if (mappingA.source > mappingB.source) {\n        return 1;\n      }\n      else if (mappingA.source < mappingB.source) {\n        return -1;\n      }\n      else {\n        var cmp = mappingA.originalLine - mappingB.originalLine;\n        return cmp === 0\n          ? mappingA.originalColumn - mappingB.originalColumn\n          : cmp;\n      }\n    };\n\n  /**\n   * Comparator between two mappings where the generated positions are compared.\n   */\n  SourceMapConsumer.prototype._compareGeneratedPositions =\n    function SourceMapConsumer_compareGeneratedPositions(mappingA, mappingB) {\n      var cmp = mappingA.generatedLine - mappingB.generatedLine;\n      return cmp === 0\n        ? mappingA.generatedColumn - mappingB.generatedColumn\n        : cmp;\n    };\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  SourceMapConsumer.prototype._findMapping =\n    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                           aColumnName, aComparator) {\n      // To return the position we are searching for, we must first find the\n      // mapping for the given position and then return the opposite position it\n      // points to. Because the mappings are sorted, we can use binary search to\n      // find the best mapping.\n\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got '\n                            + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got '\n                            + aNeedle[aColumnName]);\n      }\n\n      return binarySearch.search(aNeedle, aMappings, aComparator);\n    };\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  SourceMapConsumer.prototype.originalPositionFor =\n    function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      var mapping = this._findMapping(needle,\n                                      this._generatedMappings,\n                                      \"generatedLine\",\n                                      \"generatedColumn\",\n                                      this._compareGeneratedPositions);\n\n      if (mapping) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source && this.sourceRoot) {\n          source = util.join(this.sourceRoot, source);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: util.getArg(mapping, 'name', null)\n        };\n      }\n\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * availible.\n   */\n  SourceMapConsumer.prototype.sourceContentFor =\n    function SourceMapConsumer_sourceContentFor(aSource) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n\n      if (this.sourceRoot) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n\n      var url;\n      if (this.sourceRoot\n          && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\"\n            && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n        }\n\n        if ((!url.path || url.path == \"/\")\n            && this._sources.has(\"/\" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n        }\n      }\n\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  SourceMapConsumer.prototype.generatedPositionFor =\n    function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n      };\n\n      if (this.sourceRoot) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n\n      var mapping = this._findMapping(needle,\n                                      this._originalMappings,\n                                      \"originalLine\",\n                                      \"originalColumn\",\n                                      this._compareOriginalPositions);\n\n      if (mapping) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null)\n        };\n      }\n\n      return {\n        line: null,\n        column: null\n      };\n    };\n\n  SourceMapConsumer.GENERATED_ORDER = 1;\n  SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  SourceMapConsumer.prototype.eachMapping =\n    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n      var mappings;\n      switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n      }\n\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function (mapping) {\n        var source = mapping.source;\n        if (source && sourceRoot) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name\n        };\n      }).forEach(aCallback, context);\n    };\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/binary-search', ['require', 'exports', 'module' , ], function(require, exports, module) {\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the next\n    //      closest element that is less than that element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element which is less than the one we are searching for, so we\n    //      return null.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid]);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return aHaystack[mid];\n    }\n    else if (cmp > 0) {\n      // aHaystack[mid] is greater than our needle.\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n      }\n      // We did not find an exact match, return the next closest one\n      // (termination case 2).\n      return aHaystack[mid];\n    }\n    else {\n      // aHaystack[mid] is less than our needle.\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (2) or (3) and return the appropriate thing.\n      return aLow < 0\n        ? null\n        : aHaystack[aLow];\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the next lowest value checked if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare) {\n    return aHaystack.length > 0\n      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)\n      : null;\n  };\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/source-node', ['require', 'exports', 'module' ,  'source-map/source-map-generator', 'source-map/util'], function(require, exports, module) {\n\n  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n  var util = require('./util');\n\n  /**\n   * SourceNodes provide a way to abstract over interpolating/concatenating\n   * snippets of generated JavaScript source code while maintaining the line and\n   * column information associated with the original source code.\n   *\n   * @param aLine The original line number.\n   * @param aColumn The original column number.\n   * @param aSource The original source's filename.\n   * @param aChunks Optional. An array of strings which are snippets of\n   *        generated JS, or other SourceNodes.\n   * @param aName The original identifier.\n   */\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine === undefined ? null : aLine;\n    this.column = aColumn === undefined ? null : aColumn;\n    this.source = aSource === undefined ? null : aSource;\n    this.name = aName === undefined ? null : aName;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   */\n  SourceNode.fromStringWithSourceMap =\n    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {\n      // The SourceNode we want to fill with the generated code\n      // and the SourceMap\n      var node = new SourceNode();\n\n      // The generated code\n      // Processed fragments are removed from this array.\n      var remainingLines = aGeneratedCode.split('\\n');\n\n      // We need to remember the position of \"remainingLines\"\n      var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n      // The generate SourceNodes we need a code range.\n      // To extract it current and last mapping is used.\n      // Here we store the last mapping.\n      var lastMapping = null;\n\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        if (lastMapping === null) {\n          // We add the generated code until the first mapping\n          // to the SourceNode without any mapping.\n          // Each line is added as separate string.\n          while (lastGeneratedLine < mapping.generatedLine) {\n            node.add(remainingLines.shift() + \"\\n\");\n            lastGeneratedLine++;\n          }\n          if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[0];\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n          }\n        } else {\n          // We add the code from \"lastMapping\" to \"mapping\":\n          // First check if there is a new line in between.\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = \"\";\n            // Associate full lines with \"lastMapping\"\n            do {\n              code += remainingLines.shift() + \"\\n\";\n              lastGeneratedLine++;\n              lastGeneratedColumn = 0;\n            } while (lastGeneratedLine < mapping.generatedLine);\n            // When we reached the correct line, we add code until we\n            // reach the correct column too.\n            if (lastGeneratedColumn < mapping.generatedColumn) {\n              var nextLine = remainingLines[0];\n              code += nextLine.substr(0, mapping.generatedColumn);\n              remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n              lastGeneratedColumn = mapping.generatedColumn;\n            }\n            // Create the SourceNode.\n            addMappingWithCode(lastMapping, code);\n          } else {\n            // There is no new line in between.\n            // Associate the code between \"lastGeneratedColumn\" and\n            // \"mapping.generatedColumn\" with \"lastMapping\"\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn -\n                                          lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                                lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n          }\n        }\n        lastMapping = mapping;\n      }, this);\n      // We have processed all mappings.\n      // Associate the remaining code in the current line with \"lastMapping\"\n      // and add the remaining lines without any mapping\n      addMappingWithCode(lastMapping, remainingLines.join(\"\\n\"));\n\n      // Copy sourcesContent into SourceNode\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content) {\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n\n      return node;\n\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          node.add(new SourceNode(mapping.originalLine,\n                                  mapping.originalColumn,\n                                  mapping.source,\n                                  code,\n                                  mapping.name));\n        }\n      }\n    };\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    }\n    else if (aChunk instanceof SourceNode || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (var i = aChunk.length-1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    }\n    else if (aChunk instanceof SourceNode || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    this.children.forEach(function (chunk) {\n      if (chunk instanceof SourceNode) {\n        chunk.walk(aFn);\n      }\n      else {\n        if (chunk !== '') {\n          aFn(chunk, { source: this.source,\n                       line: this.line,\n                       column: this.column,\n                       name: this.name });\n        }\n      }\n    }, this);\n  };\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len-1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  };\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild instanceof SourceNode) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    }\n    else if (typeof lastChild === 'string') {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    }\n    else {\n      this.children.push(''.replace(aPattern, aReplacement));\n    }\n    return this;\n  };\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  SourceNode.prototype.setSourceContent =\n    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walkSourceContents =\n    function SourceNode_walkSourceContents(aFn) {\n      this.children.forEach(function (chunk) {\n        if (chunk instanceof SourceNode) {\n          chunk.walkSourceContents(aFn);\n        }\n      }, this);\n      Object.keys(this.sourceContents).forEach(function (sourceFileKey) {\n        aFn(util.fromSetString(sourceFileKey), this.sourceContents[sourceFileKey]);\n      }, this);\n    };\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  };\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if(lastOriginalSource !== original.source\n           || lastOriginalLine !== original.line\n           || lastOriginalColumn !== original.column\n           || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      chunk.split('').forEach(function (ch) {\n        if (ch === '\\n') {\n          generated.line++;\n          generated.column = 0;\n        } else {\n          generated.column++;\n        }\n      });\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map: map };\n  };\n\n  exports.SourceNode = SourceNode;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n///////////////////////////////////////////////////////////////////////////////\n\nwindow.sourceMap = {\n  SourceMapConsumer: require('source-map/source-map-consumer').SourceMapConsumer,\n  SourceMapGenerator: require('source-map/source-map-generator').SourceMapGenerator,\n  SourceNode: require('source-map/source-node').SourceNode\n};\n})();\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/sweeten.js":"requirejs.config({\n    shim: {\n        'underscore': {\n            exports: '_'\n        }\n    }\n});\n\nrequire([\"jquery\"], function($) {\n    require([\"sweet\"], function(sweet) {\n        $(function(){\n            window.sweeten = (function(){\n                // the textareas to turn into CodeMirror editors\n                var $textAreas = $(\".editor\");\n\n                var editors = {};\n                $textAreas.each(function(nb, textarea){\n                    // replace with a CM editor\n                    var editor = CodeMirror.fromTextArea(this, {\n                        lineNumbers:true,\n                        mode: \"javascript\"\n                    });\n                    editor.setOption(\"theme\", \"sweetprism\");\n                    editors[nb] = editor;\n\n                    // add sweeten button and output div\n                    var $editorDiv = $(textarea).next();\n                    $editorDiv.after('<button onclick=\"sweeten('+ nb +');\">' + \n                                  'Try it!</button><pre id=\"output-'+ nb +\n                                  '\" class=\"cm-s-sweetprism console\"></pre>')\n                });\n                \n                return function (nb) {\n                    var $console = $(\"#output-\" + nb);\n                    $console.css(\"display\", \"block\");\n                    try {\n                        var editor = editors[nb];\n                        var result = sweet.compile(editor.getValue());\n                        CodeMirror.runMode(result, \"javascript\", $console[0]);\n                    } catch(e) {\n                        $console.text(e);\n                    }\n                }\n            })();\n        });\n    });\n});","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/text.js":"/**\n * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/text for details\n */\n/*jslint regexp: true */\n/*global require, XMLHttpRequest, ActiveXObject,\n  define, window, process, Packages,\n  java, location, Components, FileUtils */\n\ndefine(['module'], function (module) {\n    'use strict';\n\n    var text, fs, Cc, Ci, xpcIsWindows,\n        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],\n        xmlRegExp = /^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im,\n        bodyRegExp = /<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im,\n        hasLocation = typeof location !== 'undefined' && location.href,\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\:/, ''),\n        defaultHostName = hasLocation && location.hostname,\n        defaultPort = hasLocation && (location.port || undefined),\n        buildMap = {},\n        masterConfig = (module.config && module.config()) || {};\n\n    text = {\n        version: '2.0.10',\n\n        strip: function (content) {\n            //Strips <?xml ...?> declarations so that external SVG and XML\n            //documents can be added to a document without worry. Also, if the string\n            //is an HTML document, only the part inside the body tag is returned.\n            if (content) {\n                content = content.replace(xmlRegExp, \"\");\n                var matches = content.match(bodyRegExp);\n                if (matches) {\n                    content = matches[1];\n                }\n            } else {\n                content = \"\";\n            }\n            return content;\n        },\n\n        jsEscape: function (content) {\n            return content.replace(/(['\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\")\n                .replace(/[\\u2028]/g, \"\\\\u2028\")\n                .replace(/[\\u2029]/g, \"\\\\u2029\");\n        },\n\n        createXhr: masterConfig.createXhr || function () {\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\n            var xhr, i, progId;\n            if (typeof XMLHttpRequest !== \"undefined\") {\n                return new XMLHttpRequest();\n            } else if (typeof ActiveXObject !== \"undefined\") {\n                for (i = 0; i < 3; i += 1) {\n                    progId = progIds[i];\n                    try {\n                        xhr = new ActiveXObject(progId);\n                    } catch (e) {}\n\n                    if (xhr) {\n                        progIds = [progId];  // so faster next time\n                        break;\n                    }\n                }\n            }\n\n            return xhr;\n        },\n\n        /**\n         * Parses a resource name into its component parts. Resource names\n         * look like: module/name.ext!strip, where the !strip part is\n         * optional.\n         * @param {String} name the resource name\n         * @returns {Object} with properties \"moduleName\", \"ext\" and \"strip\"\n         * where strip is a boolean.\n         */\n        parseName: function (name) {\n            var modName, ext, temp,\n                strip = false,\n                index = name.indexOf(\".\"),\n                isRelative = name.indexOf('./') === 0 ||\n                             name.indexOf('../') === 0;\n\n            if (index !== -1 && (!isRelative || index > 1)) {\n                modName = name.substring(0, index);\n                ext = name.substring(index + 1, name.length);\n            } else {\n                modName = name;\n            }\n\n            temp = ext || modName;\n            index = temp.indexOf(\"!\");\n            if (index !== -1) {\n                //Pull off the strip arg.\n                strip = temp.substring(index + 1) === \"strip\";\n                temp = temp.substring(0, index);\n                if (ext) {\n                    ext = temp;\n                } else {\n                    modName = temp;\n                }\n            }\n\n            return {\n                moduleName: modName,\n                ext: ext,\n                strip: strip\n            };\n        },\n\n        xdRegExp: /^((\\w+)\\:)?\\/\\/([^\\/\\\\]+)/,\n\n        /**\n         * Is an URL on another domain. Only works for browser use, returns\n         * false in non-browser environments. Only used to know if an\n         * optimized .js version of a text resource should be loaded\n         * instead.\n         * @param {String} url\n         * @returns Boolean\n         */\n        useXhr: function (url, protocol, hostname, port) {\n            var uProtocol, uHostName, uPort,\n                match = text.xdRegExp.exec(url);\n            if (!match) {\n                return true;\n            }\n            uProtocol = match[2];\n            uHostName = match[3];\n\n            uHostName = uHostName.split(':');\n            uPort = uHostName[1];\n            uHostName = uHostName[0];\n\n            return (!uProtocol || uProtocol === protocol) &&\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\n                   ((!uPort && !uHostName) || uPort === port);\n        },\n\n        finishLoad: function (name, strip, content, onLoad) {\n            content = strip ? text.strip(content) : content;\n            if (masterConfig.isBuild) {\n                buildMap[name] = content;\n            }\n            onLoad(content);\n        },\n\n        load: function (name, req, onLoad, config) {\n            //Name has format: some.module.filext!strip\n            //The strip part is optional.\n            //if strip is present, then that means only get the string contents\n            //inside a body tag in an HTML string. For XML/SVG content it means\n            //removing the <?xml ...?> declarations so the content can be inserted\n            //into the current doc without problems.\n\n            // Do not bother with the work if a build and text will\n            // not be inlined.\n            if (config.isBuild && !config.inlineText) {\n                onLoad();\n                return;\n            }\n\n            masterConfig.isBuild = config.isBuild;\n\n            var parsed = text.parseName(name),\n                nonStripName = parsed.moduleName +\n                    (parsed.ext ? '.' + parsed.ext : ''),\n                url = req.toUrl(nonStripName),\n                useXhr = (masterConfig.useXhr) ||\n                         text.useXhr;\n\n            // Do not load if it is an empty: url\n            if (url.indexOf('empty:') === 0) {\n                onLoad();\n                return;\n            }\n\n            //Load the text. Use XHR if possible and in a browser.\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\n                text.get(url, function (content) {\n                    text.finishLoad(name, parsed.strip, content, onLoad);\n                }, function (err) {\n                    if (onLoad.error) {\n                        onLoad.error(err);\n                    }\n                });\n            } else {\n                //Need to fetch the resource across domains. Assume\n                //the resource has been optimized into a JS module. Fetch\n                //by the module name + extension, but do not include the\n                //!strip part to avoid file system issues.\n                req([nonStripName], function (content) {\n                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,\n                                    parsed.strip, content, onLoad);\n                });\n            }\n        },\n\n        write: function (pluginName, moduleName, write, config) {\n            if (buildMap.hasOwnProperty(moduleName)) {\n                var content = text.jsEscape(buildMap[moduleName]);\n                write.asModule(pluginName + \"!\" + moduleName,\n                               \"define(function () { return '\" +\n                                   content +\n                               \"';});\\n\");\n            }\n        },\n\n        writeFile: function (pluginName, moduleName, req, write, config) {\n            var parsed = text.parseName(moduleName),\n                extPart = parsed.ext ? '.' + parsed.ext : '',\n                nonStripName = parsed.moduleName + extPart,\n                //Use a '.js' file name so that it indicates it is a\n                //script that can be loaded across domains.\n                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';\n\n            //Leverage own load() method to load plugin value, but only\n            //write out values that do not have the strip argument,\n            //to avoid any potential issues with ! in file names.\n            text.load(nonStripName, req, function (value) {\n                //Use own write() method to construct full module value.\n                //But need to create shell that translates writeFile's\n                //write() to the right interface.\n                var textWrite = function (contents) {\n                    return write(fileName, contents);\n                };\n                textWrite.asModule = function (moduleName, contents) {\n                    return write.asModule(moduleName, fileName, contents);\n                };\n\n                text.write(pluginName, nonStripName, textWrite, config);\n            }, config);\n        }\n    };\n\n    if (masterConfig.env === 'node' || (!masterConfig.env &&\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            !!process.versions.node &&\n            !process.versions['node-webkit'])) {\n        //Using special require.nodeRequire, something added by r.js.\n        fs = require.nodeRequire('fs');\n\n        text.get = function (url, callback, errback) {\n            try {\n                var file = fs.readFileSync(url, 'utf8');\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\n                if (file.indexOf('\\uFEFF') === 0) {\n                    file = file.substring(1);\n                }\n                callback(file);\n            } catch (e) {\n                errback(e);\n            }\n        };\n    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&\n            text.createXhr())) {\n        text.get = function (url, callback, errback, headers) {\n            var xhr = text.createXhr(), header;\n            xhr.open('GET', url, true);\n\n            //Allow plugins direct access to xhr headers\n            if (headers) {\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\n                    }\n                }\n            }\n\n            //Allow overrides specified in config\n            if (masterConfig.onXhr) {\n                masterConfig.onXhr(xhr, url);\n            }\n\n            xhr.onreadystatechange = function (evt) {\n                var status, err;\n                //Do not explicitly handle errors, those should be\n                //visible via console output in the browser.\n                if (xhr.readyState === 4) {\n                    status = xhr.status;\n                    if (status > 399 && status < 600) {\n                        //An http 4xx or 5xx error. Signal an error.\n                        err = new Error(url + ' HTTP status: ' + status);\n                        err.xhr = xhr;\n                        errback(err);\n                    } else {\n                        callback(xhr.responseText);\n                    }\n\n                    if (masterConfig.onXhrComplete) {\n                        masterConfig.onXhrComplete(xhr, url);\n                    }\n                }\n            };\n            xhr.send(null);\n        };\n    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&\n            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {\n        //Why Java, why is this so awkward?\n        text.get = function (url, callback) {\n            var stringBuffer, line,\n                encoding = \"utf-8\",\n                file = new java.io.File(url),\n                lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n                content = '';\n            try {\n                stringBuffer = new java.lang.StringBuffer();\n                line = input.readLine();\n\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n                // http://www.unicode.org/faq/utf_bom.html\n\n                // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\n                    // Eat the BOM, since we've already found the encoding on this file,\n                    // and we plan to concatenating this buffer with others; the BOM should\n                    // only appear at the top of a file.\n                    line = line.substring(1);\n                }\n\n                if (line !== null) {\n                    stringBuffer.append(line);\n                }\n\n                while ((line = input.readLine()) !== null) {\n                    stringBuffer.append(lineSeparator);\n                    stringBuffer.append(line);\n                }\n                //Make sure we return a JavaScript string and not a Java string.\n                content = String(stringBuffer.toString()); //String\n            } finally {\n                input.close();\n            }\n            callback(content);\n        };\n    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&\n            typeof Components !== 'undefined' && Components.classes &&\n            Components.interfaces)) {\n        //Avert your gaze!\n        Cc = Components.classes,\n        Ci = Components.interfaces;\n        Components.utils['import']('resource://gre/modules/FileUtils.jsm');\n        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);\n\n        text.get = function (url, callback) {\n            var inStream, convertStream, fileObj,\n                readData = {};\n\n            if (xpcIsWindows) {\n                url = url.replace(/\\//g, '\\\\');\n            }\n\n            fileObj = new FileUtils.File(url);\n\n            //XPCOM, you so crazy\n            try {\n                inStream = Cc['@mozilla.org/network/file-input-stream;1']\n                           .createInstance(Ci.nsIFileInputStream);\n                inStream.init(fileObj, 1, 0, false);\n\n                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']\n                                .createInstance(Ci.nsIConverterInputStream);\n                convertStream.init(inStream, \"utf-8\", inStream.available(),\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n\n                convertStream.readString(inStream.available(), readData);\n                convertStream.close();\n                inStream.close();\n                callback(readData.value);\n            } catch (e) {\n                throw new Error((fileObj && fileObj.path || '') + ': ' + e);\n            }\n        };\n    }\n    return text;\n});\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/underscore.js":"//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate) {\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate(elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/browser/scripts/vim.js":"/**\n * Supported keybindings:\n *\n *   Motion:\n *   h, j, k, l\n *   gj, gk\n *   e, E, w, W, b, B, ge, gE\n *   f<character>, F<character>, t<character>, T<character>\n *   $, ^, 0, -, +, _\n *   gg, G\n *   %\n *   '<character>, `<character>\n *\n *   Operator:\n *   d, y, c\n *   dd, yy, cc\n *   g~, g~g~\n *   >, <, >>, <<\n *\n *   Operator-Motion:\n *   x, X, D, Y, C, ~\n *\n *   Action:\n *   a, i, s, A, I, S, o, O\n *   zz, z., z<CR>, zt, zb, z-\n *   J\n *   u, Ctrl-r\n *   m<character>\n *   r<character>\n *\n *   Modes:\n *   ESC - leave insert mode, visual mode, and clear input state.\n *   Ctrl-[, Ctrl-c - same as ESC.\n *\n * Registers: unamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instanstiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n */\n\n(function() {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: ['<Left>'], type: 'keyToKey', toKeys: ['h'] },\n    { keys: ['<Right>'], type: 'keyToKey', toKeys: ['l'] },\n    { keys: ['<Up>'], type: 'keyToKey', toKeys: ['k'] },\n    { keys: ['<Down>'], type: 'keyToKey', toKeys: ['j'] },\n    { keys: ['<Space>'], type: 'keyToKey', toKeys: ['l'] },\n    { keys: ['<BS>'], type: 'keyToKey', toKeys: ['h'] },\n    { keys: ['<C-Space>'], type: 'keyToKey', toKeys: ['W'] },\n    { keys: ['<C-BS>'], type: 'keyToKey', toKeys: ['B'] },\n    { keys: ['<S-Space>'], type: 'keyToKey', toKeys: ['w'] },\n    { keys: ['<S-BS>'], type: 'keyToKey', toKeys: ['b'] },\n    { keys: ['<C-n>'], type: 'keyToKey', toKeys: ['j'] },\n    { keys: ['<C-p>'], type: 'keyToKey', toKeys: ['k'] },\n    { keys: ['C-['], type: 'keyToKey', toKeys: ['<Esc>'] },\n    { keys: ['<C-c>'], type: 'keyToKey', toKeys: ['<Esc>'] },\n    { keys: ['s'], type: 'keyToKey', toKeys: ['c', 'l'] },\n    { keys: ['S'], type: 'keyToKey', toKeys: ['c', 'c'] },\n    { keys: ['<Home>'], type: 'keyToKey', toKeys: ['0'] },\n    { keys: ['<End>'], type: 'keyToKey', toKeys: ['$'] },\n    { keys: ['<PageUp>'], type: 'keyToKey', toKeys: ['<C-b>'] },\n    { keys: ['<PageDown>'], type: 'keyToKey', toKeys: ['<C-f>'] },\n    // Motions\n    { keys: ['H'], type: 'motion',\n        motion: 'moveToTopLine',\n        motionArgs: { linewise: true, toJumplist: true }},\n    { keys: ['M'], type: 'motion',\n        motion: 'moveToMiddleLine',\n        motionArgs: { linewise: true, toJumplist: true }},\n    { keys: ['L'], type: 'motion',\n        motion: 'moveToBottomLine',\n        motionArgs: { linewise: true, toJumplist: true }},\n    { keys: ['h'], type: 'motion',\n        motion: 'moveByCharacters',\n        motionArgs: { forward: false }},\n    { keys: ['l'], type: 'motion',\n        motion: 'moveByCharacters',\n        motionArgs: { forward: true }},\n    { keys: ['j'], type: 'motion',\n        motion: 'moveByLines',\n        motionArgs: { forward: true, linewise: true }},\n    { keys: ['k'], type: 'motion',\n        motion: 'moveByLines',\n        motionArgs: { forward: false, linewise: true }},\n    { keys: ['g','j'], type: 'motion',\n        motion: 'moveByDisplayLines',\n        motionArgs: { forward: true }},\n    { keys: ['g','k'], type: 'motion',\n        motion: 'moveByDisplayLines',\n        motionArgs: { forward: false }},\n    { keys: ['w'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: true, wordEnd: false }},\n    { keys: ['W'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: ['e'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: ['E'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: true, wordEnd: true, bigWord: true,\n            inclusive: true }},\n    { keys: ['b'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: false, wordEnd: false }},\n    { keys: ['B'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: ['g', 'e'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: ['g', 'E'], type: 'motion',\n        motion: 'moveByWords',\n        motionArgs: { forward: false, wordEnd: true, bigWord: true,\n            inclusive: true }},\n    { keys: ['{'], type: 'motion', motion: 'moveByParagraph',\n        motionArgs: { forward: false, toJumplist: true }},\n    { keys: ['}'], type: 'motion', motion: 'moveByParagraph',\n        motionArgs: { forward: true, toJumplist: true }},\n    { keys: ['<C-f>'], type: 'motion',\n        motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: ['<C-b>'], type: 'motion',\n        motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: ['<C-d>'], type: 'motion',\n        motion: 'moveByScroll',\n        motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: ['<C-u>'], type: 'motion',\n        motion: 'moveByScroll',\n        motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: ['g', 'g'], type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: ['G'], type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: ['0'], type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: ['^'], type: 'motion',\n        motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: ['+'], type: 'motion',\n        motion: 'moveByLines',\n        motionArgs: { forward: true, toFirstChar:true }},\n    { keys: ['-'], type: 'motion',\n        motion: 'moveByLines',\n        motionArgs: { forward: false, toFirstChar:true }},\n    { keys: ['_'], type: 'motion',\n        motion: 'moveByLines',\n        motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: ['$'], type: 'motion',\n        motion: 'moveToEol',\n        motionArgs: { inclusive: true }},\n    { keys: ['%'], type: 'motion',\n        motion: 'moveToMatchedSymbol',\n        motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: ['f', 'character'], type: 'motion',\n        motion: 'moveToCharacter',\n        motionArgs: { forward: true , inclusive: true }},\n    { keys: ['F', 'character'], type: 'motion',\n        motion: 'moveToCharacter',\n        motionArgs: { forward: false }},\n    { keys: ['t', 'character'], type: 'motion',\n        motion: 'moveTillCharacter',\n        motionArgs: { forward: true, inclusive: true }},\n    { keys: ['T', 'character'], type: 'motion',\n        motion: 'moveTillCharacter',\n        motionArgs: { forward: false }},\n    { keys: [';'], type: 'motion', motion: 'repeatLastCharacterSearch',\n        motionArgs: { forward: true }},\n    { keys: [','], type: 'motion', motion: 'repeatLastCharacterSearch',\n        motionArgs: { forward: false }},\n    { keys: ['\\'', 'character'], type: 'motion', motion: 'goToMark',\n        motionArgs: {toJumplist: true}},\n    { keys: ['`', 'character'], type: 'motion', motion: 'goToMark',\n        motionArgs: {toJumplist: true}},\n    { keys: [']', '`'], type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: ['[', '`'], type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: [']', '\\''], type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: ['[', '\\''], type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    { keys: [']', 'character'], type: 'motion',\n        motion: 'moveToSymbol',\n        motionArgs: { forward: true, toJumplist: true}},\n    { keys: ['[', 'character'], type: 'motion',\n        motion: 'moveToSymbol',\n        motionArgs: { forward: false, toJumplist: true}},\n    { keys: ['|'], type: 'motion',\n        motion: 'moveToColumn',\n        motionArgs: { }},\n    // Operators\n    { keys: ['d'], type: 'operator', operator: 'delete' },\n    { keys: ['y'], type: 'operator', operator: 'yank' },\n    { keys: ['c'], type: 'operator', operator: 'change',\n        operatorArgs: { enterInsertMode: true } },\n    { keys: ['>'], type: 'operator', operator: 'indent',\n        operatorArgs: { indentRight: true }},\n    { keys: ['<'], type: 'operator', operator: 'indent',\n        operatorArgs: { indentRight: false }},\n    { keys: ['g', '~'], type: 'operator', operator: 'swapcase' },\n    { keys: ['n'], type: 'motion', motion: 'findNext',\n        motionArgs: { forward: true, toJumplist: true }},\n    { keys: ['N'], type: 'motion', motion: 'findNext',\n        motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: ['x'], type: 'operatorMotion', operator: 'delete',\n        motion: 'moveByCharacters', motionArgs: { forward: true },\n        operatorMotionArgs: { visualLine: false }},\n    { keys: ['X'], type: 'operatorMotion', operator: 'delete',\n        motion: 'moveByCharacters', motionArgs: { forward: false },\n        operatorMotionArgs: { visualLine: true }},\n    { keys: ['D'], type: 'operatorMotion', operator: 'delete',\n      motion: 'moveToEol', motionArgs: { inclusive: true },\n        operatorMotionArgs: { visualLine: true }},\n    { keys: ['Y'], type: 'operatorMotion', operator: 'yank',\n        motion: 'moveToEol', motionArgs: { inclusive: true },\n        operatorMotionArgs: { visualLine: true }},\n    { keys: ['C'], type: 'operatorMotion',\n        operator: 'change', operatorArgs: { enterInsertMode: true },\n        motion: 'moveToEol', motionArgs: { inclusive: true },\n        operatorMotionArgs: { visualLine: true }},\n    { keys: ['~'], type: 'operatorMotion', operator: 'swapcase',\n        motion: 'moveByCharacters', motionArgs: { forward: true }},\n    // Actions\n    { keys: ['<C-i>'], type: 'action', action: 'jumpListWalk',\n        actionArgs: { forward: true }},\n    { keys: ['<C-o>'], type: 'action', action: 'jumpListWalk',\n        actionArgs: { forward: false }},\n    { keys: ['a'], type: 'action', action: 'enterInsertMode', isEdit: true,\n        actionArgs: { insertAt: 'charAfter' }},\n    { keys: ['A'], type: 'action', action: 'enterInsertMode', isEdit: true,\n        actionArgs: { insertAt: 'eol' }},\n    { keys: ['i'], type: 'action', action: 'enterInsertMode', isEdit: true,\n        actionArgs: { insertAt: 'inplace' }},\n    { keys: ['I'], type: 'action', action: 'enterInsertMode', isEdit: true,\n        actionArgs: { insertAt: 'firstNonBlank' }},\n    { keys: ['o'], type: 'action', action: 'newLineAndEnterInsertMode',\n        isEdit: true, interlaceInsertRepeat: true,\n        actionArgs: { after: true }},\n    { keys: ['O'], type: 'action', action: 'newLineAndEnterInsertMode',\n        isEdit: true, interlaceInsertRepeat: true,\n        actionArgs: { after: false }},\n    { keys: ['v'], type: 'action', action: 'toggleVisualMode' },\n    { keys: ['V'], type: 'action', action: 'toggleVisualMode',\n        actionArgs: { linewise: true }},\n    { keys: ['J'], type: 'action', action: 'joinLines', isEdit: true },\n    { keys: ['p'], type: 'action', action: 'paste', isEdit: true,\n        actionArgs: { after: true, isEdit: true }},\n    { keys: ['P'], type: 'action', action: 'paste', isEdit: true,\n        actionArgs: { after: false, isEdit: true }},\n    { keys: ['r', 'character'], type: 'action', action: 'replace', isEdit: true },\n    { keys: ['@', 'character'], type: 'action', action: 'replayMacro' },\n    { keys: ['q', 'character'], type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: ['R'], type: 'action', action: 'enterInsertMode', isEdit: true,\n        actionArgs: { replace: true }},\n    { keys: ['u'], type: 'action', action: 'undo' },\n    { keys: ['<C-r>'], type: 'action', action: 'redo' },\n    { keys: ['m', 'character'], type: 'action', action: 'setMark' },\n    { keys: ['\"', 'character'], type: 'action', action: 'setRegister' },\n    { keys: ['z', 'z'], type: 'action', action: 'scrollToCursor',\n        actionArgs: { position: 'center' }},\n    { keys: ['z', '.'], type: 'action', action: 'scrollToCursor',\n        actionArgs: { position: 'center' },\n        motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: ['z', 't'], type: 'action', action: 'scrollToCursor',\n        actionArgs: { position: 'top' }},\n    { keys: ['z', '<CR>'], type: 'action', action: 'scrollToCursor',\n        actionArgs: { position: 'top' },\n        motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: ['z', '-'], type: 'action', action: 'scrollToCursor',\n        actionArgs: { position: 'bottom' }},\n    { keys: ['z', 'b'], type: 'action', action: 'scrollToCursor',\n        actionArgs: { position: 'bottom' },\n        motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: ['.'], type: 'action', action: 'repeatLastEdit' },\n    { keys: ['<C-a>'], type: 'action', action: 'incrementNumberToken',\n        isEdit: true,\n        actionArgs: {increase: true, backtrack: false}},\n    { keys: ['<C-x>'], type: 'action', action: 'incrementNumberToken',\n        isEdit: true,\n        actionArgs: {increase: false, backtrack: false}},\n    // Text object motions\n    { keys: ['a', 'character'], type: 'motion',\n        motion: 'textObjectManipulation' },\n    { keys: ['i', 'character'], type: 'motion',\n        motion: 'textObjectManipulation',\n        motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: ['/'], type: 'search',\n        searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: ['?'], type: 'search',\n        searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: ['*'], type: 'search',\n        searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: ['#'], type: 'search',\n        searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: [':'], type: 'ex' }\n  ];\n\n  var Vim = function() {\n    var numberRegex = /[\\d]/;\n    var wordRegexp = [(/\\w/), (/[^\\w\\s]/)], bigWordRegexp = [(/\\S/)];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var specialSymbols = '~`!@#$%^&*()_-+=[{}]\\\\|/?.,<>:;\"\\''.split('');\n    var specialKeys = ['Left', 'Right', 'Up', 'Down', 'Space', 'Backspace',\n        'Esc', 'Home', 'End', 'PageUp', 'PageDown', 'Enter'];\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    var createMacroState = function() {\n      return {\n        macroKeyBuffer: [],\n        latestRegister: undefined,\n        inReplay: false,\n        lastInsertModeChanges: {\n          changes: [], // Change list\n          expectCursorActivityForChange: false // Set to true on change, false on cursorActivity.\n        },\n        enteredMacroMode: undefined,\n        isMacroPlaying: false,\n        toggle: function(cm, registerName) {\n          if (this.enteredMacroMode) { //onExit\n            this.enteredMacroMode(); // close dialog\n            this.enteredMacroMode = undefined;\n          } else { //onEnter\n            this.latestRegister = registerName;\n            this.enteredMacroMode = cm.openDialog(\n              '(recording)['+registerName+']', null, {bottom:true});\n          }\n        }\n      };\n    };\n\n    // Global Vim state. Call getVimGlobalState to get and initialize.\n    var vimGlobalState;\n    function getVimGlobalState() {\n      if (!vimGlobalState) {\n        vimGlobalState = {\n          // The current search query.\n          searchQuery: null,\n          // Whether we are searching backwards.\n          searchIsReversed: false,\n          jumpList: createCircularJumpList(),\n          macroModeState: createMacroState(),\n          // Recording latest f, t, F or T motion command.\n          lastChararacterSearch: {increment:0, forward:true, selectedCharacter:''},\n          registerController: new RegisterController({})\n        };\n      }\n      return vimGlobalState;\n    }\n    function getVimState(cm) {\n      if (!cm.vimState) {\n        // Store instance state in the CodeMirror object.\n        cm.vimState = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false\n        };\n      }\n      return cm.vimState;\n    }\n\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return getVimGlobalState().registerController;\n      },\n      // Testing hook.\n      clearVimGlobalState_: function() {\n        vimGlobalState = null;\n      },\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs);\n      },\n      defineEx: function(name, prefix, func){\n        if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      // Initializes vim state variable on the CodeMirror object. Should only be\n      // called lazily by handleKey or for testing.\n      maybeInitState: function(cm) {\n        getVimState(cm);\n      },\n      // This is the outermost function called by CodeMirror, after keys have\n      // been mapped to their Vim equivalents.\n      handleKey: function(cm, key) {\n        var command;\n        var vim = getVimState(cm);\n        var macroModeState = getVimGlobalState().macroModeState;\n        if (macroModeState.enteredMacroMode) {\n          if (key == 'q') {\n            actions.exitMacroRecordMode();\n            vim.inputState = new InputState();\n            return;\n          }\n        }\n        if (key == '<Esc>') {\n          // Clear input state and get back to normal mode.\n          vim.inputState = new InputState();\n          if (vim.visualMode) {\n            exitVisualMode(cm, vim);\n          }\n          return;\n        }\n        if (vim.visualMode &&\n            cursorEqual(cm.getCursor('head'), cm.getCursor('anchor'))) {\n          // The selection was cleared. Exit visual mode.\n          exitVisualMode(cm, vim);\n        }\n        if (!vim.visualMode &&\n            !cursorEqual(cm.getCursor('head'), cm.getCursor('anchor'))) {\n          vim.visualMode = true;\n          vim.visualLine = false;\n        }\n        if (key != '0' || (key == '0' && vim.inputState.getRepeat() === 0)) {\n          // Have to special case 0 since it's both a motion and a number.\n          command = commandDispatcher.matchCommand(key, defaultKeymap, vim);\n        }\n        if (!command) {\n          if (isNumber(key)) {\n            // Increment count unless count is 0 and key is 0.\n            vim.inputState.pushRepeatDigit(key);\n          }\n          return;\n        }\n        if (command.type == 'keyToKey') {\n          // TODO: prevent infinite recursion.\n          for (var i = 0; i < command.toKeys.length; i++) {\n            this.handleKey(cm, command.toKeys[i]);\n          }\n        } else {\n          if (macroModeState.enteredMacroMode) {\n            logKey(macroModeState, key);\n          }\n          commandDispatcher.processCommand(cm, vim, command);\n        }\n      }\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise) {\n      this.clear();\n      if (text) {\n        this.set(text, linewise);\n      }\n    }\n    Register.prototype = {\n      set: function(text, linewise) {\n        this.text = text;\n        this.linewise = !!linewise;\n      },\n      append: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise || this.linewise) {\n          this.text += '\\n' + text;\n          this.linewise = true;\n        } else {\n          this.text += text;\n        }\n      },\n      clear: function() {\n        this.text = '';\n        this.linewise = false;\n      },\n      toString: function() { return this.text; }\n    };\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unamedRegister = registers['\"'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise) {\n        if (linewise && text.charAt(0) == '\\n') {\n          text = text.slice(1) + '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unamedRegister.set(text, linewise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.append(text, linewise);\n          // The unamed register always has the same value as the last used\n          // register.\n          this.unamedRegister.append(text, linewise);\n        } else {\n          register.set(text, linewise);\n          this.unamedRegister.set(text, linewise);\n        }\n      },\n      setRegisterText: function(name, text, linewise) {\n        this.getRegister(name).set(text, linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n\n    var commandDispatcher = {\n      matchCommand: function(key, keyMap, vim) {\n        var inputState = vim.inputState;\n        var keys = inputState.keyBuffer.concat(key);\n        for (var i = 0; i < keyMap.length; i++) {\n          var command = keyMap[i];\n          if (matchKeysPartial(keys, command.keys)) {\n            if (keys.length < command.keys.length) {\n              // Matches part of a multi-key command. Buffer and wait for next\n              // stroke.\n              inputState.keyBuffer.push(key);\n              return null;\n            }\n            if (inputState.operator && command.type == 'action') {\n              // Ignore matched action commands after an operator. Operators\n              // only operate on motions. This check is really for text\n              // objects since aW, a[ etcs conflicts with a.\n              continue;\n            }\n            // Matches whole comand. Return the command.\n            if (command.keys[keys.length - 1] == 'character') {\n              inputState.selectedCharacter = keys[keys.length - 1];\n              if(inputState.selectedCharacter.length>1){\n                switch(inputState.selectedCharacter){\n                  case '<CR>':\n                    inputState.selectedCharacter='\\n';\n                    break;\n                  case '<Space>':\n                    inputState.selectedCharacter=' ';\n                    break;\n                  default:\n                    continue;\n                }\n              }\n            }\n            inputState.keyBuffer = [];\n            return command;\n          }\n        }\n        // Clear the buffer since there are no partial matches.\n        inputState.keyBuffer = [];\n        return null;\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            vim.inputState = new InputState();\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        vim.inputState = new InputState();\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        }\n        function onPromptKeyUp(_e, query) {\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, _query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[') {\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n\n            CodeMirror.e_stop(e);\n            close();\n            cm.focus();\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: searchPromptDesc,\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n            });\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword) {\n              query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            getVimGlobalState().jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, _input, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[') {\n            CodeMirror.e_stop(e);\n            close();\n            cm.focus();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion comand is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var selectionEnd = cm.getCursor('head');\n        var selectionStart = cm.getCursor('anchor');\n        // The difference between cur and selection cursors are that cur is\n        // being operated on and ignores that there is a selection.\n        var curStart = copyCursor(selectionEnd);\n        var curOriginal = copyCursor(curStart);\n        var curEnd;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        vim.inputState = new InputState();\n        if (motion) {\n          var motionResult = motions[motion](cm, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = getVimGlobalState().jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, curOriginal, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            curStart = motionResult[0];\n            curEnd = motionResult[1];\n          } else {\n            curEnd = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!curEnd) {\n            curEnd = { ch: curStart.ch, line: curStart.line };\n          }\n          if (vim.visualMode) {\n            // Check if the selection crossed over itself. Will need to shift\n            // the start point if that happened.\n            if (cursorIsBefore(selectionStart, selectionEnd) &&\n                (cursorEqual(selectionStart, curEnd) ||\n                    cursorIsBefore(curEnd, selectionStart))) {\n              // The end of the selection has moved from after the start to\n              // before the start. We will shift the start right by 1.\n              selectionStart.ch += 1;\n            } else if (cursorIsBefore(selectionEnd, selectionStart) &&\n                (cursorEqual(selectionStart, curEnd) ||\n                    cursorIsBefore(selectionStart, curEnd))) {\n              // The opposite happened. We will shift the start left by 1.\n              selectionStart.ch -= 1;\n            }\n            selectionEnd = curEnd;\n            if (vim.visualLine) {\n              if (cursorIsBefore(selectionStart, selectionEnd)) {\n                selectionStart.ch = 0;\n                selectionEnd.ch = lineLength(cm, selectionEnd.line);\n              } else {\n                selectionEnd.ch = 0;\n                selectionStart.ch = lineLength(cm, selectionStart.line);\n              }\n            }\n            cm.setSelection(selectionStart, selectionEnd);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(selectionStart, selectionEnd) ? selectionStart\n                    : selectionEnd);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(selectionStart, selectionEnd) ? selectionEnd\n                    : selectionStart);\n          } else if (!operator) {\n            curEnd = clipCursorToContent(cm, curEnd);\n            cm.setCursor(curEnd.line, curEnd.ch);\n          }\n        }\n\n        if (operator) {\n          var inverted = false;\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // Indent in visual mode needs this.\n          if (vim.visualMode) {\n            curStart = selectionStart;\n            curEnd = selectionEnd;\n            motionArgs.inclusive = true;\n          }\n          // Swap start and end if motion was backward.\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n            inverted = true;\n          }\n          if (motionArgs.inclusive && !(vim.visualMode && inverted)) {\n            // Move the selection end one to the right to include the last\n            // character.\n            curEnd.ch++;\n          }\n          var linewise = motionArgs.linewise ||\n              (vim.visualMode && vim.visualLine);\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          operators[operator](cm, operatorArgs, vim, curStart,\n              curEnd, curOriginal);\n          if (vim.visualMode) {\n            exitVisualMode(cm, vim);\n          }\n          if (operatorArgs.enterInsertMode) {\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = getVimGlobalState().macroModeState;\n        if (macroModeState.inReplay) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return { line: line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(line)) };\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return { line: line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(line)) };\n      },\n      moveToBottomLine: function(cm, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return { line: line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(line)) };\n      },\n      expandToLine: function(cm, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = cm.getCursor();\n        return { line: cur.line + motionArgs.repeat - 1, ch: Infinity };\n      },\n      findNext: function(cm, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(_cm, motionArgs, vim) {\n        var mark = vim.marks[motionArgs.selectedCharacter];\n        if (mark) {\n          return mark.find();\n        }\n        return null;\n      },\n      jumpToMark: function(cm, motionArgs, vim) {\n        var best = cm.getCursor();\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cusrorIsBetween(cursor, mark, best) :\n              cusrorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best.ch = findFirstNonWhiteSpaceCharacter(cm.getLine(best.line));\n        }\n        return best;\n      },\n      moveByCharacters: function(cm, motionArgs) {\n        var cur = cm.getCursor();\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return { line: cur.line, ch: ch };\n      },\n      moveByLines: function(cm, motionArgs, vim) {\n        var cur = cm.getCursor();\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        if (line < cm.firstLine() || line > cm.lastLine() ) {\n          return null;\n        }\n        if(motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords({line:line, ch:endCh},'div').left;\n        return { line: line, ch: endCh };\n      },\n      moveByDisplayLines: function(cm, motionArgs, vim) {\n        var cur = cm.getCursor();\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords({ line: cm.firstLine(), ch: 0}, 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = cm.getCursor();\n        var repeat = motionArgs.repeat;\n        cm.moveV((motionArgs.forward ? repeat : -repeat), 'page');\n        var curEnd = cm.getCursor();\n        cm.setCursor(curStart);\n        return curEnd;\n      },\n      moveByParagraph: function(cm, motionArgs) {\n        var line = cm.getCursor().line;\n        var repeat = motionArgs.repeat;\n        var inc = motionArgs.forward ? 1 : -1;\n        for (var i = 0; i < repeat; i++) {\n          if ((!motionArgs.forward && line === cm.firstLine() ) ||\n              (motionArgs.forward && line == cm.lastLine())) {\n            break;\n          }\n          line += inc;\n          while (line !== cm.firstLine() && line != cm.lastLine() && cm.getLine(line)) {\n            line += inc;\n          }\n        }\n        return { line: line, ch: 0 };\n      },\n      moveByScroll: function(cm, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(cm.getCursor(), 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, motionArgs) {\n        return moveToWord(cm, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if(!curEnd)return cm.getCursor();\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || cm.getCursor();\n      },\n      moveToSymbol: function(cm, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || cm.getCursor();\n      },\n      moveToColumn: function(cm, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(cm.getCursor(),'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, motionArgs, vim) {\n        var cur = cm.getCursor();\n        vim.lastHPos = Infinity;\n        var retval={ line: cur.line + motionArgs.repeat - 1, ch: Infinity };\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = cm.getCursor();\n        return { line: cursor.line,\n            ch: findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)) };\n      },\n      moveToMatchedSymbol: function(cm) {\n        var cursor = cm.getCursor();\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        var startContext = cm.getTokenAt(cursor).type;\n        var startCtxLevel = getContextLevel(startContext);\n        do {\n          symbol = lineText.charAt(ch++);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var endContext = cm.getTokenAt({line:line, ch:ch}).type;\n            var endCtxLevel = getContextLevel(endContext);\n            if (startCtxLevel >= endCtxLevel) {\n              break;\n            }\n          }\n        } while (symbol);\n        if (symbol) {\n          return findMatchedSymbol(cm, {line:line, ch:ch-1}, symbol);\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(cm) {\n        var cursor = cm.getCursor();\n        return { line: cursor.line, ch: 0 };\n      },\n      moveToLineOrEdgeOfDocument: function(cm, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return { line: lineNum,\n            ch: findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)) };\n      },\n      textObjectManipulation: function(cm, motionArgs) {\n        var character = motionArgs.selectedCharacter;\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n        if (!textObjects[character]) {\n          // No text object defined for this, don't move.\n          return null;\n        }\n        var tmp = textObjects[character](cm, inclusive);\n        var start = tmp.start;\n        var end = tmp.end;\n        return [start, end];\n      },\n      repeatLastCharacterSearch: function(cm, motionArgs) {\n        var lastSearch = getVimGlobalState().lastChararacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return cm.getCursor();\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    var operators = {\n      change: function(cm, operatorArgs, _vim, curStart, curEnd) {\n        getVimGlobalState().registerController.pushText(\n            operatorArgs.registerName, 'change', cm.getRange(curStart, curEnd),\n            operatorArgs.linewise);\n        if (operatorArgs.linewise) {\n          // Delete starting at the first nonwhitespace character of the first\n          // line, instead of from the start of the first line. This way we get\n          // an indent when we get into insert mode. This behavior isn't quite\n          // correct because we should treat this as a completely new line, and\n          // indent should be whatever codemirror thinks is the right indent.\n          // But cm.indentLine doesn't seem work on empty lines.\n          // TODO: Fix the above.\n          curStart.ch =\n              findFirstNonWhiteSpaceCharacter(cm.getLine(curStart.line));\n          // Insert an additional newline so that insert mode can start there.\n          // curEnd should be on the first character of the new line.\n          cm.replaceRange('\\n', curStart, curEnd);\n        } else {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var text = cm.getRange(curStart, curEnd);\n          if (!isWhiteSpaceString(text)) {\n            var match = (/\\s+$/).exec(text);\n            if (match) {\n              curEnd = offsetCursor(curEnd, 0, - match[0].length);\n            }\n          }\n          cm.replaceRange('', curStart, curEnd);\n        }\n        cm.setCursor(curStart);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, operatorArgs, _vim, curStart, curEnd) {\n        // If the ending line is past the last line, inclusive, instead of\n        // including the trailing \\n, include the \\n before the starting line\n        if (operatorArgs.linewise &&\n            curEnd.line > cm.lastLine() && curStart.line > cm.firstLine()) {\n          curStart.line--;\n          curStart.ch = lineLength(cm, curStart.line);\n        }\n        getVimGlobalState().registerController.pushText(\n            operatorArgs.registerName, 'delete', cm.getRange(curStart, curEnd),\n            operatorArgs.linewise);\n        cm.replaceRange('', curStart, curEnd);\n        if (operatorArgs.linewise) {\n          cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));\n        } else {\n          cm.setCursor(curStart);\n        }\n      },\n      indent: function(cm, operatorArgs, vim, curStart, curEnd) {\n        var startLine = curStart.line;\n        var endLine = curEnd.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? operatorArgs.repeat : 1;\n        if (operatorArgs.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, operatorArgs.indentRight);\n          }\n        }\n        cm.setCursor(curStart);\n        cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));\n      },\n      swapcase: function(cm, _operatorArgs, _vim, curStart, curEnd, curOriginal) {\n        var toSwap = cm.getRange(curStart, curEnd);\n        var swapped = '';\n        for (var i = 0; i < toSwap.length; i++) {\n          var character = toSwap.charAt(i);\n          swapped += isUpperCase(character) ? character.toLowerCase() :\n              character.toUpperCase();\n        }\n        cm.replaceRange(swapped, curStart, curEnd);\n        cm.setCursor(curOriginal);\n      },\n      yank: function(cm, operatorArgs, _vim, curStart, curEnd, curOriginal) {\n        getVimGlobalState().registerController.pushText(\n            operatorArgs.registerName, 'yank',\n            cm.getRange(curStart, curEnd), operatorArgs.linewise);\n        cm.setCursor(curOriginal);\n      }\n    };\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = getVimGlobalState().jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords({line: lineNum, ch: 0}, 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight*1.4;\n            break;\n          case 'top': y = y + lineHeight*0.4;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = getVimGlobalState().macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        var keyBuffer = parseRegisterToKeyBuffer(macroModeState, registerName);\n        while(repeat--){\n          executeMacroKeyBuffer(cm, macroModeState, keyBuffer);\n        }\n      },\n      exitMacroRecordMode: function() {\n        var macroModeState = getVimGlobalState().macroModeState;\n        macroModeState.toggle();\n        parseKeyBufferToRegister(macroModeState.latestRegister,\n                                 macroModeState.macroKeyBuffer);\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = getVimGlobalState().macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        macroModeState.toggle(cm, registerName);\n        emptyMacroKeyBuffer(macroModeState);\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        if (insertAt == 'eol') {\n          var cursor = cm.getCursor();\n          cursor = { line: cursor.line, ch: lineLength(cm, cursor.line) };\n          cm.setCursor(cursor);\n        } else if (insertAt == 'charAfter') {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n        } else if (insertAt == 'firstNonBlank') {\n          cm.setCursor(motions.moveToFirstNonWhiteSpaceCharacter(cm));\n        }\n        cm.setOption('keyMap', 'vim-insert');\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n        } else {\n          cm.setOption('keyMap', 'vim-insert');\n        }\n        if (!getVimGlobalState().macroModeState.inReplay) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          cm.on('cursorActivity', onCursorActivity);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var curStart = cm.getCursor();\n        var curEnd;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          if (vim.visualLine) {\n            curStart.ch = 0;\n            curEnd = clipCursorToContent(cm, {\n              line: curStart.line + repeat - 1,\n              ch: lineLength(cm, curStart.line)\n            }, true /** includeLineBreak */);\n          } else {\n            curEnd = clipCursorToContent(cm, {\n              line: curStart.line,\n              ch: curStart.ch + repeat\n            }, true /** includeLineBreak */);\n          }\n          // Make the initial selection.\n          if (!actionArgs.repeatIsExplicit && !vim.visualLine) {\n            // This is a strange case. Here the implicit repeat is 1. The\n            // following commands lets the cursor hover over the 1 character\n            // selection.\n            cm.setCursor(curEnd);\n            cm.setSelection(curEnd, curStart);\n          } else {\n            cm.setSelection(curStart, curEnd);\n          }\n        } else {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (!vim.visualLine && actionArgs.linewise) {\n            // Shift-V pressed in characterwise visual mode. Switch to linewise\n            // visual mode instead of exiting visual mode.\n            vim.visualLine = true;\n            curStart.ch = cursorIsBefore(curStart, curEnd) ? 0 :\n                lineLength(cm, curStart.line);\n            curEnd.ch = cursorIsBefore(curStart, curEnd) ?\n                lineLength(cm, curEnd.line) : 0;\n            cm.setSelection(curStart, curEnd);\n          } else if (vim.visualLine && !actionArgs.linewise) {\n            // v pressed in linewise visual mode. Switch to characterwise visual\n            // mode instead of exiting visual mode.\n            vim.visualLine = false;\n          } else {\n            exitVisualMode(cm, vim);\n          }\n        }\n        updateMark(cm, vim, '<', cursorIsBefore(curStart, curEnd) ? curStart\n            : curEnd);\n        updateMark(cm, vim, '>', cursorIsBefore(curStart, curEnd) ? curEnd\n            : curStart);\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, { line: curStart.line + repeat - 1,\n              ch: Infinity });\n        }\n        var finalCh = 0;\n        cm.operation(function() {\n          for (var i = curStart.line; i < curEnd.line; i++) {\n            finalCh = lineLength(cm, curStart.line);\n            var tmp = { line: curStart.line + 1,\n                ch: lineLength(cm, curStart.line + 1) };\n            var text = cm.getRange(curStart, tmp);\n            text = text.replace(/\\n\\s*/g, ' ');\n            cm.replaceRange(text, curStart, tmp);\n          }\n          var curFinalPos = { line: curStart.line, ch: finalCh };\n          cm.setCursor(curFinalPos);\n        });\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        var insertAt = cm.getCursor();\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', { line: cm.firstLine(), ch: 0 });\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var register = getVimGlobalState().registerController.getRegister(\n            actionArgs.registerName);\n        if (!register.text) {\n          return;\n        }\n        for (var text = '', i = 0; i < actionArgs.repeat; i++) {\n          text += register.text;\n        }\n        var linewise = register.linewise;\n        if (linewise) {\n          if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        cm.replaceRange(text, cur);\n        // Now fine tune the cursor to where we want it.\n        var curPosFinal;\n        var idx;\n        if (linewise && actionArgs.after) {\n          curPosFinal = { line: cur.line + 1,\n              ch: findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)) };\n        } else if (linewise && !actionArgs.after) {\n          curPosFinal = { line: cur.line,\n              ch: findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)) };\n        } else if (!linewise && actionArgs.after) {\n          idx = cm.indexFromPos(cur);\n          curPosFinal = cm.posFromIndex(idx + text.length - 1);\n        } else {\n          idx = cm.indexFromPos(cur);\n          curPosFinal = cm.posFromIndex(idx + text.length);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        if(vim.visualMode){\n          curStart=cm.getCursor('start');\n          curEnd=cm.getCursor('end');\n          // workaround to catch the character under the cursor\n          //  existing workaround doesn't cover actions\n          curEnd=cm.clipPos({line: curEnd.line, ch: curEnd.ch+1});\n        }else{\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = { line: curStart.line, ch: replaceTo };\n        }\n        if(replaceWith=='\\n'){\n          if(!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        }else {\n          var replaceWithStr=cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr=replaceWithStr.replace(/[^\\n]/g,replaceWith);\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n          if(vim.visualMode){\n            cm.setCursor(curStart);\n            exitVisualMode(cm,vim);\n          }else{\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if(cur.ch < end)break;\n        }\n        if(!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = {ch:start, line:cur.line};\n          var to = {ch:end, line:cur.line};\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor({line: cur.line, ch: start + numberStr.length - 1});\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      }\n    };\n\n    var textObjects = {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n      // TODO: implement text objects for the reverse like }. Should just be\n      //     an additional mapping after moving to the defaultKeyMap.\n      'w': function(cm, inclusive) {\n        return expandWordUnderCursor(cm, inclusive, true /** forward */,\n            false /** bigWord */);\n      },\n      'W': function(cm, inclusive) {\n        return expandWordUnderCursor(cm, inclusive,\n            true /** forward */, true /** bigWord */);\n      },\n      '{': function(cm, inclusive) {\n        return selectCompanionObject(cm, '}', inclusive);\n      },\n      '(': function(cm, inclusive) {\n        return selectCompanionObject(cm, ')', inclusive);\n      },\n      '[': function(cm, inclusive) {\n        return selectCompanionObject(cm, ']', inclusive);\n      },\n      '\\'': function(cm, inclusive) {\n        return findBeginningAndEnd(cm, \"'\", inclusive);\n      },\n      '\"': function(cm, inclusive) {\n        return findBeginningAndEnd(cm, '\"', inclusive);\n      }\n    };\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return { line: line, ch: ch };\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      return { line: cur.line + offsetLine, ch: cur.ch + offsetCh };\n    }\n    function matchKeysPartial(pressed, mapped) {\n      for (var i = 0; i < pressed.length; i++) {\n        // 'character' means any character. For mark, register commads, etc.\n        if (pressed[i] != mapped[i] && mapped[i] != 'character') {\n          return false;\n        }\n      }\n      return true;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return { line: cur.line, ch: cur.ch };\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cusrorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function reverse(s){\n      return s.split('').reverse().join('');\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n\n    function exitVisualMode(cm, vim) {\n      vim.visualMode = false;\n      vim.visualLine = false;\n      var selectionStart = cm.getCursor('anchor');\n      var selectionEnd = cm.getCursor('head');\n      if (!cursorEqual(selectionStart, selectionEnd)) {\n        // Clear the selection and set the cursor only if the selection has not\n        // already been cleared. Otherwise we risk moving the cursor somewhere\n        // it's not supposed to be.\n        cm.setCursor(clipCursorToContent(cm, selectionEnd));\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitepsace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = cm.getCursor();\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var textAfterIdx = line.substring(idx);\n      var firstMatchedChar;\n      if (noSymbol) {\n        firstMatchedChar = textAfterIdx.search(/\\w/);\n      } else {\n        firstMatchedChar = textAfterIdx.search(/\\S/);\n      }\n      if (firstMatchedChar == -1) {\n        return null;\n      }\n      idx += firstMatchedChar;\n      textAfterIdx = line.substring(idx);\n      var textBeforeIdx = line.substring(0, idx);\n\n      var matchRegex;\n      // Greedy matchers for the \"word\" we are trying to expand.\n      if (bigWord) {\n        matchRegex = /^\\S+/;\n      } else {\n        if ((/\\w/).test(line.charAt(idx))) {\n          matchRegex = /^\\w+/;\n        } else {\n          matchRegex = /^[^\\w\\s]+/;\n        }\n      }\n\n      var wordAfterRegex = matchRegex.exec(textAfterIdx);\n      var wordStart = idx;\n      var wordEnd = idx + wordAfterRegex[0].length;\n      // TODO: Find a better way to do this. It will be slow on very long lines.\n      var revTextBeforeIdx = reverse(textBeforeIdx);\n      var wordBeforeRegex = matchRegex.exec(revTextBeforeIdx);\n      if (wordBeforeRegex) {\n        wordStart -= wordBeforeRegex[0].length;\n      }\n\n      if (inclusive) {\n        // If present, trim all whitespace after word.\n        // Otherwise, trim all whitespace before word.\n        var textAfterWordEnd = line.substring(wordEnd);\n        var whitespacesAfterWord = textAfterWordEnd.match(/^\\s*/)[0].length;\n        if (whitespacesAfterWord > 0) {\n          wordEnd += whitespacesAfterWord;\n        } else {\n          var revTrim = revTextBeforeIdx.length - wordStart;\n          var textBeforeWordStart = revTextBeforeIdx.substring(revTrim);\n          var whitespacesBeforeWord = textBeforeWordStart.match(/^\\s*/)[0].length;\n          wordStart -= whitespacesBeforeWord;\n        }\n      }\n\n      return { start: { line: cur.line, ch: wordStart },\n        end: { line: cur.line, ch: wordEnd }};\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if(!cursorEqual(oldCur, newCur)) {\n        getVimGlobalState().jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        var vimGlobalState = getVimGlobalState();\n        vimGlobalState.lastChararacterSearch.increment = increment;\n        vimGlobalState.lastChararacterSearch.forward = args.forward;\n        vimGlobalState.lastChararacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if(state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if(state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if(token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = cm.getCursor();\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if(!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if(init)init(state);\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return { line: line, ch: state.index };\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var regexps = bigWord ? bigWordRegexp : wordRegexp;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < regexps.length && !foundWord; ++i) {\n            if (regexps[i].test(line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && regexps[i].test(line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n      // Should never get here.\n      throw new Error('The impossible happened.');\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, repeat, forward, wordEnd, bigWord) {\n      var cur = cm.getCursor();\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = {line: word.line, ch: forward ? (word.to - 1) : word.from};\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return {line: lastWord.line, ch: lastWord.from};\n      } else if (forward && wordEnd) {\n        return {line: lastWord.line, ch: lastWord.to - 1};\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return {line: lastWord.line, ch: lastWord.to};\n      } else {\n        // b\n        return {line: lastWord.line, ch: lastWord.from};\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return { line: cm.getCursor().line, ch: idx };\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, { line: line, ch: repeat - 1 });\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function getContextLevel(ctx) {\n      return (ctx === 'string' || ctx === 'comment') ? 1 : 0;\n    }\n\n    function findMatchedSymbol(cm, cur, symb) {\n      var line = cur.line;\n      var ch = cur.ch;\n      symb = symb ? symb : cm.getLine(line).charAt(ch);\n\n      var symbContext = cm.getTokenAt({line:line, ch:ch+1}).type;\n      var symbCtxLevel = getContextLevel(symbContext);\n\n      var reverseSymb = ({\n        '(': ')', ')': '(',\n        '[': ']', ']': '[',\n        '{': '}', '}': '{'})[symb];\n\n      // Couldn't find a matching symbol, abort\n      if (!reverseSymb) {\n        return cur;\n      }\n\n      // set our increment to move forward (+1) or backwards (-1)\n      // depending on which bracket we're matching\n      var increment = ({'(': 1, '{': 1, '[': 1})[symb] || -1;\n      var endLine = increment === 1 ? cm.lineCount() : -1;\n      var depth = 1, nextCh = symb, index = ch, lineText = cm.getLine(line);\n      // Simple search for closing paren--just count openings and closings till\n      // we find our match\n      // TODO: use info from CodeMirror to ignore closing brackets in comments\n      // and quotes, etc.\n      while (line !== endLine && depth > 0) {\n        index += increment;\n        nextCh = lineText.charAt(index);\n        if (!nextCh) {\n          line += increment;\n          lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            index = 0;\n          } else {\n            var lineLen = lineText.length;\n            index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          nextCh = lineText.charAt(index);\n        }\n        var revSymbContext = cm.getTokenAt({line:line, ch:index+1}).type;\n        var revSymbCtxLevel = getContextLevel(revSymbContext);\n        if (symbCtxLevel >= revSymbCtxLevel) {\n          if (nextCh === symb) {\n            depth++;\n          } else if (nextCh === reverseSymb) {\n            depth--;\n          }\n        }\n      }\n\n      if (nextCh) {\n        return { line: line, ch: index };\n      }\n      return cur;\n    }\n\n    function selectCompanionObject(cm, revSymb, inclusive) {\n      var cur = cm.getCursor();\n\n      var end = findMatchedSymbol(cm, cur, revSymb);\n      var start = findMatchedSymbol(cm, end);\n      start.ch += inclusive ? 1 : 0;\n      end.ch += inclusive ? 0 : 1;\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, symb, inclusive) {\n      var cur = cm.getCursor();\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: { line: cur.line, ch: start },\n        end: { line: cur.line, ch: end }\n      };\n    }\n\n    // Search functions\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return getVimGlobalState().query;\n      },\n      setQuery: function(query) {\n        getVimGlobalState().query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return getVimGlobalState().isReversed;\n      },\n      setReversed: function(reversed) {\n        getVimGlobalState().isReversed = reversed;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = getVimState(cm);\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp });\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = (c == '\\\\');\n      }\n      return slashes;\n    }\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openConfirm) {\n        cm.openConfirm('<span style=\"color: red\">' + text +\n            '</span> <button type=\"button\">OK</button>', function() {},\n            {bottom: true});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '';\n      if (prefix) {\n        raw += '<span style=\"font-family: monospace\">' + prefix + '</span>';\n      }\n      raw += '<input type=\"text\"/> ' +\n          '<span style=\"color: #888\">';\n      if (desc) {\n        raw += '<span style=\"color: #888\">';\n        raw += desc;\n        raw += '</span>';\n      }\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var overlay = getSearchState(cm).getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        getSearchState(cm).setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? { line: cm.lastLine() } : {line: cm.firstLine(), ch: 0} );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      getSearchState(cm).setOverlay(null);\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    // Ex command handling\n    // Care must be taken when adding to the default Ex command map. For any\n    // pair of commands that have a shared prefix, at least one of their\n    // shortNames must not match the prefix of the other command.\n    var defaultExCommandMap = [\n      { name: 'map', type: 'builtIn' },\n      { name: 'write', shortName: 'w', type: 'builtIn' },\n      { name: 'undo', shortName: 'u', type: 'builtIn' },\n      { name: 'redo', shortName: 'red', type: 'builtIn' },\n      { name: 'sort', shortName: 'sor', type: 'builtIn'},\n      { name: 'substitute', shortName: 's', type: 'builtIn'},\n      { name: 'nohlsearch', shortName: 'noh', type: 'builtIn'},\n      { name: 'delmarks', shortName: 'delm', type: 'builtin'}\n    ];\n    Vim.ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    Vim.ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input) {\n        var vim = getVimState(cm);\n        if (vim.visualMode) {\n          exitVisualMode(cm, vim);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        var params = {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          return;\n        }\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          var command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i]);\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n        } catch(e) {\n          showConfirm(cm, e);\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return cm.getCursor().line;\n          case '$':\n            return cm.lastLine();\n          case '\\'':\n            var mark = getVimState(cm).marks[inputStream.next()];\n            if (mark && mark.find()) {\n              return mark.find().line;\n            }\n            throw new Error('Mark not set');\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1)\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: parseKeyString(rhs)\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            defaultKeymap.unshift({\n              keys: parseKeyString(lhs),\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }});\n          } else {\n            // Key to key mapping\n            defaultKeymap.unshift({\n              keys: parseKeyString(lhs),\n              type: 'keyToKey',\n              toKeys: parseKeyString(rhs)\n            });\n          }\n        }\n      }\n    };\n\n    // Converts a key string sequence of the form a<C-w>bd<Left> into Vim's\n    // keymap representation.\n    function parseKeyString(str) {\n      var key, match;\n      var keys = [];\n      while (str) {\n        match = (/<\\w+-.+?>|<\\w+>|./).exec(str);\n        if(match === null)break;\n        key = match[0];\n        str = str.substring(match.index + key.length);\n        keys.push(key);\n      }\n      return keys;\n    }\n\n    var exCommands = {\n      map: function(cm, params) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], cm);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, getVimState(cm), {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { throw new Error('invalid arguments ' + args.match(/.*/)[0]); }\n            var opts = args.match(/[a-z]+/);\n            if (opts) {\n              opts = opts[0];\n              ignoreCase = opts.indexOf('i') != -1;\n              unique = opts.indexOf('u') != -1;\n              var decimal = opts.indexOf('d') != -1 && 1;\n              var hex = opts.indexOf('x') != -1 && 1;\n              var octal = opts.indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { throw new Error('invalid arguments'); }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (args.eatSpace() && args.match(/\\/.*\\//)) { throw new Error('patterns not supported'); }\n          }\n        }\n        parseArgs();\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = { line: lineStart, ch: 0 };\n        var curEnd = { line: lineEnd, ch: lineLength(cm, lineEnd) };\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number) {\n          for (var i = 0; i < text.length; i++) {\n            if (numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        numPart.sort(compareFn);\n        textPart.sort(compareFn);\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var slashes = findUnescapedSlashes(argString);\n        if (slashes[0] !== 0) {\n          showConfirm(cm, 'Substitutions should be of the form ' +\n              ':s/pattern/replace/');\n          return;\n        }\n        var regexPart = argString.substring(slashes[0] + 1, slashes[1]);\n        var replacePart = '';\n        var flagsPart;\n        var count;\n        var confirm = false; // Whether to confirm each replace.\n        if (slashes[1]) {\n          replacePart = argString.substring(slashes[1] + 1, slashes[2]);\n        }\n        if (slashes[2]) {\n          // After the 3rd slash, we can have flags followed by a space followed\n          // by count.\n          var trailing = argString.substring(slashes[2] + 1).split(' ');\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n        }\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n            flagsPart.replace('c', '');\n          }\n          regexPart = regexPart + '/' + flagsPart;\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, { line: lineStart, ch: 0 });\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, lineStart, lineEnd, cursor, query, replacePart);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else {\n          // Saves to text area if no save command is defined.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !params.argString.trim()) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = getVimState(cm);\n        var stream = new CodeMirror.StringStream(params.argString.trim());\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new Vim.ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    */\n    function doReplace(cm, confirm, lineStart, lineEnd, searchCursor, query,\n        replaceWith) {\n      // Set up all the functions.\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        var found = searchCursor.findNext();\n        if (!found) {\n          done = true;\n        } else if (isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n        } else {\n          done = true;\n        }\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = getVimState(cm);\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            cm.operation(replaceAll); break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        throw new Error('No matches for ' + query.source);\n      }\n      if (!confirm) {\n        replaceAll();\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    // Register Vim with CodeMirror\n    function buildVimKeyMap() {\n      /**\n       * Handle the raw key event from CodeMirror. Translate the\n       * Shift + key modifier to the resulting letter, while preserving other\n       * modifers.\n       */\n      // TODO: Figure out a way to catch capslock.\n      function cmKeyToVimKey(key, modifier) {\n        var vimKey = key;\n        if (isUpperCase(vimKey)) {\n          // Convert to lower case if shift is not the modifier since the key\n          // we get from CodeMirror is always upper case.\n          if (modifier == 'Shift') {\n            modifier = null;\n          }\n          else {\n            vimKey = vimKey.toLowerCase();\n          }\n        }\n        if (modifier) {\n          // Vim will parse modifier+key combination as a single key.\n          vimKey = modifier.charAt(0) + '-' + vimKey;\n        }\n        var specialKey = ({Enter:'CR',Backspace:'BS',Delete:'Del'})[vimKey];\n        vimKey = specialKey ? specialKey : vimKey;\n        vimKey = vimKey.length > 1 ? '<'+ vimKey + '>' : vimKey;\n        return vimKey;\n      }\n\n      // Closure to bind CodeMirror, key, modifier.\n      function keyMapper(vimKey) {\n        return function(cm) {\n          CodeMirror.Vim.handleKey(cm, vimKey);\n        };\n      }\n\n      var cmToVimKeymap = {\n        'nofallthrough': true,\n        'disableInput': true,\n        'style': 'fat-cursor'\n      };\n      function bindKeys(keys, modifier) {\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (!modifier && inArray(key, specialSymbols)) {\n            // Wrap special symbols with '' because that's how CodeMirror binds\n            // them.\n            key = \"'\" + key + \"'\";\n          }\n          var vimKey = cmKeyToVimKey(keys[i], modifier);\n          var cmKey = modifier ? modifier + '-' + key : key;\n          cmToVimKeymap[cmKey] = keyMapper(vimKey);\n        }\n      }\n      bindKeys(upperCaseAlphabet);\n      bindKeys(upperCaseAlphabet, 'Shift');\n      bindKeys(upperCaseAlphabet, 'Ctrl');\n      bindKeys(specialSymbols);\n      bindKeys(specialSymbols, 'Ctrl');\n      bindKeys(numbers);\n      bindKeys(numbers, 'Ctrl');\n      bindKeys(specialKeys);\n      bindKeys(specialKeys, 'Ctrl');\n      return cmToVimKeymap;\n    }\n    CodeMirror.keyMap.vim = buildVimKeyMap();\n\n    function exitInsertMode(cm) {\n      var vim = getVimState(cm);\n      vim.insertMode = false;\n      var inReplay = getVimGlobalState().macroModeState.inReplay;\n      if (!inReplay) {\n        cm.off('change', onChange);\n        cm.off('cursorActivity', onCursorActivity);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!inReplay && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1, true);\n      cm.setOption('keyMap', 'vim');\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    }\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      'Esc': exitInsertMode,\n      'Ctrl-[': exitInsertMode,\n      'Ctrl-C': exitInsertMode,\n      'Ctrl-N': 'autocomplete',\n      'Ctrl-P': 'autocomplete',\n      'Enter': function(cm) {\n        var fn = CodeMirror.commands.newlineAndIndentContinueComment ||\n            CodeMirror.commands.newlineAndIndent;\n        fn(cm);\n      },\n      fallthrough: ['default']\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert']\n    };\n\n    function parseRegisterToKeyBuffer(macroModeState, registerName) {\n      var match, key;\n      var register = getVimGlobalState().registerController.getRegister(registerName);\n      var text = register.toString();\n      var macroKeyBuffer = macroModeState.macroKeyBuffer;\n      emptyMacroKeyBuffer(macroModeState);\n      do {\n        match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n        if(match === null)break;\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        macroKeyBuffer.push(key);\n      } while (text);\n      return macroKeyBuffer;\n    }\n\n    function parseKeyBufferToRegister(registerName, keyBuffer) {\n      var text = keyBuffer.join('');\n      getVimGlobalState().registerController.setRegisterText(registerName, text);\n    }\n\n    function emptyMacroKeyBuffer(macroModeState) {\n      if(macroModeState.isMacroPlaying)return;\n      var macroKeyBuffer = macroModeState.macroKeyBuffer;\n      macroKeyBuffer.length = 0;\n    }\n\n    function executeMacroKeyBuffer(cm, macroModeState, keyBuffer) {\n      macroModeState.isMacroPlaying = true;\n      for (var i = 0, len = keyBuffer.length; i < len; i++) {\n        CodeMirror.Vim.handleKey(cm, keyBuffer[i]);\n      };\n      macroModeState.isMacroPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if(macroModeState.isMacroPlaying)return;\n      var macroKeyBuffer = macroModeState.macroKeyBuffer;\n      macroKeyBuffer.push(key);\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(_cm, changeObj) {\n      var macroModeState = getVimGlobalState().macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n            || changeObj.origin === undefined /* only in testing */) {\n          var text = changeObj.text.join('\\n');\n          lastChange.changes.push(text);\n        }\n        // Change objects may be chained with next.\n        changeObj = changeObj.next;\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    * - For tracking cursor activity in insert mode.\n    * - Should only be active in insert mode.\n    */\n    function onCursorActivity() {\n      var macroModeState = getVimGlobalState().macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.changes = [];\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = getVimGlobalState().macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      function onKeyFound() {\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, ['vim-insert'], onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = getVimGlobalState().macroModeState;\n      macroModeState.inReplay = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM will does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          repeatLastInsertModeChanges(cm, repeat, macroModeState);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.inReplay = false;\n    };\n\n    function repeatLastInsertModeChanges(cm, repeat, macroModeState) {\n      var lastChange = macroModeState.lastInsertModeChanges;\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      for (var i = 0; i < repeat; i++) {\n        for (var j = 0; j < lastChange.changes.length; j++) {\n          var change = lastChange.changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, ['vim-insert'], keyHandler);\n          } else {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          }\n        }\n      }\n    }\n\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n}\n)();\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/editor/addon/runmode.js":"CodeMirror.runMode = function(string, modespec, callback, options) {\n  var mode = CodeMirror.getMode(CodeMirror.defaults, modespec);\n\n  if (callback.nodeType == 1) {\n    var tabSize = (options && options.tabSize) || CodeMirror.defaults.tabSize;\n    var node = callback, col = 0;\n    node.innerHTML = \"\";\n    callback = function(text, style) {\n      if (text == \"\\n\") {\n        node.appendChild(document.createElement(\"br\"));\n        col = 0;\n        return;\n      }\n      var content = \"\";\n      // replace tabs\n      for (var pos = 0;;) {\n        var idx = text.indexOf(\"\\t\", pos);\n        if (idx == -1) {\n          content += text.slice(pos);\n          col += text.length - pos;\n          break;\n        } else {\n          col += idx - pos;\n          content += text.slice(pos, idx);\n          var size = tabSize - col % tabSize;\n          col += size;\n          for (var i = 0; i < size; ++i) content += \" \";\n          pos = idx + 1;\n        }\n      }\n\n      if (style) {\n        var sp = node.appendChild(document.createElement(\"span\"));\n        sp.className = \"cm-\" + style.replace(/ +/g, \" cm-\");\n        sp.appendChild(document.createTextNode(content));\n      } else {\n        node.appendChild(document.createTextNode(content));\n      }\n    };\n  }\n\n  var lines = CodeMirror.splitLines(string), state = CodeMirror.startState(mode);\n  for (var i = 0, e = lines.length; i < e; ++i) {\n    if (i) callback(\"\\n\");\n    var stream = new CodeMirror.StringStream(lines[i]);\n    while (!stream.eol()) {\n      var style = mode.token(stream, state);\n      callback(stream.current(), style, i, stream.start);\n      stream.start = stream.pos;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/default-readtable.js":"// @flow\n\nimport { List } from 'immutable';\nimport { isEOS, getCurrentReadtable, setCurrentReadtable } from 'readtable';\nimport readIdentifier from './read-identifier';\nimport readNumericLiteral from './read-numeric';\nimport readStringLiteral from './read-string';\nimport readTemplateLiteral from './read-template';\nimport readRegExp from './read-regexp.js';\nimport readComment from './read-comment';\nimport { readSyntaxTemplate } from './read-dispatch';\nimport {\n  punctuatorTable as punctuatorMapping,\n  keywordTable as keywordMapping,\n  KeywordToken,\n  PunctuatorToken,\n  EmptyToken,\n  IdentifierToken,\n} from '../tokens';\nimport {\n  insertSequence,\n  retrieveSequenceLength,\n  isExprPrefix,\n  isRegexPrefix,\n  isIdentifierPart,\n  isWhiteSpace,\n  isLineTerminator,\n  isDecimalDigit,\n} from './utils';\n\nimport type { CharStream } from 'readtable';\n\n// use https://github.com/mathiasbynens/regenerate to generate the Unicode code points when implementing modes\n\nfunction eatWhitespace(stream: CharStream) {\n  stream.readString();\n  return EmptyToken;\n}\n\nconst punctuatorTable = Object.keys(punctuatorMapping).reduce(\n  insertSequence,\n  {},\n);\n\nfunction readPunctuator(stream) {\n  const len = retrieveSequenceLength(punctuatorTable, stream, 0);\n  if (len > 0) {\n    return new PunctuatorToken({\n      value: stream.readString(len),\n    });\n  }\n  throw Error('Unknown punctuator');\n}\n\nconst punctuatorEntries = Object.keys(punctuatorTable).map(p => ({\n  key: p,\n  mode: 'terminating',\n  action: readPunctuator,\n}));\n\nconst whiteSpaceTable = [\n  0x20,\n  0x09,\n  0x0b,\n  0x0c,\n  0xa0,\n  0x1680,\n  0x2000,\n  0x2001,\n  0x2002,\n  0x2003,\n  0x2004,\n  0x2005,\n  0x2006,\n  0x2007,\n  0x2008,\n  0x2009,\n  0x200a,\n  0x202f,\n  0x205f,\n  0x3000,\n  0xfeff,\n];\n\nconst whiteSpaceEntries = whiteSpaceTable.map(w => ({\n  key: w,\n  mode: 'terminating',\n  action: eatWhitespace,\n}));\n\nconst lineTerminatorTable = [0x0a, 0x0d, 0x2028, 0x2029];\n\nconst lineTerminatorEntries = lineTerminatorTable.map(lt => ({\n  key: lt,\n  mode: 'terminating',\n  action: function readLineTerminator(stream) {\n    this.incrementLine();\n    return eatWhitespace(stream);\n  },\n}));\n\nconst digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\nconst numericEntries = digits.map(d => ({\n  key: d,\n  mode: 'non-terminating',\n  action: readNumericLiteral,\n}));\n\nconst quotes = ['\\'', '\"'];\n\nconst stringEntries = quotes.map(q => ({\n  key: q,\n  mode: 'terminating',\n  action: readStringLiteral,\n}));\n\nconst identifierEntry = {\n  mode: 'non-terminating',\n  action: readIdentifier,\n};\n\nconst templateEntry = {\n  key: '`',\n  mode: 'terminating',\n  action: readTemplateLiteral,\n};\n\nconst primitiveReadtable = getCurrentReadtable().extend(\n  ...[\n    identifierEntry,\n    ...whiteSpaceEntries,\n    templateEntry,\n    ...punctuatorEntries,\n    ...lineTerminatorEntries,\n    ...numericEntries,\n    ...stringEntries,\n  ],\n);\n\nconst dotEntry = {\n  key: '.',\n  mode: 'terminating',\n  action: function readDot(stream, ...rest) {\n    const nxt = stream.peek(1).charCodeAt(0);\n    if (isDecimalDigit(nxt)) {\n      return readNumericLiteral(stream, ...rest);\n    }\n    return readPunctuator.call(this, stream);\n  },\n};\n\nconst keywordTable = Object.keys(keywordMapping).reduce(insertSequence, {});\n\nconst keywordEntries = Object.keys(keywordTable).map(k => ({\n  key: k,\n  mode: 'non-terminating',\n  action: function readKeyword(stream) {\n    const len = retrieveSequenceLength(keywordTable, stream, 0);\n    if (len > 0 && !isIdentifierPart(stream.peek(len).charCodeAt(0))) {\n      return new KeywordToken({\n        value: stream.readString(len),\n      });\n    }\n    return readIdentifier.call(this, stream);\n  },\n}));\n\nconst delimiterPairs = [['[', ']'], ['(', ')']];\n\nfunction readDelimiters(closing, stream, prefix, b) {\n  const currentReadtable = getCurrentReadtable();\n  setCurrentReadtable(primitiveReadtable);\n\n  let results = List.of(this.readToken(stream, List(), b));\n\n  setCurrentReadtable(currentReadtable);\n  return this.readUntil(closing, stream, results, b);\n}\n\nconst delimiterEntries = delimiterPairs.map(p => ({\n  key: p[0],\n  mode: 'terminating',\n  action: function readDefaultDelimiters(stream, prefix, b) {\n    return readDelimiters.call(this, p[1], stream, prefix, true);\n  },\n}));\n\nconst bracesEntry = {\n  key: '{',\n  mode: 'terminating',\n  action: function readBraces(stream, prefix, b) {\n    const line = this.locationInfo.line;\n    const innerB = isExprPrefix(line, b, prefix);\n    return readDelimiters.call(this, '}', stream, prefix, innerB);\n  },\n};\n\nfunction readClosingDelimiter(opening, closing, stream, prefix, b) {\n  if (prefix.first().value !== opening) {\n    throw Error('Unmatched delimiter:', closing);\n  }\n  return readPunctuator.call(this, stream);\n}\n\nconst unmatchedDelimiterEntries = [\n  ['{', '}'],\n  ['[', ']'],\n  ['(', ')'],\n].map(p => ({\n  key: p[1],\n  mode: 'terminating',\n  action: function readClosingDelimiters(stream, prefix, b) {\n    return readClosingDelimiter.call(this, ...p, stream, prefix, b);\n  },\n}));\n\nconst divEntry = {\n  key: '/',\n  mode: 'terminating',\n  action: function readDiv(stream, prefix, b) {\n    let nxt = stream.peek(1);\n    if (nxt === '/' || nxt === '*') {\n      const result = readComment.call(this, stream);\n      return result;\n    }\n    if (isRegexPrefix(b, prefix)) {\n      return readRegExp.call(this, stream, prefix, b);\n    }\n    return readPunctuator.call(this, stream);\n  },\n};\n\nconst dispatchBacktickEntry = {\n  key: '`',\n  mode: 'dispatch',\n  action: readSyntaxTemplate,\n};\n\nconst defaultDispatchEntry = {\n  mode: 'dispatch',\n  action: function readDefaultDispatch(...args) {\n    this.readToken(...args);\n    return EmptyToken;\n  },\n};\n\nconst dispatchWhiteSpaceEntries = whiteSpaceTable\n  .concat(lineTerminatorTable)\n  .map(w => ({\n    key: w,\n    mode: 'dispatch',\n    action: function readDispatchWhitespace(\n      stream,\n      prefix,\n      allowExprs,\n      dispatchKey,\n    ) {\n      this.readToken(stream, prefix, allowExprs);\n      return new IdentifierToken({ value: dispatchKey });\n    },\n  }));\n\nconst atEntry = {\n  key: '@',\n  mode: 'terminating',\n  action: function readAt(stream, prefix) {\n    const nxt = stream.peek(1), nxtCode = nxt.charCodeAt(0);\n    if (isEOS(nxt) || isWhiteSpace(nxtCode) || isLineTerminator(nxtCode)) {\n      return new IdentifierToken({ value: stream.readString() });\n    }\n    throw new SyntaxError('Invalid or unexpected token');\n  },\n};\n\nconst defaultReadtable = primitiveReadtable.extend(\n  ...[\n    dotEntry,\n    ...delimiterEntries,\n    ...unmatchedDelimiterEntries,\n    bracesEntry,\n    divEntry,\n    ...keywordEntries,\n    defaultDispatchEntry,\n    dispatchBacktickEntry,\n    ...dispatchWhiteSpaceEntries,\n    atEntry,\n  ],\n);\n\nexport default defaultReadtable;\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-comment.js":"// @flow\nimport type { CharStream } from 'readtable';\n\nimport { isEOS } from 'readtable';\nimport { skipSingleLineComment } from './utils';\nimport { EmptyToken } from '../tokens';\n\nexport default function readComment(stream: CharStream): typeof EmptyToken {\n  let char = stream.peek();\n\n  while (!isEOS(char)) {\n    let chCode = char.charCodeAt(0);\n    if (chCode === 47) {\n      /* \"/\" */ const nxt = stream.peek(1);\n      if (isEOS(nxt)) {\n        break;\n      }\n      chCode = nxt.charCodeAt(0);\n      if (chCode === 47) {\n        /* \"/\" */ skipSingleLineComment.call(this, stream);\n      } else if (chCode === 42) {\n        /* \"*\" */ skipMultiLineComment.call(this, stream);\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n    char = stream.peek();\n  }\n\n  return EmptyToken;\n}\n\nfunction skipMultiLineComment(stream: CharStream): void {\n  let idx = 2;\n  let char = stream.peek(idx);\n  const { position: startPosition } = stream.sourceInfo;\n  let lineStart;\n  while (!isEOS(char)) {\n    let chCode = char.charCodeAt(0);\n    if (chCode < 0x80) {\n      switch (chCode) {\n        case 42: // \"*\"\n          // Block comment ends with \"*/\".\n          if (stream.peek(idx + 1).charAt(0) === '/') {\n            stream.readString(idx + 2);\n            if (lineStart)\n              this.locationInfo.column = stream.sourceInfo.position - lineStart;\n            return;\n          }\n          ++idx;\n          break;\n        case 10: // \"\\n\"\n          this.incrementLine();\n          lineStart = startPosition + idx;\n          ++idx;\n          break;\n        case 13: {\n          // \"\\r\":\n          let startIdx = idx;\n          if (stream.peek(idx + 1).charAt(0) === '\\n') {\n            ++idx;\n          }\n          ++idx;\n          this.incrementLine();\n          lineStart = startPosition + startIdx;\n          break;\n        }\n        default:\n          ++idx;\n      }\n    } else if (chCode === 0x2028 || chCode === 0x2029) {\n      this.incrementLine();\n      lineStart = startPosition + idx;\n      ++idx;\n    } else {\n      ++idx;\n    }\n    char = stream.peek(idx);\n  }\n  throw this.createILLEGAL(char);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-dispatch.js":"// @flow\n\nimport { getCurrentReadtable, setCurrentReadtable } from 'readtable';\nimport { List } from 'immutable';\nimport { TokenType as TT } from '../tokens';\n\nimport type { CharStream } from 'readtable';\n\nconst backtickEntry = {\n  key: '`',\n  mode: 'terminating',\n  action: function readBacktick(\n    stream: CharStream,\n    prefix: List<any>,\n    e: boolean,\n  ) {\n    if (prefix.isEmpty()) {\n      return {\n        type: TT.LSYNTAX,\n        value: stream.readString(),\n      };\n    }\n\n    return {\n      type: TT.RSYNTAX,\n      value: stream.readString(),\n    };\n  },\n};\n\nexport function readSyntaxTemplate(\n  stream: CharStream,\n  prefix: List<any>,\n  exprAllowed: boolean,\n  dispatchChar: string,\n): List<any> | { type: typeof TT.RSYNTAX, value: string } {\n  // return read('syntaxTemplate').first().token;\n  // TODO: Can we simply tack 'syntaxTemplate' on the front and process it as a\n  //       syntax macro?\n  const prevTable = getCurrentReadtable();\n  setCurrentReadtable(prevTable.extend(backtickEntry));\n\n  const result = this.readUntil(\n    '`',\n    stream,\n    List.of(\n      updateSyntax(dispatchChar, this.readToken(stream, List(), exprAllowed)),\n    ),\n    exprAllowed,\n  );\n\n  setCurrentReadtable(prevTable);\n  return result;\n}\n\nfunction updateSyntax(prefix, token) {\n  token.value = prefix + token.value;\n  token.slice.text = prefix + token.slice.text;\n  token.slice.start -= 1;\n  token.slice.startLocation.position -= 1;\n  return token;\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-identifier.js":"// @flow\n\nimport { scanUnicode } from './utils';\n\nimport { isEOS, getCurrentReadtable } from 'readtable';\nimport type { CharStream } from 'readtable';\n\nimport { IdentifierToken } from '../tokens';\n\nimport { isTerminating, isIdentifierPart, isIdentifierStart } from './utils';\n\nlet terminates;\n\nexport default function readIdentifier(stream: CharStream) {\n  terminates = isTerminating(getCurrentReadtable());\n  let char = stream.peek();\n  let code;\n  let check = isIdentifierStart;\n  let idx = 0;\n  while (!terminates(char) && !isEOS(char)) {\n    code = char.charCodeAt(0);\n    if (char === '\\\\' || (0xd800 <= code && code <= 0xdbff)) {\n      return new IdentifierToken({\n        value: getEscapedIdentifier.call(this, stream),\n      });\n    }\n    if (!check(code)) {\n      return new IdentifierToken({\n        value: stream.readString(idx),\n      });\n    }\n    char = stream.peek(++idx);\n    check = isIdentifierPart;\n  }\n  return new IdentifierToken({\n    value: stream.readString(idx),\n  });\n}\n\nfunction getEscapedIdentifier(stream) {\n  const sPeek = stream.peek.bind(stream);\n  let id = '';\n  let check = isIdentifierStart;\n  let char = sPeek();\n  let code = char.charCodeAt(0);\n  while (!terminates(char) && !isEOS(char)) {\n    let streamRead = false;\n    if (char === '\\\\') {\n      let nxt = sPeek(1);\n      if (isEOS(nxt)) {\n        throw this.createILLEGAL(char);\n      }\n      if (nxt !== 'u') {\n        throw this.createILLEGAL(char);\n      }\n      code = scanUnicode(stream, 2);\n      streamRead = true;\n      if (code < 0) {\n        throw this.createILLEGAL(char);\n      }\n    } else if (0xd800 <= code && code <= 0xdbff) {\n      if (isEOS(char)) {\n        throw this.createILLEGAL(char);\n      }\n      let lowSurrogateCode = sPeek(1).charCodeAt(0);\n      if (0xdc00 > lowSurrogateCode || lowSurrogateCode > 0xdfff) {\n        throw this.createILLEGAL(char);\n      }\n      stream.readString(2);\n      code = decodeUtf16(code, lowSurrogateCode);\n      streamRead = true;\n    }\n    if (!check(code)) {\n      if (id.length < 1) {\n        throw this.createILLEGAL(char);\n      }\n      return id;\n    }\n\n    if (!streamRead) stream.readString();\n\n    id += String.fromCodePoint(code);\n    char = sPeek();\n    code = char.charCodeAt(0);\n    check = isIdentifierPart;\n  }\n  return id;\n}\n\nfunction decodeUtf16(lead, trail) {\n  return (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-numeric.js":"// @flow\n\nimport { isEOS, getCurrentReadtable } from 'readtable';\nimport { code } from 'esutils';\nimport { isTerminating, getHexValue } from './utils';\nimport { NumericToken } from '../tokens';\n\nimport type { CharStream } from 'readtable';\n\nconst {\n  isIdentifierPartES6: isIdentifierPart,\n  isIdentifierStartES6: isIdentifierStart,\n} = code;\n\nlet terminates;\n\nexport default function readNumericLiteral(stream: CharStream) {\n  terminates = isTerminating(getCurrentReadtable());\n  let idx = 0, char = stream.peek();\n\n  if (char === '0') {\n    char = stream.peek(++idx);\n    if (!isEOS(char)) {\n      char = char.toLowerCase();\n      switch (char) {\n        case 'x':\n          return readHexLiteral.call(this, stream);\n        case 'b':\n          return readBinaryLiteral.call(this, stream);\n        case 'o':\n          return readOctalLiteral.call(this, stream);\n        default:\n          if (isDecimalChar(char)) {\n            return readLegacyOctalLiteral.call(this, stream); // reads legacy octal and decimal\n          }\n      }\n    } else {\n      return new NumericToken({\n        value: +stream.readString(),\n      });\n    }\n  } else if (char !== '.') {\n    while (!terminates(char) && isDecimalChar(char)) {\n      char = stream.peek(++idx);\n    }\n    if (isEOS(char)) {\n      return new NumericToken({\n        value: +stream.readString(idx),\n      });\n    }\n  }\n\n  idx = addDecimalLiteralSuffixLength.call(this, stream, idx);\n\n  char = stream.peek(idx);\n  if (!isEOS(char) && !terminates(char) && isIdentifierStart(char)) {\n    throw this.createILLEGAL(char);\n  }\n\n  return new NumericToken({\n    value: +stream.readString(idx),\n  });\n}\n\nfunction addDecimalLiteralSuffixLength(stream, idx) {\n  let char = stream.peek(idx);\n  if (char === '.') {\n    char = stream.peek(++idx);\n    if (isEOS(char)) return idx;\n\n    while (isDecimalChar(char)) {\n      char = stream.peek(++idx);\n      if (terminates(char) || isEOS(char)) return idx;\n    }\n  }\n\n  if (char.toLowerCase() === 'e') {\n    char = stream.peek(++idx);\n    if (isEOS(char)) throw this.createILLEGAL(char);\n\n    if (char === '+' || char === '-') {\n      char = stream.peek(++idx);\n      if (isEOS(char)) throw this.createILLEGAL(char);\n    }\n\n    while (isDecimalChar(char)) {\n      char = stream.peek(++idx);\n      if (terminates(char) || isEOS(char)) break;\n    }\n  }\n  return idx;\n}\n\nfunction readLegacyOctalLiteral(stream) {\n  let idx = 0, isOctal = true, char = stream.peek();\n\n  while (!terminates(char) && !isEOS(char)) {\n    if ('0' <= char && char <= '7') {\n      idx++;\n    } else if (char === '8' || char === '9') {\n      isOctal = false;\n      idx++;\n    } else if (isIdentifierPart(char.charCodeAt(0))) {\n      throw this.createILLEGAL(char);\n    } else {\n      break;\n    }\n\n    char = stream.peek(idx);\n  }\n\n  if (!isOctal)\n    return new NumericToken({\n      value: parseNumeric(stream, idx, 10),\n      octal: true,\n      noctal: !isOctal,\n    });\n\n  return new NumericToken({\n    value: parseNumeric(stream, idx, 8),\n    octal: true,\n    noctal: !isOctal,\n  });\n}\n\nfunction readOctalLiteral(stream) {\n  let start, idx = (start = 2), char = stream.peek(idx);\n  while (!terminates(char) && !isEOS(char)) {\n    if ('0' <= char && char <= '7') {\n      char = stream.peek(++idx);\n    } else if (isIdentifierPart(char.charCodeAt(0))) {\n      throw this.createILLEGAL(char);\n    } else {\n      break;\n    }\n  }\n\n  if (idx === start) {\n    throw this.createILLEGAL(char);\n  }\n\n  return new NumericToken({\n    value: parseNumeric(stream, idx, 8, start),\n  });\n}\n\nfunction readBinaryLiteral(stream) {\n  let start, idx = (start = 2);\n  let char = stream.peek(idx);\n\n  while (!terminates(char) && !isEOS(char)) {\n    if (char !== '0' && char !== '1') {\n      break;\n    }\n    char = stream.peek(idx);\n    idx++;\n  }\n\n  if (idx === start) {\n    throw this.createILLEGAL(char);\n  }\n\n  if (\n    !isEOS(char) &&\n    !terminates(char) &&\n    (isIdentifierStart(char) || isDecimalChar(char))\n  ) {\n    throw this.createILLEGAL(char);\n  }\n\n  return new NumericToken({\n    value: parseNumeric(stream, idx, 2, start),\n  });\n}\n\nfunction readHexLiteral(stream) {\n  let start, idx = (start = 2), char = stream.peek(idx);\n  while (!terminates(char)) {\n    let hex = getHexValue(char);\n    if (hex === -1) {\n      break;\n    }\n    char = stream.peek(++idx);\n  }\n\n  if (idx === start) {\n    throw this.createILLEGAL(char);\n  }\n\n  if (!isEOS(char) && !terminates(char) && isIdentifierStart(char)) {\n    throw this.createILLEGAL(char);\n  }\n\n  return new NumericToken({\n    value: parseNumeric(stream, idx, 16, start),\n  });\n}\n\nfunction parseNumeric(stream, len, radix, start = 0) {\n  stream.readString(start);\n  return parseInt(stream.readString(len - start), radix);\n}\n\nfunction isDecimalChar(char) {\n  return '0' <= char && char <= '9';\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-regexp.js":"// @flow\nimport type { CharStream } from 'readtable';\n\nimport { isEOS } from 'readtable';\nimport { RegExpToken } from '../tokens';\nimport { isLineTerminator, isIdentifierPart } from './utils';\n\nexport default function readRegExp(stream: CharStream) {\n  let value = stream.readString(),\n    char = stream.peek(),\n    idx = 0,\n    classMarker = false,\n    terminated = false;\n\n  const UNTERMINATED_REGEXP_MSG = 'Invalid regular expression: missing /';\n\n  while (!isEOS(char)) {\n    if (char === '\\\\') {\n      value += char;\n      ++idx;\n      char = stream.peek(idx);\n\n      if (isLineTerminator(char.charCodeAt(0))) {\n        throw this.createError(UNTERMINATED_REGEXP_MSG);\n      }\n      value += char;\n      ++idx;\n    } else if (isLineTerminator(char.charCodeAt(0))) {\n      throw this.createError(UNTERMINATED_REGEXP_MSG);\n    } else {\n      if (classMarker) {\n        if (char === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (char === '/') {\n          terminated = true;\n          value += char;\n          ++idx;\n          char = stream.peek(idx);\n          break;\n        } else if (char === '[') {\n          classMarker = true;\n        }\n      }\n      value += char;\n      ++idx;\n    }\n    char = stream.peek(idx);\n  }\n\n  if (!terminated) {\n    throw this.createError(UNTERMINATED_REGEXP_MSG);\n  }\n\n  while (!isEOS(char)) {\n    if (char === '\\\\') {\n      throw this.createError('Invalid regular expression flags');\n    }\n    if (!isIdentifierPart(char.charCodeAt(0))) {\n      break;\n    }\n    value += char;\n    ++idx;\n    char = stream.peek(idx);\n  }\n\n  stream.readString(idx);\n\n  return new RegExpToken({\n    value,\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-string.js":"// @flow\nimport type { CharStream } from 'readtable';\n\nimport { readStringEscape, isLineTerminator } from './utils';\nimport { isEOS } from 'readtable';\nimport { StringToken } from '../tokens';\n\nexport default function readStringLiteral(stream: CharStream): StringToken {\n  let str = '',\n    octal = null,\n    idx: number = 0,\n    quote = stream.readString(),\n    char = stream.peek(),\n    lineStart;\n\n  while (!isEOS(char)) {\n    if (char === quote) {\n      stream.readString(++idx);\n      if (lineStart != null) this.locationInfo.column += idx - lineStart;\n      return new StringToken({ str, octal });\n    } else if (char === '\\\\') {\n      [str, idx, octal, lineStart] = readStringEscape.call(\n        this,\n        str,\n        stream,\n        idx,\n        octal,\n      );\n    } else if (isLineTerminator(char.charCodeAt(0))) {\n      throw this.createILLEGAL(char);\n    } else {\n      ++idx;\n      str += char;\n    }\n    char = stream.peek(idx);\n  }\n  throw this.createILLEGAL(char);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/read-template.js":"// @flow\nimport { List } from 'immutable';\n\nimport type { CharStream } from 'readtable';\nimport { isEOS } from 'readtable';\n\nimport { readStringEscape } from './utils';\nimport { getSlice } from './token-reader';\nimport { TemplateToken, TemplateElementToken } from '../tokens';\n\nexport default function readTemplateLiteral(\n  stream: CharStream,\n  prefix: List<any>,\n): TemplateToken {\n  let element, items = [];\n  stream.readString();\n\n  do {\n    element = readTemplateElement.call(this, stream);\n    items.push(element);\n    if (element.interp) {\n      element = this.readToken(stream, List(), false);\n      items.push(element);\n    }\n  } while (!element.tail);\n\n  return new TemplateToken({\n    items: List(items),\n  });\n}\n\nfunction readTemplateElement(stream: CharStream): TemplateElementToken {\n  let char = stream.peek(), idx = 0, value = '', octal = null;\n  const startLocation = Object.assign({}, this.locationInfo, stream.sourceInfo);\n  while (!isEOS(char)) {\n    switch (char) {\n      case '`': {\n        stream.readString(idx);\n        const slice = getSlice(stream, startLocation);\n        stream.readString();\n        return new TemplateElementToken({\n          tail: true,\n          interp: false,\n          value,\n          slice,\n        });\n      }\n      case '$': {\n        if (stream.peek(idx + 1) === '{') {\n          stream.readString(idx);\n          const slice = getSlice(stream, startLocation);\n          stream.readString();\n\n          return new TemplateElementToken({\n            tail: false,\n            interp: true,\n            value,\n            slice,\n          });\n        }\n        break;\n      }\n      case '\\\\': {\n        let newVal;\n        [newVal, idx, octal] = readStringEscape.call(\n          this,\n          '',\n          stream,\n          idx,\n          octal,\n        );\n        if (octal != null) throw this.createILLEGAL(octal);\n        value += newVal;\n        --idx;\n        break;\n      }\n      default: {\n        value += char;\n      }\n    }\n    char = stream.peek(++idx);\n  }\n  throw this.createILLEGAL(char);\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/token-reader.js":"// @flow\n\nimport { CharStream, isEOS, Reader, setCurrentReadtable } from 'readtable';\nimport defaultReadtable from './default-readtable';\nimport { List } from 'immutable';\nimport { EmptyToken } from '../tokens';\n\nimport type { StartLocation, Slice } from '../tokens';\n\nsetCurrentReadtable(defaultReadtable);\n\nexport type LocationInfo = {\n  line: number,\n  column: number,\n};\n\ntype Context = {\n  bindings: any,\n  scopesets: any,\n};\n\nexport function getSlice(\n  stream: CharStream,\n  startLocation: StartLocation,\n): Slice {\n  return {\n    text: stream.getSlice(startLocation.position),\n    start: startLocation.position,\n    startLocation,\n    end: stream.sourceInfo.position,\n  };\n}\n\nconst streams = new WeakMap();\n\nclass ReadError extends Error {\n  index: number;\n  line: number;\n  column: number;\n  message: string;\n  constructor({\n    index,\n    line,\n    column,\n    message,\n  }: { index: number, line: number, column: number, message: string }) {\n    super(message);\n    this.index = index;\n    this.line = line;\n    this.column = column;\n    this.message = `[${line}:${column}] ${message}`;\n  }\n}\n\nclass TokenReader extends Reader {\n  locationInfo: LocationInfo;\n  context: ?Context;\n  constructor(stream: CharStream, context?: Context) {\n    super();\n    this.context = context;\n    streams.set(this, stream);\n    this.locationInfo = {\n      line: 1,\n      column: 1,\n    };\n  }\n\n  createError(msg: string): ReadError {\n    let message = msg.replace(/\\{(\\d+)\\}/g, (_, n) =>\n      JSON.stringify(arguments[+n + 1]),\n    );\n    return new ReadError({\n      message,\n      // $FlowFixMe: decide on how to handle possible nullability\n      index: streams.get(this).sourceInfo.position,\n      line: this.locationInfo.line,\n      column: this.locationInfo.column,\n    });\n  }\n\n  createILLEGAL(char) {\n    return !isEOS(char)\n      ? this.createError('Unexpected {0}', char)\n      : this.createError('Unexpected end of input');\n  }\n\n  readToken(stream: CharStream, ...rest: Array<any>) {\n    const startLocation = Object.assign(\n      {},\n      this.locationInfo,\n      stream.sourceInfo,\n    );\n    const result = super.read(stream, ...rest);\n\n    if (\n      startLocation.column === this.locationInfo.column &&\n      startLocation.line === this.locationInfo.line\n    ) {\n      this.locationInfo.column +=\n        stream.sourceInfo.position - startLocation.position;\n    }\n\n    if (result === EmptyToken) return result;\n\n    if (!List.isList(result)) result.slice = getSlice(stream, startLocation);\n\n    return result;\n  }\n\n  readUntil(\n    close: ?Function | ?string,\n    stream: CharStream,\n    prefix: List<any>,\n    exprAllowed: boolean,\n  ): List<any> {\n    let result, results = prefix, done = false;\n    do {\n      if (isEOS(stream.peek())) break;\n      done = typeof close === 'function' ? close() : stream.peek() === close;\n      result = this.readToken(stream, results, exprAllowed);\n\n      if (result !== EmptyToken) {\n        results = results.push(result);\n      }\n    } while (!done);\n    return results;\n  }\n\n  incrementLine(): void {\n    this.locationInfo.line += 1;\n    this.locationInfo.column = 1;\n  }\n}\n\nexport default function read(\n  source: string | CharStream,\n  context?: Context,\n): List<any> {\n  const stream = typeof source === 'string' ? new CharStream(source) : source;\n  if (isEOS(stream.peek())) return List();\n  return new TokenReader(stream, context).readUntil(\n    null,\n    stream,\n    List(),\n    false,\n  );\n}\n","/home/travis/build/npmtest/node-npmtest-sweet.js/node_modules/sweet.js/src/reader/utils.js":"// @flow\n\nimport { isEOS } from 'readtable';\nimport { List } from 'immutable';\n\nimport type { Readtable, CharStream } from 'readtable';\n\nimport { code } from 'esutils';\nimport type { TokenTree } from '../tokens';\nimport {\n  getLineNumber,\n  isPunctuator,\n  isKeyword,\n  isBraces,\n  isParens,\n  isIdentifier,\n} from '../tokens';\n\nconst {\n  isLineTerminator,\n  isWhiteSpace,\n  isDecimalDigit,\n  isIdentifierPartES6: isIdentifierPart,\n  isIdentifierStartES6: isIdentifierStart,\n} = code;\n\nimport * as R from 'ramda';\nimport { Maybe } from 'ramda-fantasy';\nconst Nothing = Maybe.Nothing;\n\n// TODO: also, need to handle contextual yield\nconst literalKeywords = ['this', 'null', 'true', 'false'];\n\nexport {\n  isLineTerminator,\n  isWhiteSpace,\n  isDecimalDigit,\n  isIdentifierStart,\n  isIdentifierPart,\n};\n\nexport function getHexValue(rune: string) {\n  if ('0' <= rune && rune <= '9') {\n    return rune.charCodeAt(0) - 48;\n  }\n  if ('a' <= rune && rune <= 'f') {\n    return rune.charCodeAt(0) - 87;\n  }\n  if ('A' <= rune && rune <= 'F') {\n    return rune.charCodeAt(0) - 55;\n  }\n  return -1;\n}\n\nexport function skipSingleLineComment(stream: CharStream): void {\n  let idx = 0;\n  let char = stream.peek(idx);\n  while (!isEOS(char)) {\n    let chCode = char.charCodeAt(0);\n    if (isLineTerminator(chCode)) {\n      ++idx;\n      if (chCode === 0xd /* \"\\r\" */ && stream.peek(idx).charCodeAt(0) === 0xa) {\n        /*\"\\n\" */ ++idx;\n      }\n      this.incrementLine();\n      break;\n    }\n    ++idx;\n    char = stream.peek(idx);\n  }\n  stream.readString(idx);\n}\n\nexport function scanUnicode(stream: CharStream, start: number) {\n  const sPeek = stream.peek.bind(stream);\n  let idx = start;\n  let hexDigits = 0;\n  if (sPeek(idx) === '{') {\n    //\\u{HexDigits}\n    ++idx;\n    let char = sPeek(idx);\n    while (!isEOS(char)) {\n      let hex = getHexValue(char);\n      if (hex === -1) break;\n      hexDigits = (hexDigits << 4) | hex;\n      if (hexDigits > 0x10ffff) {\n        throw this.createILLEGAL(char);\n      }\n      char = sPeek(++idx);\n    }\n    if (char !== '}') {\n      throw this.createILLEGAL(char);\n    }\n    if (idx === start + 1) {\n      throw this.createILLEGAL(stream.peek(idx + 1));\n    }\n    ++idx;\n  } else {\n    //\\uHex4Digits\n    if (isEOS(sPeek(idx + 3))) return -1;\n    let r;\n    for (; idx < start + 4; ++idx) {\n      r = getHexValue(sPeek(idx));\n      if (r === -1) return -1;\n      hexDigits = (hexDigits << 4) | r;\n    }\n  }\n  stream.readString(idx);\n\n  return hexDigits;\n}\n\nexport function readStringEscape(\n  str: string,\n  stream: CharStream,\n  start: number,\n  octal: ?string,\n) {\n  let idx = start + 1, char = stream.peek(idx), lineStart;\n  if (isEOS(char)) throw this.createILLEGAL(char);\n\n  if (!isLineTerminator(char.charCodeAt(0))) {\n    switch (char) {\n      case 'b':\n        str += '\\b';\n        ++idx;\n        break;\n      case 'f':\n        str += '\\f';\n        ++idx;\n        break;\n      case 'n':\n        str += '\\n';\n        ++idx;\n        break;\n      case 'r':\n        str += '\\r';\n        ++idx;\n        break;\n      case 't':\n        str += '\\t';\n        ++idx;\n        break;\n      case 'v':\n        str += '\\u000B';\n        ++idx;\n        break;\n      case 'u':\n      case 'x': {\n        let unescaped;\n        ++idx;\n        let nxt = stream.peek(idx);\n        if (isEOS(nxt)) {\n          throw this.createILLEGAL(nxt);\n        }\n        unescaped = char === 'u'\n          ? scanUnicode.call(this, stream, idx)\n          : scanHexEscape2.call(this, stream);\n        if (unescaped === -1) throw this.createILLEGAL(char);\n        idx = 0; // stream is read in scanUnicode and scanHexEscape2\n\n        str += String.fromCodePoint(unescaped);\n        break;\n      }\n      default: {\n        if ('0' <= char && char <= '7') {\n          [str, idx, octal] = scanOctal.call(\n            this,\n            str,\n            stream,\n            char,\n            idx,\n            octal,\n          );\n        } else if (char === '8' || char === '9') {\n          throw this.createILLEGAL(char);\n        } else {\n          str += char;\n          ++idx;\n        }\n      }\n    }\n  } else {\n    if (char === '\\r' && stream.peek(idx + 1) === '\\n') {\n      ++idx;\n    }\n    ++idx;\n    this.incrementLine();\n    lineStart = idx;\n  }\n  return [str, idx, octal, lineStart];\n}\n\nfunction scanOctal(str, stream, char, start, octal) {\n  let len = 1, idx = start;\n  if ('0' <= char && char <= '3') {\n    len = 0;\n  }\n  let code = 0;\n\n  while (len < 3 && '0' <= char && char <= '7') {\n    ++idx;\n    if (len > 0 || char !== '0') {\n      if (octal == null) octal = '';\n      octal += char;\n    }\n    code *= 8;\n    code += +char; //coersion\n    ++len;\n    char = stream.peek(idx);\n    if (isEOS(char)) {\n      throw this.createILLEGAL(char);\n    }\n  }\n  str += String.fromCharCode(code);\n  return [str, idx, octal];\n}\n\nfunction scanHexEscape2(stream, idx) {\n  let char = stream.peek(idx);\n\n  if (isEOS(char)) return -1;\n\n  let r1 = getHexValue(stream.peek());\n  if (r1 === -1) return r1;\n\n  let r2 = getHexValue(stream.peek(1));\n  if (r2 === -1) return r2;\n\n  stream.readString(2);\n  return (r1 << 4) | r2;\n}\n\nexport function insertSequence(coll: Object, seq: string) {\n  const char = seq[0];\n  if (!coll[char]) {\n    coll[char] = {};\n  }\n  if (seq.length === 1) {\n    coll[char].isValue = true;\n    return coll;\n  } else {\n    coll[char] = insertSequence(coll[char], seq.slice(1));\n    return coll;\n  }\n}\n\nexport const isTerminating = (table: Readtable) => (char: string): boolean =>\n  table.getMapping(char).mode === 'terminating';\n\n// check for terminating doesn't work if it's at the start\nexport function retrieveSequenceLength(\n  table: Object,\n  stream: CharStream,\n  idx: number,\n): number {\n  const char = stream.peek(idx);\n  if (!table[char]) {\n    if (table.isValue) return idx;\n    return -1;\n  } else {\n    return retrieveSequenceLength(table[char], stream, ++idx);\n  }\n}\n\nconst assignOps = [\n  '=',\n  '+=',\n  '-=',\n  '*=',\n  '/=',\n  '%=',\n  '<<=',\n  '>>=',\n  '>>>=',\n  '&=',\n  '|=',\n  '^=',\n  ',',\n];\n\nconst binaryOps = [\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '<<',\n  '>>',\n  '>>>',\n  '&',\n  '|',\n  '^',\n  '&&',\n  '||',\n  '?',\n  ':',\n  '===',\n  '==',\n  '>=',\n  '<=',\n  '<',\n  '>',\n  '!=',\n  '!==',\n  'instanceof',\n];\n\nconst unaryOps = [\n  '++',\n  '--',\n  '~',\n  '!',\n  'delete',\n  'void',\n  'typeof',\n  'yield',\n  'throw',\n  'new',\n];\n\nconst allOps = assignOps.concat(binaryOps).concat(unaryOps);\n\nfunction isNonLiteralKeyword(t: TokenTree) {\n  return isKeyword(t) && t.value && !R.contains(t.value, literalKeywords);\n}\nconst exprPrefixKeywords = [\n  'instanceof',\n  'typeof',\n  'delete',\n  'void',\n  'yield',\n  'throw',\n  'new',\n  'case',\n];\n\nfunction isExprReturn(l: number, p: List<TokenTree>) {\n  // ... return {x: 42} /r /i\n  // ... return\\n{x: 42} /r /i\n  return popRestMaybe(p)\n    .map(\n      ([retKwd, rest]) =>\n        isKeyword(retKwd, 'return') && getLineNumber(retKwd) === l,\n    )\n    .getOrElse(false);\n}\n\n// List a -> Boolean\nfunction isTopPunctuator(p: List<TokenTree>) {\n  return popMaybe(p).map(punc => isPunctuator(punc)).getOrElse(false);\n}\n\nfunction isOperator(op: TokenTree) {\n  if ((isPunctuator(op) || isKeyword(op)) && op.value != null) {\n    const opVal = op.value; // the const is because flow doesn't know op.value isn't mutated\n    return allOps.some(o => o === opVal);\n  }\n  return false;\n}\n\nfunction isTopOperator(p: List<TokenTree>) {\n  return popMaybe(p)\n    .map(op => {\n      return isOperator(op);\n    })\n    .getOrElse(false);\n}\n\nfunction isExprPrefixKeyword(kwd: TokenTree) {\n  return isKeyword(kwd, exprPrefixKeywords);\n}\n\nfunction isTopKeywordExprPrefix(p: List<TokenTree>) {\n  return popMaybe(p)\n    .map(kwd => {\n      return isExprPrefixKeyword(kwd);\n    })\n    .getOrElse(false);\n}\n\nfunction isTopColon(p: List<TokenTree>) {\n  return popMaybe(p)\n    .map(colon => {\n      if (isPunctuator(colon, ':')) {\n        return true;\n      }\n      return false;\n    })\n    .getOrElse(false);\n}\n\nexport function isExprPrefix(l: number, b: boolean, p: List<TokenTree>) {\n  if (p.size === 0) {\n    // ... ({x: 42} /r/i)\n    return b;\n  } else if (isTopColon(p)) {\n    // ... ({x: {x: 42} /r/i })\n    return b;\n  } else if (isTopKeywordExprPrefix(p)) {\n    // ... throw {x: 42} /r/i\n    return true;\n  } else if (isTopOperator(p)) {\n    // ... 42 + {x: 42} /r/i\n    return true;\n  } else if (isTopPunctuator(p)) {\n    // ... for ( ; {x: 42}/r/i)\n    return b;\n  } else if (isExprReturn(l, p)) {\n    // ... return {x: 42} /r /i\n    // ... return\\n{x: 42} /r /i\n    return true;\n  }\n  return false;\n}\n\nfunction popMaybe<T>(p: List<T>): Maybe<T> {\n  if (p.size >= 1) {\n    return Maybe.of(p.last());\n  }\n  return Nothing();\n}\n\nfunction isTopStandaloneKeyword(prefix: List<TokenTree>) {\n  // P . t . t'  where t \\not = \".\" and t' ∈ (Keyword \\setminus  LiteralKeyword)\n  return popRestMaybe(prefix)\n    .map(([kwd, rest]) => {\n      if (isNonLiteralKeyword(kwd)) {\n        return Maybe.maybe(\n          true,\n          dot => !isPunctuator(dot, '.'),\n          popMaybe(rest),\n        );\n      }\n      return false;\n    })\n    .getOrElse(false);\n}\n\nfunction isTopParensWithKeyword(prefix: List<TokenTree>) {\n  // P . t . t' . (T)  where t \\not = \".\" and t' ∈ (Keyword \\setminus LiteralKeyword)\n  return popRestMaybe(prefix)\n    .chain(\n      ([paren, rest]) => (isParens(paren) ? popRestMaybe(rest) : Nothing()),\n    )\n    .map(([kwd, rest]) => {\n      if (isNonLiteralKeyword(kwd)) {\n        return Maybe.maybe(\n          true,\n          dot => !isPunctuator(dot, '.'),\n          popMaybe(rest),\n        );\n      }\n      return false;\n    })\n    .getOrElse(false);\n}\n\nfunction popRestMaybe(p: List<TokenTree>): Maybe<[TokenTree, List<TokenTree>]> {\n  if (p.size > 0) {\n    let last = p.last();\n    let rest = p.pop();\n    return Maybe.of([last, rest]);\n  }\n  return Nothing();\n}\n\nfunction isTopFunctionExpression(\n  prefix: List<TokenTree>,\n  exprAllowed: boolean,\n) {\n  // P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false\n  return popRestMaybe(prefix)\n    .chain(([curly, rest]) => {\n      if (isBraces(curly)) {\n        return popRestMaybe(rest);\n      }\n      return Nothing();\n    })\n    .chain(([paren, rest]) => {\n      if (isParens(paren)) {\n        return popRestMaybe(rest);\n      }\n      return Nothing();\n    })\n    .chain(([optIdent, rest]) => {\n      if (isIdentifier(optIdent)) {\n        return popRestMaybe(rest);\n      }\n      return Maybe.of([optIdent, rest]);\n    })\n    .chain(([fnKwd, rest]) => {\n      if (isKeyword(fnKwd, 'function')) {\n        let l = getLineNumber(fnKwd);\n        if (l == null) {\n          throw new Error('Un-expected null line number');\n        }\n        return Maybe.of(!isExprPrefix(l, exprAllowed, rest));\n      }\n      return Maybe.of(false);\n    })\n    .getOrElse(false);\n}\n\nfunction isTopObjectLiteral(prefix: List<TokenTree>, exprAllowed: boolean) {\n  // P . {T}^l  where isExprPrefix(P, b, l) = false\n  return popRestMaybe(prefix)\n    .chain(([braces, rest]) => {\n      if (isBraces(braces)) {\n        let l = getLineNumber(braces);\n        if (l == null) {\n          throw new Error('Un-expected null line number');\n        }\n        return Maybe.of(!isExprPrefix(l, exprAllowed, rest));\n      }\n      return Maybe.of(false);\n    })\n    .getOrElse(false);\n}\n\nfunction isTopFunction(prefix: List<TokenTree>) {\n  // P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false\n  return popRestMaybe(prefix)\n    .chain(([curly, rest]) => {\n      if (isBraces(curly)) {\n        return popRestMaybe(rest);\n      }\n      return Nothing();\n    })\n    .chain(([paren, rest]) => {\n      if (isParens(paren)) {\n        return popRestMaybe(rest);\n      }\n      return Nothing();\n    })\n    .chain(([optIdent, rest]) => {\n      if (isIdentifier(optIdent)) {\n        return popRestMaybe(rest);\n      }\n      return Maybe.of([optIdent, rest]);\n    })\n    .chain(([fnKwd, rest]) => {\n      if (isKeyword(fnKwd, 'function')) {\n        return Maybe.of(true);\n      }\n      return Maybe.of(false);\n    })\n    .getOrElse(false);\n}\n\nexport function isRegexPrefix(exprAllowed: boolean, prefix: List<TokenTree>) {\n  if (prefix.isEmpty()) {\n    // ε\n    return true;\n  } else if (isTopPunctuator(prefix)) {\n    // P . t   where t ∈ Punctuator\n    return true;\n  } else if (isTopStandaloneKeyword(prefix)) {\n    // P . t . t'  where t \\not = \".\" and t' ∈ (Keyword \\setminus  LiteralKeyword)\n    return true;\n  } else if (isTopParensWithKeyword(prefix)) {\n    // P . t . t' . (T)  where t \\not = \".\" and t' ∈ (Keyword \\setminus LiteralKeyword)\n    return true;\n  } else if (isTopFunction(prefix)) {\n    // P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false\n    return isTopFunctionExpression(prefix, exprAllowed);\n  } else if (isTopObjectLiteral(prefix, exprAllowed)) {\n    // P . {T}^l  where isExprPrefix(P, b, l) = false\n    return true;\n  }\n  return false;\n}\n"}